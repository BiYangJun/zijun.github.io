<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[DllPlugin优化探究]]></title>
    <url>%2F2021%2F03%2F16%2Fdllplugin%2F</url>
    <content type="text"><![CDATA[webpack版本：4.43.0 手动配置DllPlugin DllPlugin是webapck内置的一款可以加快构建速度的插件，其主要优化思想就是用空间换取时间，对于某些不常更新依赖内容，如:vue、vuex、vue-router，UI库等，可以提前打包好，取名为’dll.js’为后缀的打包文件，后面再打包的时候就跳过原来的未打包代码，直接使用之前打包好的文件，依次减少构建速度。 首先要写一个dll的webpack配置文件，放在根目录或者自己新建一个build文件夹都行。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546var path = require('path');const DllPlugin = require('webpack/lib/DllPlugin');/* 将特定的类库提前打包然后引入，不但能够极大减少打包时间，也实现了将公共代码抽离成单独文件的优化方案，可以很大程度的减小打包之后的文件体积。 */module.exports = &#123; // 你想要提前打包的类库的数组。注意 vue 要写成别名 entry: &#123; // 如果这些类库有版本更新了（一般很少更新），就需要重新执行 npm run dll 打包类库，再执行 npm run build 打包项目上线 // 分成多个包 vuebundle: [ 'vue/dist/vue.esm.js', 'vuex', 'vue-router' ], utils: [ 'lodash', 'moment', 'jspdf', 'html2canvas' ], uibundle: [ 'element-ui', '@gs-ui/gs-ui' ] &#125;, output: &#123; path: path.join(__dirname, '../public/js'), // 打包后文件输出的位置，放到项目根目录的 public/js 下 filename: '[name].dll.js', // 打包后的文件名 vendor.dll.js library: '[name]_library' // vendor.dll.js 中暴露出的全局变量名，主要是给 DllPlugin 中的 name 使用。 // 所以这里需要和 webpack.DllPlugin 中的 name: '[name]_library', 保持一致。 &#125;, plugins: [ new DllPlugin(&#123; // manifest.json 生成的文件夹及名字,也就是让它生成在了根目录下 path: path.join(__dirname, './[name]-manifest.json'), // 和 output.library 保持一致即可 name: '[name]_library', // manifest 文件中请求的上下文，默认为本文件的上下文 context: __dirname &#125;) // 这里可以使用 UglifyJsPlugin 插件压缩代码 ]&#125;; 在vue.config.js里增加plugin配置 1234567891011121314151617181920const DllReferencePlugin = require('webpack/lib/DllReferencePlugin'); ... configureWebpack: &#123; plugins: [ // 此插件用于加速打包速度 // new HardSourceWebpackPlugin() // 用于指定对应的json new DllReferencePlugin(&#123; manifest: require('./build/vuebundle-manifest.json') &#125;), new DllReferencePlugin(&#123; manifest: require('./build/utils-manifest.json') &#125;), new DllReferencePlugin(&#123; manifest: require('./build/uibundle-manifest.json') &#125;) ] &#125;, ... 在package.json里增肌一条dll命令 1"dll": "webpack --config ./build/webpack.dll.conf.js", // 路径是dll配置放的路径 执行命令 npm run dll，因为我的dll配置里分成了三个包，所以我会得到三个json与三个dll.js文件，放在配置里指定存放的位置 12345678// build 文件夹下vuebundle-manifest.jsonutils-manifest.jsonuibundle-manifest.json// public/js 文件夹下vue.dll.jsutils.dll.jsui.dll.js 最后一步，在index.html尾部引入三个dll.js文件 1234// index.html&lt;script src='./public/vue.dll.js'&gt;&lt;/script&gt;&lt;script src='./public/utils.dll.js'&gt;&lt;/script&gt;&lt;script src='./public/vue.dll.js'&gt;&lt;/script&gt; 优点： 可以加快构建速度，但其实加速的时间并不多。 缺点： 配置步骤很麻烦，指定依赖更新时，需要手动执行命令进行更新 vue与react的脚手架已经去dll 配置，表示webpack4的打包性能足够好，不需要这个。(相关issues)[https://link.zhihu.com/?target=https%3A//github.com/vuejs/vue-cli/issues/1205] 虽然可以指定依赖内容提前打包，但是开发环境下这些依赖依旧会打包进chunk里。 使用dll自动化配置插件：autodll-webpack-plugin 可以省去繁琐的dll配置，只需要在vue.config.js里增加如下配置即可。 12345678910111213141516npm install autodll-webpack-plugin -D...const AutoDllPlugin = require('autodll-webpack-plugin');...new AutoDllPlugin(&#123; inject: true, // 设为 true 就把 DLL bundles 插到 index.html 里 filename: '[name].dll.js', context: path.resolve(__dirname, './'), // AutoDllPlugin 的 context 必须和 package.json 的同级目录，要不然会链接失败 entry: &#123; vue: [ 'vue/dist/vue.esm.js', 'vuex', 'vue-router' ] &#125;&#125;) 使用为模块提供中间缓存的插件hard-source-webpack-plugin,首次构建时间没有太大变化，但是第二次开始，构建时间会大大减少。配置也非常简单. 123456789npm install hard-source-webpack-plugin -D//webpack.config.jsvar HardSourceWebpackPlugin = require('hard-source-webpack-plugin');module.exports = &#123; //... plugins: [ new HardSourceWebpackPlugin() ]&#125;]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[自问自答系列(持续更新！2-26)]]></title>
    <url>%2F2021%2F02%2F26%2Fqustion-answer%2F</url>
    <content type="text"><![CDATA[1、写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？自答： 要明白key的作用，首先我们要知道列表组件带key与不带key会有什么区别。 前提我们需要知道vue如何更新列表组件的。 在vue的diff函数中。经过交叉对比后，当新节点跟旧节点头尾交叉对比没有结果时，会根据新节点的key去对比旧节点数组中的key，从而找到相应旧节点（这里对应的是一个key =&gt; index 的map映射）。如果没找到就认为是一个新增节点。而如果没有key，那么就会采用遍历查找的方式去找到对应的旧节点。 不带key： 就地复用组件：当 Vue 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。比如绑定的数据项发生了改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。以上是vue官网的说法。当不带key时，在比较新旧两个组件是否是同一个组件的过程中会判断成新旧两个组件是同一个组件，因为 old.key 和 new.key 都是 undefined。所以不会重新创建组件和删除组件，只会在组件的属性层面上进行比较和更新。所以可能在某种程度上（创建和删除组件方面）会有渲染性能上的提升。 无法维持组件的状态：因为时就地复用组件，可能在维持组件状态方面会导致不可预知的错误，比如无法维持改组件的动画效果、开关等状态，在现实业务场景中会有更多不可预知的问题。 也有可能带来性能下降：因为是直接就地复用节点，如果修改的组件，需要复用的很多节点，顺序又和原来的完全不同的话，那么创建和删除的节点数量就会比带 key 的时候增加很多，(为什么会很多)，性能就会有所下降； 带key： 维持组件的状态：保证组件的复用：因为有 key 唯一标识了组件，在进行新旧节点比较的时候，会在接下来的节点中找到 key 相同的节点去比较，能找到相同的 key 的话就复用节点，不能找到的话就增加或者删除节点。 查找性能上的提升：有 key 的时候，会生成 hash（即对应关系），这样在查找的时候就是 hash 查找了，基本上就是 O(1) 的复杂度。 节点复用带来的性能提升：因为有 key 唯一标识了组件，所以会尽可能多的对组件进行复用（尽管组件顺序不同），那么创建和删除节点数量就会变少，这方面的消耗就会下降，带来性能的提升。 衍生问题：为什么不推荐使用数组的index作为列表组件的key？ 官网推荐推荐的使用key，应该理解为“使用唯一id作为key”。因为index作为key，和不带key的效果是一样的。index作为key时，每个列表项的index在变更前后也是一样的，都是直接判断为sameVnode然后复用。 2、[‘1’, ‘2’, ‘3’].map(parseInt) what &amp; why ?自答： 像此类的问题只需要逐个分析函数的参数即可，map函数第一个参数是时候一个callback，而这里相当于parseInt这个函数，callback有三个参数，第一个参数元素本身，第二个参数是下标，第三个参数为执行数组。parseInt第一个参数是需要取整的字符串，第二个参数radix是解析时的基数，是一个介于2-36之间的整数，默认是10。 那么执行’1’的过程就是，parseInt(&#39;1&#39;,0) === 1 为啥为1呢？因为radix为0时，且string参数不以“0x”和“0”开头时，按照10为基数处理。这个时候返回1 那么执行’2’的过程就是，parseInt(&#39;2&#39;,1) === NaN radix是一个介于2-36之间的整数 那么执行’3’的过程就是，parseInt(&#39;3&#39;,2) === NaN 没有数的二进制能用3来表示。 返回的结果为[1,NaN,NaN]。 3、什么是防抖和节流？有什么区别？如何实现？自答： 防抖： 指定时间内，方法只能执行一次。而这个时间的计算，是从最后一次触发监听事件开始算起。 自己的理解：无数次请求执行方法，如果最后一次请求在规定时间内没有再发生请求，那么以最后一次为准 一般表现为，在一段连续触发的事件中，最终会转化为一次方法执行，就像防止抖动一样，你做一个事，防止你手抖不小心重复干了 场景：如在一个输入框内输入文字，你想在输入停止一段时间过后再去获取数据（如过滤），而不是每输入一个文字就去请求一次，那么这时候你就可以利用防抖，指定keyup事件不断触发的过程中不要重复发请求，到最后一次停止输入再去请求。 函数实现 1234567891011121314151617181920212223242526272829303132333435363738394041/** * 防抖函数 * @param &#123;Function&#125; fn - 实际要执行的函数 * @param &#123;Number&#125; wait - 规定在什么时间内执行一次函数，单位是秒 * @param &#123;Boolean&#125; immediate - 是否立即执行，true为立即执行，立即执行指触发监听事件是先执行 * @return &#123;Function&#125; 经过防抖处理后的要执行的函数 */function debounce(fn, wait, immediate) &#123; let timerId = null; // 记录定时器id wait = +wait || 0; // 如果wait没有传，那么初始化0值 if (typeof fn !== 'function') &#123; throw new Error('debounce的第一个参数请传入函数'); return; &#125; // 防抖后的执行函数 function debounced() &#123; timerId &amp;&amp; clearTimeout(timerId); // 如果是立即执行 if (immediate) &#123; // 如果已经过了规定时间，则执行函数 或 第一次触发监听事件 !timerId &amp;&amp; fn.apply(this, arguments); // 规定时间后情况定时器id，表明到达了规定时间 timerId = setTimeout(() =&gt; &#123; timerId = null; &#125;, wait); &#125; else &#123; // 延后执行 // 只有到达了规定时间后才会执行fn函数 timerId = setTimeout(() =&gt; &#123; fn.apply(this, arguments); timerId = null; &#125;, wait); &#125; &#125; // 手动取消该次设定的防抖时间，取消后当成是“第一次触发”一样 function cancel() &#123; clearTimeout(timerId); timerId = null; &#125; debounced.cancel = cancel; return debounced;&#125; 节流： 指定时间内，方法只能执行一次。而这个时间的计算，是从上次执行方法开始算起。 自己的理解：立马执行第一请求，在一次执行方法请求后的规定时间内，不能再次发出请求，规定时间结束后可再次请求，如果规定时间内再次发出，则重置规定时间。 一般表现为，在一段连续触发的事件中，根据你设定的时间间隔，降低触发频率，重复执行。 场景：如你需要做无限加载，监听到滚动条到达底部就加载更多数据，这时候其实你不必要时时刻刻都执行scroll事件绑定的函数，这样没必要，只要把执行频率降低点同样可以达到效果，节约资源。这就是利用节流。 函数实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * 节流函数 * @param &#123;Function&#125; fn - 实际要执行的函数，对其进行节流处理 * @param &#123;Number&#125; wait - 规定的执行时间间隔 * @param &#123;Object&#125; option - 用于设置节流的函数的触发时机， * - 默认是&#123;leading: true, trailing: true&#125;，表示第一次触发监听事件马上执行，停止后最后也执行一次 * - leading为false时，表示第一次触发不马上执行 * - trailing为false时，表示最后停止触发后不执行 * @return &#123;Function&#125; 返回经过节流处理后的函数 */function throttle(fn, wait, option) &#123; let timerId = null; // 用于记录定时器的id let lastTime = 0; // 上次触发fn的时间戳 wait = +wait || 0; // 如果wait没有传，那么初始化0值 option = option || &#123;&#125;; // 如果option没有传，那么初始化&#123;&#125;值 if (typeof fn !== 'function') &#123; throw new Error('throttle的第一个参数请传入函数'); return; &#125; if (option.leading === false &amp;&amp; option.trailing === false) &#123; throw new Error('option的leading 和 trailing不能同时为false'); return; &#125; // 节流后的执行函数 function throttled() &#123; let now = +new Date(); // 获取当前时间 // 如果没有上次触发执行时间（即第一次运行），以及leading设置为false !lastTime &amp;&amp; option.leading === false &amp;&amp; (lastTime = now); // 距离到达规定的wait时间剩余时间 let remainingTime = wait - (now - lastTime); // 条件①：如果到达了规定的间隔时间或用户自己设定了系统时间导致的不合理时间差，则立刻执行一次触发函数 if (remainingTime &lt;= 0 || remainingTime &gt; wait) &#123; fn.apply(this, arguments); lastTime = now; if (timerId) &#123; clearTimeout(timerId); timerId = null; &#125; // 条件②：如果未达到规定时间，以及要求停止后延迟执行（trailing=false） &#125; else if(!timerId &amp;&amp; option.trailing !== false) &#123; timerId = setTimeout(() =&gt; &#123; timerId = null; fn.apply(this, arguments); lastTime = option.leading === false ? 0 : +new Date(); &#125;, remainingTime); &#125; &#125; // 手动提前终止节流时间，恢复初始状态 function cancel() &#123; clearTimeout(timerId); timerId = null; lastTime = 0; &#125; throttled.cancel = cancel; return throttled;&#125; 4、介绍下 Set、Map、WeakSet 和 WeakMap 的区别？自答： Set(集合) Set 是一种叫做集合的数据结构，成员是唯一且无序的，没有重复的值。Set 本身是一种构造函数，用来生成 Set 数据结构。，Set 对象允许你储存任何类型的唯一值，Set 内部判断两个值是否不同的判断类似于精确相等运算符（===），主要的区别是在Set内NaN和NaN是相同的，但是NaN === NaN =&gt; false。 Set的实例方法：add(value)，delete(value)，has(value)，clear()，keys()，values()，entries()，forEach(callbackFn, thisArg)，map()，filter() WeakSet WeakSet 对象允许你将弱引用对象储存在一个集合中。 WeakSet 与 Set 的区别： WeakSet 只能储存对象引用，不能存放值，而 Set 对象都可以 WeakSet 对象中储存的对象值都是被弱引用的，即垃圾回收机制不考虑 WeakSet 对该对象的引用，如果没有其他的变量或属性引用这个对象值，则这个对象将会被垃圾回收掉（不考虑该对象还存在于 WeakSet 中），所以，WeakSet 对象里有多少个成员元素，取决于垃圾回收机制有没有运行，运行前后成员个数可能不一致，遍历结束之后，有的成员可能取不到了（被垃圾回收了），WeakSet 对象是无法被遍历的（ES6 规定 WeakSet 不可遍历），也没有办法拿到它包含的所有元素。 WeakSet实例方法：add(value)，has(value)，delete(value) 1234567891011const foos = new WeakSet()class Foo &#123; constructor() &#123; foos.add(this) &#125; method () &#123; if (!foos.has(this)) &#123; throw new TypeError('Foo.prototype.method 只能在Foo的实例上调用！'); &#125; &#125;&#125; 上面代码保证了Foo的实例方法，只能在Foo的实例上调用。这里使用 WeakSet 的好处是，foos对实例的引用，不会被计入内存回收机制，所以删除实例的时候，不用考虑foos，也不会出现内存泄漏。 Map(字典) 集合 与 字典 的区别： 共同点：集合、字典 可以储存不重复的值（Map里的key如果是引用类型，看上去像”重复”了一样，实际上不重复是指内存地址的不重复） 不同点：集合 是以 [value, value]的形式储存元素，字典 是以 [key, value] 的形式储存 任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构(即[[key,value],[key,value]])都可以当作Map构造函数的参数，例如： Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。 如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等（===），Map 将其视为一个键，比如0和-0就是一个键，布尔值true和字符串&#39;true&#39;则是两个不同的键。另外，undefined和null也是两个不同的键。虽然NaN不严格相等于自身，但 Map 将其视为同一个键（这个点和Set是一样的）。 实例方法：set(key, value)，get(key)，has(key)，delete(key)，clear()，keys()，values()，entries()，forEach(callback(value,key,map),thisArg) WeakMap WeakMap 对象是一组键值对的集合，其中的键是弱引用对象，而值可以是任意。注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。 WeakMap 中，每个键对自己所引用对象的引用都是弱引用，在没有其他引用和该键引用同一对象，这个对象将会被垃圾回收（相应的key则变成无效的），所以，WeakMap 的 key 是不可枚举的。 实例方法：has(key)，get(key)，set(key)，delete(key) 总结： Set 成员唯一、无序且不重复 [value, value]，键值与键名是一致的（或者说只有键值，没有键名） 可以遍历，方法有：add、delete、has WeakSet 成员都是对象 成员都是弱引用，可以被垃圾回收机制回收，可以用来保存DOM节点，不容易造成内存泄漏 不能遍历，方法有add、delete、has Map 本质上是键值对的集合，类似集合 可以遍历，方法很多可以跟各种数据格式转换 WeakMap 只接受对象作为键名（null除外），不接受其他类型的值作为键名 键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的 不能遍历，方法有get、set、has、delete 5、介绍下深度优先遍历和广度优先遍历，如何实现？自答： 12345678910111213141516parent= &#123; child_1: &#123; child_1_1: &#123; child_1_1_1 &#125;, child_1_2: &#123; child_1_2_1 &#125;, child_1_3 &#125;, child_2: &#123; child_2_1, chhild_2_2, &#125;, child_3&#125; 深度优先遍历DFS：深度优先遍历 与树的先序遍历比较类似。从某个顶点出发，首先访问该顶点然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程。有点类似正则中的嵌套捕获，捕获内容以深度优先。 遍历结果为 123456789101112[child_1,child_1_1,child_1_1_1,child_1_2,child_1_2_1,child_1_3,child_2,child_2_1,child_2_2,child_3] 广度优先遍历 BFS:从某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。 如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程。 遍历结果为 12345678910111213[child_1,child_2,child_3,child_1_1,child_1_2,child_1_3,child_2,child_2_1,child_2_2,child_1_1_1,child_1_2_1] 深度优先与广度优先经常用在二叉树的搜索上。 二叉树：一种每个节点不能多于有两个儿子的非线性的数据结构。 6、请分别用深度优先思想和广度优先思想实现一个拷贝函数。7、setTimeout、Promise、Async/Await 的区别事件循环中分为宏任务队列和微任务队列。参考文章 在事件循环中，每进行一次循环操作称为 tick，每一次 tick 的任务处理模型是比较复杂的，但关键步骤如下： 执行一个宏任务（栈中没有就从事件队列中获取） 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行） 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取） 宏任务主要包含：script(整体代码)、setTimeout、setInterval、I/O、UI交互事件、postMessage、MessageChannel、setImmediate(Node.js 环境)。 微任务主要包含：Promise.then、MutaionObserver、process.nextTick(Node.js 环境) 其中settimeout的回调函数放到宏任务队列里，等到执行栈清空以后执行； 浏览器和Node 事件循环的区别，主要区别在node10: Node 10以前：node会先执行完一个阶段的所有任务,将同源的宏任务队列执行完毕后再去清空微任务队列。 Node 11以后：，node与浏览器统一，执行完一个宏任务就会去清空微任务队列 promise本身是同步的立即执行函数，promise.then里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码执行完再执行； async函数表示函数里面可能会有异步方法，await是一个让出线程的标志。await后面的表达式会先执行一遍，将await后面的代码加入到microtask中，然后就会跳出整个async函数来执行后面的代码。 由于因为async await 本身就是promise+generator的语法糖。所以await后面的代码是微任务。 123456789101112async function async1() &#123; console.log('async1 start'); await async2(); console.log('async1 end');&#125;/*等价于*/async function async1() &#123; console.log('async1 start'); Promise.resolve(async2()).then(() =&gt; &#123; console.log('async1 end'); &#125;)&#125; 相关例子 1234567891011121314151617181920212223242526272829303132async function async1() &#123; console.log('async1 start'); await async2(); console.log('async1 end');&#125;async function async2() &#123; console.log('async2');&#125;console.log('script start');setTimeout(function() &#123; console.log('setTimeout');&#125;, 0)async1();new Promise(function(resolve) &#123; console.log('promise1'); resolve();&#125;).then(function() &#123; console.log('promise2');&#125;);console.log('script end');// 运行顺序/*script startasync1 startasync2promise1script endasync1 endpromise2setTimeout*/ 123456789101112131415161718192021222324252627282930313233343536373839404142434445async function a1 () &#123; console.log('a1 start') await a2() console.log('a1 end')&#125;async function a2 () &#123; console.log('a2')&#125;console.log('script start')setTimeout(() =&gt; &#123; console.log('setTimeout')&#125;, 0)Promise.resolve().then(() =&gt; &#123; console.log('promise1')&#125;)a1()let promise2 = new Promise((resolve) =&gt; &#123; resolve('promise2.then') console.log('promise2')&#125;)promise2.then((res) =&gt; &#123; console.log(res) Promise.resolve().then(() =&gt; &#123; console.log('promise3') &#125;)&#125;)console.log('script end')//script starta1 starta2promise2script endpromise1a1 endpromise2.thenpromise3setTimeout 8、JS 异步解决方案的发展历程以及优缺点。 回调函数（callback) 缺点：回调地狱，不能用 try catch 捕获错误，不能 return 优点：解决了同步的问题（只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。这是所有异步解决方案的共同问题） Promise Promise就是为了解决callback的问题而产生的，本质上感觉还是个回调函数，只是代码顺序让人看着舒服。Promise 实现了链式调用，也就是说每次 then 后返回的都是一个全新 Promise，如果我们在 then 中 return ，return 的结果会被 Promise.resolve() 包装 优点：解决了回调地狱的问题 缺点：无法取消 Promise ，错误需要通过回调函数来捕获 Generator 生成器函数 特点：可以控制函数的执行，可以配合 co 函数库使用 缺点：不够普及，需要自行调用next方法继续执行。 Async/await 优点：代码清晰，以同步的方式解决了异步请求，不用像 Promise 写一大堆 then 链，处理了回调地狱的问题 缺点：await 将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用 await 会导致性能上的降低。 9、Promise 构造函数是同步执行还是异步执行，那么 then 方法呢？Promise 构造函数是同步的，then方法也是同步的，只是then里的回电函数callback是异步的。 10、使用 sort() 对数组 [3, 15, 8, 29, 102, 22] 进行排序，输出结果[102, 15, 22, 29, 3, 8],根据MDN上对Array.sort()的解释，默认的排序方法会将数组元素转换为字符串，然后比较字符串中字符的UTF-16编码顺序来进行排序。所以’102’ 会排在 ‘15’ 前面 11、new关键词的作用，如何实现一个new 不用创建临时对象，因为 new 会帮你做（你使用「this」就可以访问到临时对象）； 不用绑定原型，因为 new 会帮你做（new 为了知道原型在哪，所以指定原型的名字为 prototype）； 不用 return 临时对象，因为 new 会帮你做； 不要给原型想名字了，因为 new 指定名字为 prototype。 12345function _new(fn, ...arg) &#123; const obj = Object.create(fn.prototype); const ret = fn.apply(obj, arg); return ret instanceof Object ? ret : obj;&#125; 12、介绍下重绘和回流（Repaint &amp; Reflow），以及如何进行优化重绘：由于节点的几何属性发生改变或者由于样式发生改变而不会影响布局的，称为重绘，例如outline, visibility, color、background-color等，重绘的代价是高昂的，因为浏览器必须验证DOM树上其他节点元素的可见性。 回流：回流是布局或者几何属性需要改变就称为回流。回流是影响浏览器性能的关键因素，因为其变化涉及到部分页面（或是整个页面）的布局更新。一个元素的回流可能会导致了其所有子元素以及DOM中紧随其后的节点、祖先节点元素的随后的回流。 回流必定会发生重绘，重绘不一定会引发回流。 13、改造下面的代码，使之输出0 - 9，写出你能想到的所有解法。12345for (var i = 0; i&lt; 10; i++)&#123; setTimeout(() =&gt; &#123; console.log(i); &#125;, 1000)&#125; 利用 setTimeout 函数的第三个参数，会作为回调函数的第一个参数传入 12345678910// 代码1for (var i = 0; i &lt; 10; i++) &#123; setTimeout(i =&gt; &#123; console.log(i); &#125;, 1000, i)&#125;// 代码2for (var i = 0; i &lt; 10; i++) &#123; setTimeout(console.log, 1000, i)&#125; 利用 bind 函数部分执行的特性 123for (var i = 0; i &lt; 10; i++) &#123; setTimeout(console.log.bind(Object.create(null), i), 1000)&#125; 利用 let 变量的特性 — 在每一次 for 循环的过程中，let 声明的变量会在当前的块级作用域里面（for 循环的 body 体，也即两个花括号之间的内容区域）创建一个文法环境（Lexical Environment），该环境里面包括了当前 for 循环过程中的 i 12345for (let i = 0; i &lt; 10; i++) &#123; setTimeout(() =&gt; &#123; console.log(i); &#125;, 1000)&#125; 利用函数自执行的方式，把当前 for 循环过程中的 i 传递进去，构建出块级作用域。IIFE (自运行函数)其实并不属于闭包的范畴。 1234567891011121314151617181920// 代码1for (var i = 0; i &lt; 10; i++) &#123; (i =&gt; &#123; setTimeout(() =&gt; &#123; console.log(i); &#125;, 1000) &#125;)(i)&#125;// 代码2for (var i = 0; i &lt; 10; i++) &#123; try &#123; throw new Error(i); &#125; catch (&#123; message: i &#125;) &#123; setTimeout(() =&gt; &#123; console.log(i); &#125;, 1000) &#125;&#125; 很多其它的方案只是把 console.log(i) 放到一个函数里面，因为 setTimeout 函数的第一个参数只接受函数以及字符串，如果是 js 语句的话，js 引擎应该会自动在该语句外面包裹一层函数。 12345678910111213141516171819202122// 1for (var i = 0; i &lt; 10; i++) &#123; setTimeout(console.log(i), 1000)&#125;// 2for (var i = 0; i &lt; 10; i++) &#123; setTimeout((() =&gt; &#123; console.log(i); &#125;)(), 1000)&#125;// 3for (var i = 0; i &lt; 10; i++) &#123; setTimeout((i =&gt; &#123; console.log(i); &#125;)(i), 1000)&#125;// 4for (var i = 0; i &lt; 10; i++) &#123; setTimeout((i =&gt; &#123; console.log(i); &#125;).call(Object.create(null), i), 1000)&#125; 利用 eval 或者 new Function 执行字符串 12345678// 1for (var i = 0; i &lt; 10; i++) &#123; setTimeout(eval('console.log(i)'), 1000)&#125;// 2for (var i = 0; i &lt; 10; i++) &#123; setTimeout(new Function('i', 'console.log(i)')(i), 1000)&#125; 14、下面代码中 a 在什么情况下会打印 1？1234var a = ?;if(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3)&#123; console.log(1);&#125; 引用类型在比较运算符时候,隐式转换会调用本类型toString或valueOf方法，所以要将a设置为引用类型，并且重写toString或者valueOf方法。 123456789101112131415161718var a = &#123; i: 1, toString() &#123; return a.i++; &#125;&#125;if( a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3 ) &#123; console.log(1);&#125;// 或者var a = &#123;num:0&#125;;a.valueOf = function()&#123; return ++a.num&#125;if(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3)&#123; console.log(1);&#125; 15、介绍下 BFC 及其应用。BFC全场Block Formatting context(格式化上下文) 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。 具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。 只要元素满足下面任一条件即可触发 BFC 特性： body 根元素 浮动元素：float 除 none 以外的值 绝对定位元素：position (absolute、fixed) display 为 inline-block、table-cells、flex overflow 除了 visible 以外的值 (hidden、auto、scroll) 16、HTTPS为什么比HTTP安全HTTP传输为明文传输，相当于在网络世界裸奔，容易被hacker劫持并且串改传输内容，比如一些微信网页会被当地电信商劫持并且插入广告。 而加密传输就是将传输内容经过一种可逆的数学计算后发送给接受方，接受方通过逆计算获得原数据。 把操作数A作为明文，操作数B作为密钥，结果C作为密文。可以看到加密解密运用同一个密钥B，把这种加解密都用同一个密钥的方式叫做对称加密（AES）。但是对称加密有一个问题，这个对称加密用到的密钥怎么互相告知呢？如果在传输真正的数据之前，先把密钥传过去，那Hacker还是能嗅探到，那之后就了无秘密了。 所以有一种更安全的非对称加密（RSA）方式:任何人都可以通过拿到A公开的公钥对内容进行加密，然后只A自己私有的钥匙才能解密还原出原来内容。但是非对称加密由于要经过更多的计算，所以会被认为性能更低，因此我们用它来先协商对称加密的密钥即可，后续真正通信的内容还是用对称加密的手段，提高整体的性能。 上边虽然解决了密钥配送的问题，但是中间人还是可以欺骗双方，只要在Alice像Bob要公钥的时候，Hacker把自己公钥给了Alice，而Alice是不知道这个事情的，以为一直都是Bob跟她在通信。 为了解决这个问题，我们需要证明这个公钥就是Bob给的，所以我们要看Bob的“身份证”。这个身份证就是一个数字证书。数字证书是一个权威组织CA颁发给Bob的，前边说到用公钥进行加密，只有拥有私钥的人才能解密。数字证书有点反过来：用私钥进行加密，用公钥进行解密。CA用自己的私钥对Bob的信息（包含Bob公钥）进行加密，由于Alice无条件信任CA，所以已经提前知道CA的公钥，当她收到Bob证书的时候，只要用CA的公钥对Bob证书内容进行解密，发现能否成功解开（还需要校验完整性），此时说明Bob就是Bob，那之后用证书里边的Bob公钥来走之前的流程，就解决了中间人欺骗这个问题了。 最后还要解决传输的完整性，单向Hash函数可以把输入变成一个定长的输出串，其特点就是无法从这个输出还原回输入内容，并且不同的输入几乎不可能产生相同的输出，即便你要特意去找也非常难找到这样的输入（抗碰撞性），因此Alice只要将明文内容做一个Hash运算得到一个Hash值，并一起加密传递过去给Bob。Hacker即便篡改了内容，Bob解密之后发现拿到的内容以及对应计算出来的Hash值与传递过来的不一致，说明这个包的完整性被破坏了。 一次安全可靠的通信包括以下几点： 对称加密以及非对称加密来解决：保密性 数字签名：认证、不可抵赖 单向Hash算法：完整性 参考文章 所以HTTPS握手过程为： 1、客户端通过https的url访问服务端要求建立ssh连接 2、服务端收到消息后，把自己的公钥和网站证书(证书里一般有数字签名)打包发给客户端。 3、客户端使收到后，会检查证书的颁发机构以及过期时间, 如果没有问题就随机产生一个会话秘钥。 4、客户端用服务端发过来的的公钥对这个随机产生的会话密钥进行加密发给服务端，服务端再用自己的密钥对其解密获得客户端发过来的会话密钥。(这一步即为非对称加密传输过程) 5、接下来客户端与服务端就可以通过这个会话密钥进行加密传输了(这一步即为对称加密传输过程)。 HTTPS 握手过程中，客户端如何验证证书的合法性？ 浏览器都会有内置的根证书，根据证书上写的CA签发机构，找到对应的证书公钥，用此公钥解开数字签名，得到摘要（digest,证书内容的hash值），据此验证证书的合法性。 17、为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片？够完成整个 HTTP 请求+响应（尽管不需要响应内容）,请求图片资源不会造成跨域的问题，gif相比其他图片资源又是最小的，一般埋点操作后单不需要做响应(响应码为204，即接受到请求但不做响应)，相比XMLHttpRequest 对象发送 GET 请求，性能上更好，因为不会对dom产生影响，所以不会阻塞页面加载，影响用户的体验，只要new Image对象就好了,一般情况下也不需要append到DOM中，通过它的onerror和onload事件来检测发送状态； 1234567&lt;script type="text/javascript"&gt; var thisPage = location.href; var referringPage = (document.referrer) ? document.referrer : "none"; var beacon = new Image(); beacon.src = "http://www.example.com/logger/beacon.gif?page=" + encodeURI(thisPage) + "&amp;ref=" + encodeURI(referringPage);&lt;/script&gt; 18、模拟实现一个 Promise.finally1234567Promise.protptype.finally = function(callback) &#123; let P = this.constructor; return this.then( value =&gt; P.resolve(callback()).then(()=&gt;value), reason =&gt; P.reject(callback()).then(()=&gt;&#123; throw.reason&#125; ) )&#125; in运算符会检查到原型链上，hasOwnProperty方法只会检查到实例上 19、用已有的promise实现 Prmoise.all方法首先需要将输入数组中的所有 Promise 对象均运行起来； 2. 在有 Promise 对象 resolve 后，判断是否所有对象均已 resolve，当所有 Promise 均被 resolve 后进行整体的 resolve；此外，当任何一个 Promise 对象出现 reject 后，直接 reject。 1234567891011121314151617181920212223function promiseAll(promises) &#123; return new Promise(function(resolve, reject) &#123; if (!isArray(promises)) &#123; return reject(new TypeError('arguments must be an array')); &#125; var resolvedCounter = 0; var promiseNum = promises.length; var resolvedValues = new Array(promiseNum); for (var i = 0; i &lt; promiseNum; i++) &#123; (function(i) &#123; Promise.resolve(promises[i]).then(function(value) &#123; resolvedCounter++ resolvedValues[i] = value if (resolvedCounter == promiseNum) &#123; return resolve(resolvedValues) &#125; &#125;, function(reason) &#123; return reject(reason) &#125;) &#125;)(i) &#125; &#125;)&#125; 20、用已有的promise实现 Prmoise.race方法上面的修改一下，不用resolvedCounter == promiseNum判断。 21、闭包的理解你不知道的JS摘抄：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。(无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包)。本质上无论何时何地，如果将(访问它们各自词法作用域的)函数当作第一 级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、 Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步(或者同步)任务中，只要使 用了回调函数，实际上就是在使用闭包! 22、精度问题如何判断0.1+0.2和0.3是否相等？最常见的方法是设置一个误差范围值，通常称为“机器精度”，对于JavaScript来说，这个值通常是2^-52。在ES6开始，该值定义在Number.EPSILON中，ES6之前的版本可以写polyfill:Math.pow(2, -52)。可是使用Number.EPSILON来比较俩个数字是否相等。 123456function numbersCloseEnoughToEqual(n1,n2) &#123; return Math.abs( n1 - n2 ) &lt; Number.EPSILON;&#125;var a = 0.1 + 0.2;var b = 0.3;numbersCloseEnoughToEqual( a, b ); 23、原型链[[Prototype]] 机制就是存在于对象中的一个内部链接，它会引用其他对象，通常来说，这个链接的作用是:如果在对象上没有找到需要的属性或者方法引用，引擎就 会继续在[[Prototype]]关联的对象上进行查找。同理，如果在后者中也没有找到需要的引用就会继续查找它的[[Prototype]]，以此类推。这一系列对象的链接被称为“原型链”。 24、Promise1234567// Promise.resolve // 返回一个Promise，状态为fulfilled// Promise.reject // 返回一个Promise，状态为rekected// Promise.all // 所有都成功=&gt;fulfilled 有一个失败=&gt;rejected// Promise.race // 有一个率先改变，就跟着它的状态// Promise.any // 有一个成功=&gt;fulfilled 全部失败=&gt;rejected// Promise.allSettled // 无论成功失败，等所有都改变了状态，返回为一个数组包含了每个Promise的值和状态// Promise.try // 如果是同步代码执行同步的，异步的就返回Promise，和async 函数相似 手写实现一个简单版的Promise 123456789101112131415161718192021222324252627282930313233343536let pending = 'pending';let reject = 'reject';let resolve = 'resolve';class Promise &#123; constructor(fn) &#123; this.status = pending; this.value = ''; this.reason = ''; this.resolveCbs = []; this.rejectCbs = []; function resolve(value) &#123; if (this.status !== pending) return; this.status = resolve; this.value = value; this.resolveCbs.map(fn =&gt; fn(this.value)); &#125; function reject(reason) &#123; if (this.status !== pending) return; this.status = reject; this.reason = reason; this.rejectCbs.map(fn =&gt; fn(this.reason)); &#125; fn(resolve.bind(this), reject.bind(this)) &#125; then(onResolve, onReject) &#123; if (this.status === resolve) &#123; onResolve(this.value) &#125; else if (this.status === reject) &#123; onReject(this.reason) &#125; else if (this.status === pending) &#123; this.resolveCbs.push(onResolve); this.rejectCbs.push(onReject); &#125; &#125;&#125; 25、async awaitasync函数的返回值是 Promise 对象，async函数内部return语句返回的值，会成为then方法回调函数的参数。async函数内部抛出错误，会导致返回的 Promise 对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到。只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。 async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。 任何一个await语句后面的 Promise 对象变为reject状态，那么整个async函数都会中断执行。有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个await放在try…catch结构里面，这样不管这个异步操作是否成功，第二个await都会执行。另一种方法是await后面的 Promise 对象再跟一个catch方法，处理前面可能出现的错误。 26、http2二进制分帧： HTTP/2 采用二进制格式传输数据，而非 HTTP 1.x 的文本格式，二进制协议解析起来更高效。HTTP / 1 的请求和响应报文，都是由起始行，首部和实体正文（可选）组成，各部分之间以文本换行符分隔。HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码。HTTP/2 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流 多路复用：多路复用，代替原来的序列和阻塞机制。所有就是请求的都是通过一个 TCP连接并发完成。 HTTP 1.x 中，如果想并发多个请求，必须使用多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 6-8个的TCP链接请求限制，如下图，红色圈出来的请求就因域名链接数已超过限制，而被挂起等待了一段时间。 服务器推送：服务端可以在发送页面HTML时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。例如服务端可以主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML时再发送这些请求。服务端可以主动推送，客户端也有权利选择是否接收。 头部压缩：HTTP 1.1请求的大小变得越来越大，有时甚至会大于TCP窗口的初始大小，因为它们需要等待带着ACK的响应回来以后才能继续被发送。HTTP/2对消息头采用HPACK（专为http/2头部设计的压缩格式）进行压缩传输，能够节省消息头占用的网络的流量。 27、JS继承的方式 原型链继承 1234function Cat()&#123;&#125;Cat.prototype = new Animal()Cat.prototype = 'cat'var cat = new Cat(); 构造继承 12345function Cat(name)&#123; Animal.call(this); this.name = name || 'cat';&#125;var cat = new Cat(); 实例继承 12345function Cat(name)&#123; var instance = new Animal(); instance.name = name || 'Tom'; return instance;&#125; 拷贝继承 1234567function Cat(name) &#123; var animal = new Animal(); for(var p in animal)&#123; Cat.prototype[p]=animal[p]; &#125; Cat.prototype.name = name || 'Tom';&#125; 组合继承 12345function Cat(name) &#123; Animal.call(this); this.name = name || 'Tom';&#125;Cat.prototype = new Animal(); 寄生组合继承 123456789function Cat(name) &#123; Animal.call(this); this.name = name || 'Tom';&#125;(function()&#123; var Super = function()&#123;&#125;; Super.prototype = Animal.prototype; Cat.prototype = new Super();&#125;)() 28、三次握手，四次挥手TCP提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接，采用四次挥手关闭一个连接。 三次握手的作用就是双方都能明确自己和对方的收、发能力是正常的。需要三次握手才能确认双方的接收与发送能力是否正常 第一次握手：客户端发送网络包。服务端收到，服务端得出结论：客户端的发送能力、服务端的接受能力是正常的。 第二次握手：服务端发包，客户端收到了，这样客户端得出结论：服务端的接收、发送能留，客户端的接收、发送能力是正常的。 第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。 经历了上面三次握手过程，客户端和服务端都确认了自己的接收、发送能力是正常的，之后就可以正常通信了。 四次挥手，TCP连接是双向传输的对等模式，就是说双方都可以同时向对方发送或接收数据，当有一方要关闭连接时，会发送指令告知对方。为什么是四次，是由于TCP的半关闭照成的，半关闭就是TCP提供了连接的一端在结束它的发送后还能接受来自另一段数据的能力。 为什么挥手需要四次：当服务端收到客服端SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，”你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。 29、快速排序 先找到一个基准点（一般指数组的中部），然后数组被该基准点分为两部分，依次与该基准点数据比较，如果比它小，放左边；反之，放右边。左右分别用一个空数组去存储比较后的数据，最后递归执行上述操作，直到数组长度 &lt;= 1。 1234567891011121314151617function quickSort(list) &#123; if (list.length &lt;= 1) &#123; return list; &#125; let minInd = Math.floor(list.length / 2); let left = []; let right = []; let minVal = list.splice(minInd,1)[0]; for (let i =0; i &lt; list.length; i++) &#123; if (list[i] &lt; minVal) &#123; left.push(list[i]) &#125; else &#123; right.push(list[i]) &#125; &#125; return [...quickSort(left), minVal, ...quickSort(right)]&#125;]]></content>
      <categories>
        <category>自问自答</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeeCode常见算法系列(持续更新！2-26)]]></title>
    <url>%2F2021%2F02%2F26%2Fleetcode%2F</url>
    <content type="text"><![CDATA[数组中的第K个最大元素 https://leetcode-cn.com/problems/kth-largest-element-in-an-array 选择最大数排序，选到下标为k-1的元素时，就可以返回了 12345678910111213141516var findKthLargest = function(nums, k) &#123; let maxInd, tmp; let len = nums.length; for (let i = 0 ; i &lt; len; i++) &#123; maxInd = i; for (let j = i+1; j &lt; len; j++) &#123; if (nums[j] &gt; nums[maxInd]) &#123; maxInd = j; &#125; &#125; tmp = nums[i]; nums[i] = nums[maxInd]; nums[maxInd] = tmp; if (i === k -1) return nums[i]; &#125;&#125;; 长度最小的子数组 https://leetcode-cn.com/problems/minimum-size-subarray-sum 滑动窗口，维护俩个下标值start，end，通过Math.min记录窗口的最小长度 1234567891011121314151617var minSubArrayLen = function(target, nums) &#123; if (nums.length === 0) return 0; let min = 999999999999; let start = 0; let end = 0; let sum = 0; while(end &lt; nums.length) &#123; sum += nums[end]; while(sum &gt;= target) &#123; min = Math.min(min, end - start + 1) sum -= nums[start]; start++; &#125; end++ &#125; return min === 999999999999 ? 0 : min;&#125;; 合并两个有序数组 https://leetcode-cn.com/problems/merge-sorted-array 最直接调用api的方法（不推荐）123456var merge = function(nums1, m, nums2, n) &#123; nums1.splice(m); nums2.splice(n); nums1.push(...nums2); return nums1.sort((a,b)=&gt; a-b);&#125;; 路径总和 https://leetcode-cn.com/problems/path-sum 先收集所有从根到叶子节点的路径，然后判断路径有没有相加为targetSum的 1234567891011121314151617var hasPathSum = function(root, targetSum) &#123; if (!root) return false; let result = []; function fn(node, pathArr) &#123; if (!node.left &amp;&amp; !node.right) &#123; result.push(pathArr); &#125; if (node.left) &#123; fn(node.left, [...pathArr, node.left.val]) &#125; if (node.right) &#123; fn(node.right, [...pathArr, node.right.val]) &#125; &#125; fn(root, [root.val]); return result.some(item =&gt; item.reduce((pre, next)=&gt;pre+next, 0) === targetSum);&#125;; 递归，到最后的叶子节点，判断当前的数字是不是0 12345678910var hasPathSum = function(root, targetSum) &#123; if (!root) return false; targetSum -= root.val; if (!root.left &amp;&amp; !root.right) &#123; if (targetSum === 0) return true; else return false; &#125; let val = root.val; return hasPathSum(root.left || &#123;&#125;, targetSum) || hasPathSum(root.right || &#123;&#125;, targetSum)&#125;; 字符串相加 https://leetcode-cn.com/problems/add-strings 简单的加法运算 123456789101112131415161718192021var addStrings = function(num1, num2) &#123; let p1 = num1.length - 1; let p2 = num2.length - 1; let tmp = 0; let arr = []; while(p1 &gt;= 0 || p2 &gt;= 0 || tmp !== 0) &#123; let count1 = num1.charAt(p1) ? num1.charAt(p1) - 0 : 0; let count2 = num2.charAt(p2) ? num2.charAt(p2) - 0 : 0; let sum = count1 + count2 + tmp; if (sum &lt; 10) &#123; arr.unshift(sum); tmp=0; &#125; else &#123; tmp = Math.floor(sum / 10); arr.unshift(sum % 10); &#125; p1--; p2--; &#125; return arr.join('');&#125;; 比较版本号 https://leetcode-cn.com/problems/compare-version-numbers 自个的想法，挨个数比较 12345678910111213141516171819202122232425var compareVersion = function(version1, version2) &#123; let arr1 = version1.split('.'); let arr2 = version2.split('.'); let p1 = 0; let p2 = 0; while(p1 &lt; arr1.length || p2 &lt; arr2.length) &#123; if (arr1[p1] === undefined &amp;&amp; arr2[p2] - 0 !== 0) &#123; return -1; &#125; if (arr2[p2] === undefined &amp;&amp; arr1[p1] - 0 !== 0) &#123; return 1; &#125; let n1 = arr1[p1] - 0; let n2 = arr2[p2] - 0; if (n1 &gt; n2) &#123; return 1; &#125; if (n1 &lt; n2) &#123; return -1; &#125; p1++; p2++; &#125; return 0;&#125;; 翻转二叉树 https://leetcode-cn.com/problems/invert-binary-tree 递归，用一个暂时的中间变量 12345678910111213141516var invertTree = function(root) &#123; function fn(node) &#123; if (!node) return; let tmp = node.left; node.left = node.right; node.right = tmp; if (node.left) &#123; fn(node.left) &#125; if (node.right) &#123; fn(node.right) &#125; &#125; fn(root) return root;&#125;; 两数之和 https://leetcode-cn.com/problems/two-sum 哈希表，用空间换时间 12345678910111213var twoSum = function(nums, target) &#123; let map = new Map(); let tmp; map.set(nums[0], 0); for (let i = 1; i &lt; nums.length; i++) &#123; tmp = target - nums[i]; if (map.get(tmp) !== undefined) &#123; return [map.get(tmp), i] &#125; else &#123; map.set(nums[i], i) &#125; &#125;&#125;; 路径总和 II https://leetcode-cn.com/problems/path-sum-ii/ 递归，得到每一条路径，然后最后判断这条路径的数相加是不是目标数 1234567891011121314151617181920var pathSum = function(root, targetSum) &#123; if (!root) return []; let result = []; function fn(node, arr) &#123; if (!node.left &amp;&amp; !node.right) &#123; if (arr.reduce((a,b) =&gt; a+b, 0) === targetSum) &#123; result.push(arr); &#125; return; &#125; if (node.left) &#123; fn(node.left, [...arr, node.left.val]) &#125; if (node.right) &#123; fn(node.right, [...arr, node.right.val]) &#125; &#125; fn(root, [root.val]) return result;&#125;; 141 判断环形链表 https://leetcode-cn.com/problems/linked-list-cycle 使用一个set数据记录每一步的数据 12345678910var hasCycle = function(head) &#123; let set = new Set(); let pre = head; while(pre) &#123; if (set.has(pre)) return true; set.add(pre) pre = pre.next; &#125; return false;&#125;; 快慢指针，快指针走俩步，慢指针走一步，相等了就是环形 123456789101112var hasCycle = function(head) &#123; let d = new ListNode(); d.next = head; let fast = slow = d; if (!fast.next || !fast.next.next) return false; while(fast &amp;&amp; fast.next) &#123; fast = fast.next.next; slow = slow.next; if (fast === slow) return true; &#125; return false;&#125;; 53 最大子序和 https://leetcode-cn.com/problems/maximum-subarray/submissions/ 动态规划 12345678var maxSubArray = function(nums) &#123; let pre = 0, maxAns = nums[0]; nums.forEach((x) =&gt; &#123; pre = Math.max(pre + x, x); maxAns = Math.max(maxAns, pre); &#125;); return maxAns;&#125;; 买卖股票的最佳时机 https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock 维护一个最大值 123456789101112131415var maxProfit = function(prices) &#123; let len = prices.length; let min = prices[0]; let result = -1; let start = 1; while(start &lt; len) &#123; if (prices[start] &lt; min) &#123; min = prices[start]; &#125; else if (min &lt; prices[start]) &#123; result = Math.max(result, prices[start] - min); &#125; start++; &#125; return result === -1 ? 0 : result;&#125;; 二叉树的中序遍历 https://leetcode-cn.com/problems/binary-tree-inorder-traversal 中序遍历： 按照访问左子树——根节点——右子树的方式遍历这棵树，而在访问左子树或者右子树的时候我们按照同样的方式遍历，直到遍历完整棵树。 123456789101112131415var inorderTraversal = function(root) &#123; let result = []; function fn(node) &#123; if (!node) return; if (node.left) &#123; fn(node.left) &#125; result.push(node.val); if (node.right) &#123; fn(node.right) &#125; &#125; fn(root) return result;&#125;; 三数只和 https://leetcode-cn.com/problems/3sum/ 先对数组进行从小到大的排序，再对排序数组进行循环，如果当前数大与0，已经不可能有三数相加为0了，跳出循环，维护左右俩个指针，相加三个数，和为0的时候，加入结果，并且为了避免没有重复数据，要对俩个指针进行while循环，去除重复数据，小于0 的时候，左边++，大于0 的时候右边减减。 123456789101112131415161718192021222324252627282930var threeSum = function(nums) &#123; let len = nums.length; if (len &lt; 3) return []; if (len === 3) &#123; return nums[0] + nums[1] + nums[2] === 0 ? [nums] : []; &#125; let result = []; let sortNums = nums.sort((a,b)=&gt;a-b); for (let p = 0; p &lt; len; p++) &#123; if (sortNums[p] &gt; 0) break; if (p &gt; 0 &amp;&amp; sortNums[p] === sortNums[p-1]) continue; let left = p + 1; let right = len - 1; while(left &lt; right) &#123; let sum = sortNums[p] + sortNums[left] + sortNums[right]; if (sum === 0) &#123; result.push([sortNums[p],sortNums[left],sortNums[right]]) while(left &lt; right &amp;&amp; sortNums[left] === sortNums[left+1]) left++; while(left &lt; right &amp;&amp; sortNums[right] === sortNums[right-1]) right--; left++; right--; &#125; else if (sum &gt; 0) &#123; right--; &#125; else &#123; left++; &#125; &#125; &#125; return result;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Webpack优化总结]]></title>
    <url>%2F2021%2F01%2F24%2Fwebpack%2F</url>
    <content type="text"><![CDATA[缩小文件搜索范围 优化loader配置。 由于Loader对文件的转化操作很耗时，需要让尽可能少的文件被Loader处理。为了尽可能少的让文件被 Loader 处理，可以通过 include 去命中只有哪些文件需要被处理。 优化resolve.modules配置 resolve.modules 用于配置 Webpack 去哪些目录下寻找第三方模块。resolve.modules 的默认值是 [‘node_modules’]，含义是先去当前目录下的 ./node_modules 目录下去找想找的模块，如果没找到就去上一级目录 ../node_modules 中找，再没有就去 ../../node_modules 中找，以此类推，这和 Node.js 的模块寻找机制很相似。 当安装的第三方模块都在项目根目录下的 ./node_modules 目录下时，没有必要按照默认方式去一层层的寻找，可以指明存放第三方模块下的绝对路径，以减少寻找。 1234567module.exports = &#123; resolve: &#123; // 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤 // 其中 __dirname 表示当前工作目录，也就是项目根目录 modules: [path.resolve(__dirname, &apos;node_modules&apos;)] &#125;,&#125;; 优化resove.mainFields配置 resove.mainFields 用于配置第三方模块使用哪个入口文件。安装的第三方模块中会有一个 package.json 文件用于描述这个模块的属性，其中有些字段用于描述入口文件在哪里，resolve.mainFields 用于配置采用哪个字段作为入口文件的描述。可以存在多个字段描述入口文件的原因是因为有些模块可以同时用在多个环境中，针对不同的运行环境需要使用不同的代码。 为了减少搜索步骤，在你明确第三方模块的入口文件描述字段时，你可以把它设置的尽量少。 由于大多数第三方模块都采用 main 字段去描述入口文件的位置，直接把mainFields设置为[main] 优化resolve.alias配置 resolve.alias 配置项通过别名来把原导入路径映射成一个新的导入路径。 vue-cli3的默认配置已做次优化：12345alias: &#123; &apos;@&apos;: &apos;/Users/biyangjun/gridsum/zeta/metaspace-ui/src&apos;, vue$: &apos;vue/dist/vue.runtime.esm.js&apos;, // 直接将Vue库指向Vue源码中的runtime版本文件，从而跳过耗时的递归解析操作 src: &apos;/Users/biyangjun/gridsum/zeta/metaspace-ui/src&apos;&#125;, 优化 resolve.extensions 配置 在导入语句没带文件后缀时，Webpack 会自动带上后缀后去尝试询问文件是否存在，resolve.extensions 用于配置在尝试过程中用到的后缀列表，默认为[‘.js’,’.json’]。 后缀尝试列表尽可能的小，不要把项目中不可能存在的情况写到后缀尝试列表中。 频率出现最高的文件优先放到最前面，做到尽快的退出寻找过程。 在源码中写入导入语句时，要经可能带上后缀，避免寻找过程。 优化module.noParse配置 module.noParse 配置项可以让Webpack忽略对部分没采用模块化的文件的递归解析处理，这样做的好处是能提高构建性能。原因是一些库，例如 jQuery 、ChartJS， 它们庞大又没有采用模块化标准，让 Webpack 去解析这些文件耗时又没有意义。 注意被忽略掉的文件里不应该包含 import 、 require 、 define 等模块化语句，不然会导致构建出的代码中包含无法在浏览器环境下执行的模块化语句。 使用可以多进程处理的Plugin 使用HappyPack 在整个Webpack构建流程中，最耗时的流程可能就是Loader对文件的转换操作，因为需要转换的文件太多，而且这些转换操作只能一个个挨着处理，HappyPack和核心原理就是把这部分任务分解到多个进程去并行处理，从而减少总的构建时间。 核心调度器的逻辑代码在主进程中，也就是运行着 Webpack 的进程中，核心调度器会把一个个任务分配给当前空闲的子进程，子进程处理完毕后把结果发送给核心调度器，它们之间的数据交换是通过进程间通信 API 实现的。核心调度器收到来自子进程处理完毕的结果后会通知 Webpack 该文件处理完毕。 Webpack4官方推出了 thread-loader, 把这个loader放置在其他loader之前，放置在这个loader之后的loader就会在一个单独的worker池中运行。但在worker池中运行的loader是受到限制的，例如： 这些loader不能产生新的文件 这些loader不能使用定制的loader API(也就是通过插件) 这些loader无法获取webpack的选项设置 使用ParalleUglifyPlugin 在使用 Webpack 构建出用于发布到线上的代码时，都会有压缩代码这一流程。 最常见的 JavaScript 代码压缩工具是 UglifyJS，并且 Webpack 也内置了它。由于压缩JavaScript代码需要先把代码解析成用Objectt抽象表示的AST语法树，再去应用各种规则分析和处理AST，导致这个过程计算量巨大，耗时非常多。 ParalleUglifyPlugin会开启多个子进程，把对多个文件的压缩工作分配给多个子进程完成，每个子进程其实还是通过UglifyJS去压缩代码，但是变成了并行执行，所以ParalleUglifyPlugin能更快的完成对多个文件的压缩工作。 Webpack文件监听的原理在Webpack中监听一个文件发生变化的原理是定时的去获取这个文件的最后编辑时间，每次都存下最新的最后编辑时间，如果发现当前获取的和最后一次保存的最后编辑时间不一致，就认为该文件发生了变化。当发现某个文件发生了变化时，并不会立刻告诉监听者，而是先缓存起来，收集一段时间的变化后，再一次性告诉监听者。 压缩代码 从UglifyJS入手 浏览器从服务器访问网页时获取的js、css资源都是文本形式的，文件越大网页加载时间越长。 为了提升网页加速速度和减少网络传输流量，可以对这些资源进行压缩，压缩的方法除了可以通过GZIP算法对文件压缩外，还可以对文本本身进行压缩。 目前最成熟的JavaScript代码压缩工具是UglifyJS，它会分析JavaScript代码语法树，理解代码含义，从而能做到诸如去掉无效代码，去掉日志输出代码，缩短变量名等优化。 UglifyJS如何改写配置以达到最优的压缩效果。 sourceMap：是否为压缩后的代码生成对应的SourceMap，默认不开启，开启后耗时会大大增加。建议不开启。 beautify：是否输出可读性较强的代码，即会保留空格和制表符，默认是。建议关闭。 comments：是否保留代码中的注释，默认为保留。可以关闭。 compress.warnings: 是否在UglifyJS删除没有用到的代码时输出警告信息，默认开启。可以关闭。 drop_console: 是否删除代码中的console语句，默认为不删除。可以开启删除，开启后不仅可以提升代码压缩效果，也可以兼容不支持console语句的IE浏览器。 collapse_vars：是否内嵌定义了但是只用到一次的变量，例如把 var x = 5; y = x 转换成 y = 5，默认为不转换。为了达到更好的压缩效果，可以设置为 true。 reduce_vars： 是否提取出出现多次但是没有定义成变量去引用的静态值，例如把 x = ‘Hello’; y = ‘Hello’ 转换成 var a = ‘Hello’; x = a; y = b，默认为不转换。为了达到更好的压缩效果，可以设置为 true。 压缩ES6 因为ES6的代码相比转换后的ES5代码有以下优点 一样的逻辑ES6实现的代码量比ES5少 JS引擎对ES6中的语法做了性能优化。 所以在运行环境允许的情况下，要尽可能的使用原生的ES6代码去运行。但是UglifyJS只认识ES5语法的代码，为了压缩ES6代码，需要专门针对ES6代码的UglifyES。 UglifyES 和 UglifyJS 来自同一个项目的不同分支，它们的配置项基本相同，并且在给 Webpack 接入 UglifyES 时，不能使用内置的 UglifyJsPlugin，而是需要单独安装和使用最新版本的 uglifyjs-webpack-plugin。 优化配置和上面的配置一样。 压缩CSS 目前比较成熟可靠的css压缩工具是cssnano，基于PostCSS，把 cssnano 接入到 Webpack 中也非常简单，因为 css-loader 已经将其内置了，要开启 cssnano 去压缩代码只需要开启 css-loader 的 minimize 选项。 1use: [&apos;css-loader?minimize&apos;] 使用Tree ShakingTree Shaking 可以用来剔除JS上用不到的死代码，它依赖静态的ES6模块化语法，例如通过import和export导入导出。 栗子： 12345678// 一个工具函数文件 util.jsexport function a() &#123;&#125;export function b() &#123;&#125;export const d = &apos;d&apos;;// 使用到util.js的main.jsimport &#123;a&#125; from &apos;./utils.js&apos;// 经过Tree Shaking处理后的util.jsexport function a() &#123;&#125;]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue源码分析]]></title>
    <url>%2F2020%2F06%2F24%2Fvue-code%2F</url>
    <content type="text"><![CDATA[作为一名日常使用Vue开发的前端开发，Vue的源码是有意义去了解的。今天的分享主要是Vue2.x源码的部分概念，包括以下三个内容：Vue的初始化、挂载与渲染流程、响应式系统的构建。 1. Vue的初始化在所有以Vue为开发框架的项目里，都必定会执行new Vue语句来形成Vue的根实例。那么在源码里都干了些什么事呢？ 在源码里，Vue是一个非常简单的以Function实现的类。在src/core/instance/index.js里定义了它。并且在这里执行了初始化所需要的所有方法函数。 1234567891011121314function Vue (options) &#123; if (process.env.NODE_ENV !== 'production' &amp;&amp; !(this instanceof Vue) ) &#123; warn('Vue is a constructor and should be called with the `new` keyword') &#125; this._init(options)&#125;initMixin(Vue)stateMixin(Vue)eventsMixin(Vue)lifecycleMixin(Vue)renderMixin(Vue) Vue源码都在src目录下，并且它的目录结构是非常清晰的，概括如下。1234567src ├── compiler # 编译相关 ├── core # 核心代码 ├── platforms # 不同平台的支持 ├── server # 服务端渲染 ├── sfc # .vue 文件解析 ├── shared # 共享代码 这里可以看出，代码保证了Vue只能通过new关键字进行初始化，一系列的mixin方法分别定义了原型上与数据，事件，生命周期，渲染相关的静态属性与方法，也就是以$开头的那些属性与方法。而_init方法来自initMixin中，其内部也是进行一系列初始化操作，包括选项的规范校验与合并，初始化生命周期，初始化事件中心，构建数据响应式系统等。最后最关键的根据我们填写的el参数，来进行模版的渲染与挂载。 选项的合并是一个很关键的点，因为我们平时写的组件代码都是通过配置的方式传入并且执行Vue内部的方法Vue.extend去创建一个子类的，那么子类的选项必定会与父类的选项产生合并行为，大致分为常规选项合并，自带资源的合并(‘compoent’,’directive’,’filter’),生命周期函数的合并。其中，为什么在new Vue里data选项能写成Object形式，组件里要写成Functino的原因也在这里。(因为源代码里写死了，不是Function就会报错，哈哈，当然最终目的还是为了保证组件的复用，数据不互相影响) 在所有配置初始化完成后，如果我们配置el参数存在，会执行Vue的内部方法$mount。 123if (vm.$options.el) &#123; vm.$mount(vm.$options.el)&#125; 而$mount函数定义的地方会与我们选择的平台和构建版本有关。比如在platforms文件夹里有web和weex俩个平台，web里有一些入口文件js，为了保证性能以及代码体积更小，我们使用的都是runtime only的构建版本(基本上就是除去编译器外的完整代码)，而编译的工作都交给了webpack的vue-loader了。但是为了更好分析Vue源码，我们要看runtime + compiler的版本，所以这时候我们要找的$mount方法在src/platforms/web/entry-runtime-with-compiler里，但是$mount的核心方法是mountComponent方法。 mountComponent方法定义在src/core/instance/lifecycle.js里，其主要作用就是进行模版的挂载、执行beforeMount,mounted生命周期函数、实例化一个组件只有一个的渲染Watcher。 2. 挂载与渲染流程在Vue的内部方法$mount里有着挂载和渲染过程的一切，大概流程图如下。 根据流程图我们可以得知以下这么几个点： 确定挂载的DOM，这个DOM不能是boyd，html标签 template模版的写法会被编译，首先会被编译成字符串模板会转换为抽象的语法树(AST)，最终被编译成render函数。(在runtime-only版本中这一步交给插件了) 无论是template模板还是手写render函数，最终都将进入mountComponent过程,这个阶段会实例化一个渲染watcher。 渲染wathcer的莫一个参数是updateComponent函数，其内部通过_render方法将render函数生成为虚拟DOM树(一个以VNode类生成的Virtual Dom)，_update方将虚拟DOM生成真实的DOM。 123updateComponent = () =&gt; &#123; vm._update(vm._render(), hydrating)&#125; 其中编译的过程Vue源码里有一个名为compiler的文件夹来处理，不用去看懂，我们只需要知道编译的流程是怎样的即可。compiler的入口为一个名为createCompiler的函数。 因为不同平台对Vue的编译过程是不一样的，所以传给createCompiler的配置是不一样的，比如Vue内置的只有web和weex俩个平台，像市场上比较流行Vue跨端开源项目，如mpVue，uni-app等都会在platform下添加一个对应的文件夹。 内部经过一系列的处理会生成三种东西。 AST抽象树，一个对象，里面放了各种属性，方法的描述 render 一个以函数封装好的with语句 staticRenderFns 以数组形式存在的静态render 有了render函数后，接下来就是将它解析成虚拟DOM，在Vue中，就是用VNode这个构造函数去描述一个真实DOM节点，但并不会把真实DOM所有的东西都描述出来，因为真实DOM包括了自身的属性描述，大小位置，浏览器事件等，东西太多了。源码中VNode定义了的属性差不多有20个左右。定义的路径为src/core/vdom/vnode。在Vue2.x的版本中，VNode有三中类型：注释节点，普通节点，文本节点。 _render()生成虚拟DOM的过程中，代码里也会做很多事情，比如：数据的规范性检测、特殊属性key的规范性检测、子节点children的规范化、遇到用户自定义组件对其进行组件初始化。 有了虚拟DOM后，最后就是执行_update方法将其渲染成真实DOM，其中核心内容就是通过调用操作真实DOM的方法来生成真实DOM，比如调用createElm方法创建节点，插入子节点，经过递归创建后成为一个完整的DOM树并插入body中，并且在发生了数据变化影响真实DOM的阶段，会有diff算法来判断前后VNode的差异，以求最小化变化改变真实DOM。 当响应式数据发生了频繁的修改，会引起整个DOM树的频繁的重绘和重排，这是及其消耗性能的，如何优化这一渲染过程，Vue源码中给出俩个思路。 将多次修改推到一个队列中，在下一个tick去执行视图更新。 使用diff算法，将需要修改的数据进行比较，并只渲染必要的DOM。 而diff算法本质上就是进行新旧节点的对比，如果新旧节点的根节点不是同一个节点，则直接替换节点。(只进行同层节点的比较，节点不一致，直接用新节点及其子节点替换旧节点)，如果是同一节点会进行如下的比较 节点相同，且节点除了拥有文本节点外没有其他子节点，直接替换文本内容。 新节点没有子节点，旧节点有子节点，则删除旧节点所有子节点。 旧节点没有子节点，新节点有子节点，则用新的所有子节点去更新旧节点。 新旧都存在子节点，则对比子节点内容做操作(最复杂的一步)。 在_update执行的过程中，如果碰到了自定义组件时，会去调用子组件init方法，开始进行该组件的合并配置，初始化生命周期，初始化事件中心，初始化渲染的过程。实例挂载又会执行$mount过程。 3. 响应式系统的构建Vue作为数据驱动为特点的一个框架，响应式系统是其非常核心的一个概念。 首先我们要先了解，Vue源码中和响应式系统的构建相关的类为以下三种： Observer类，实例化一个Observer类会通过Object.defineProperty对数据的getter,setter方法进行改写，在getter阶段进行依赖的收集,在数据发生更新阶段，触发setter方法进行依赖的更新。 Watcher类，实例化Watcher类相当于创建一个依赖，简单的理解是数据在哪里被使用就需要产生了一个依赖。当数据发生改变时，会通知到每个依赖进行更新。 Dep类，既然Watcher理解为每个数据需要监听的依赖，那么对这些依赖的收集和通知则需要另一个类来管理，这个类便是Dep,Dep需要做的只有两件事，收集依赖和派发更新依赖。 在这张图里我们可以看到这三个类的关系 在最前面的初始化的时候，执行_init函数的时候，响应式系统的构建也已经同步开始了。经过初始化后的数据，我们在控制台打印this._data或者引用类型的数据时，我们会发现在其原型里会有一个不可枚举的__ob__字段，标示这是经过Observer类实例化后。 3.1 数据初始化 data初始化：对data进行Observer类实例化，添加响应式对象标志__ob__, 执行walk函数(其核心内容为defineReactive函数)，该函数主要作用是对每个属性实例化一个Dep类，即为每个数据都创建一个依赖的管理，如果遇到深层次对象(属性为一个对象)，则会递归调用实例化Observer类，让其也转换为响应式对象。defineReactive函数就是利用Object.defineProperty重写getter，setter方法。数据被访问时，通过dep.depend收集被访问时的依赖Watcher。数据被修改时，通过dep.notify通知收集到的Watcher进行相应的更新。 computed初始化：computed初始化和data类似，但是computed是直接通过Object.defineProperty设置set与get的，还有几点不同之处。1、如果我们写的computed是function类型的时候，set函数是为空函数的。2、与computed涉及的data会收集当前computed的watcher，方便后面data更改时，来通知computed的更新。3、computedWatcher的标志为{lazy: true}，并且不会立刻执行依赖的更新操作，通过一个dirty设置为true进行标记，访问computed的时候如果dirty为true会重新计算值。4、computed不会收集渲染watcher，computed更新的时候视图会更新是为其涉及的data收集了渲染watcher。 props初始化：遍历定义的props配置。遍历的过程主要做两件事情：一是调用Observer类里的defineReactive方法把每个prop对应的值变成响应式，二是使用Proxy为props做了一层代理，用户通过vm.XXX可以代理访问到vm._props上的值。 watch初始化：当传入的选项里有watch选项时，会执行watch的初始化内容，其核心为createWatcher，无论传入watch是什么形式最终都会调用实例的$watch方法，$watch的核心是创建一个user watcher，其中{user: true}是当前用户定义watcher的标志。 3.2 依赖收集既然数据的初始化完成以后，就是等待数据被访问，收集当前的依赖了，我们可以先看下Watcher的定义，和上面几种类型Watcher实例化时传了哪些参数。 Watcher基本定义 1234567891011export default class Watcher &#123; ... constructor ( vm: Component, // vue实例 expOrFn: string | Function, // 用于收集依赖的方法 cb: Function, // 回调函数 options?: ?Object, // 自定义参数，比如自定义watch传入的depp，immediate isRenderWatcher?: boolean // 是否为渲染Watcher ) ....&#125; 渲染Watcher实例化123456789101112new Watcher( vm, updateComponent, // 渲染模版更新DOM的方法 noop, // 没有回调，空函数 &#123; before () &#123; // 数据更新之前执行beforeUpdate生命周期 if (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123; callHook(vm, 'beforeUpdate') &#125; &#125;&#125;, true /* isRenderWatcher */) 计算属性Watcher实例化123456watchers[key] = new Watcher( vm, getter || noop, // getter是我们写的computed函数或者是自定义的get函数 noop, // 空函数 computedWatcherOptions // &#123; lazy: true &#125; 标示自己是计算属性Watcher) 用户自定义Watcher实例化123456const watcher = new Watcher( vm, expOrFn, // watch key值 cb, // 用户写的函数 options // depp，immediate之类的) 在Watcher类定义的地方，构造函数内有这么一段逻辑1234567891011121314if (typeof expOrFn === 'function') &#123; this.getter = expOrFn&#125; else &#123; this.getter = parsePath(expOrFn) // parsePath是一个工具函数，返回一个访问vm.expOrFn的执行函数 if (!this.getter) &#123; this.getter = noop &#125;&#125;this.value = this.lazy ? undefined : this.get();// get 函数内部value = this.getter.call(vm, vm) 意味着expOrFn参数是否为函数，都会在Watcher实例化的时候执行。所以可以解释各个依赖都是在哪些地方第一次被收集的。 渲染Watcher：updateComponent作为expOrFn参数传入的，也就是进行模版渲染的过程中有地方访问到了写在模版里的数据，更详细的讲是_render方法中，生成的render渲染函数fuction(){width(){}}的width语句中访问到了相应数据，该数据就会收集到渲染Watcher。 计算属性Watcher：执行我们写入的computed函数，访问到了相关数据，相关数据收集计算属性Watcher。 用户自定义Watcher：expOrFn传入的是我们写的watch key，在执行this.getter的时候会访问到vm.[key],所以是在被定义的时候就被对应的数据收集了。 3.3 更新视图无论是在哪收集到的watcher，数据更新的时候最终的目的还是要更新视图。 比如我们data里的数据被更新了，会触发set方法，其主要干了以下几件事： 判断数据更改前后是否一致，如果数据相等则不进行任何派发更新操作。 新值为对象时，会对该值的属性进行依赖收集过程 通知该数据收集的watcher依赖，遍历每个watcher进行数据更新(调用dep.notify方法进行更新的派发，该方法内通过调用watcher类的update方法进行更新数据操作) 更新时将每个watcher推到队列中，等待下一个tick(事件循环)到来时取出每个watcher进行run操作。 update函数执行的过程很复杂，其内部会执行Vue自定义的nextTick函数，nextTick会缓冲多个数据处理过程，等到下一个事件循环tick中再去执行DOM操作，原理是利用事件循环的微任务队列实现异步更新。当tick到来时，还会对各个依赖进行排序，因为依赖有优先级关系(自定义watcher优先于渲染watcher)，组件也有父子关系(父的渲染watcher优先于子的渲染watcher更新)。 对于渲染Watcher来说，run函数就是更新DOM的地方，也是执行我们执行实例化Watcher时传入的expOrFn参数。1234567891011121314151617181920212223run () &#123; if (this.active) &#123; const value = this.get() // 重新求值 if ( value !== this.value || isObject(value) || this.deep ) &#123; // set new value const oldValue = this.value this.value = value if (this.user) &#123; try &#123; this.cb.call(this.vm, value, oldValue) &#125; catch (e) &#123; handleError(e, this.vm, `callback for watcher "$&#123;this.expression&#125;"`) &#125; &#125; else &#123; this.cb.call(this.vm, value, oldValue) &#125; &#125; &#125;&#125; 根据依赖收集的地方我们得知，thi.get内会执行this.getter,而此时的getter就是updateComponent方法。 3.4 思考 为什么Vue官方文档中提到以下几种方式的赋值是构不成响应式数据的呢？又为什么通过数组的splice、push、shift等方法，或者通过this.$set的方法进行赋值就能构成响应式数据了呢？ 在Vue2.x的文档中有提到如果给直接修改数组的length属性，或者利用索引修改数组长度时，对象属性的添加或者删除，Vue不能检测到变动。这些都是与Object.defineProperty的特新有关。 首先Object.defineProperty的get，set方法只能检测到对象属性的变化，对数组的变化无能为力。之所以能通过数组方法进行更改，是因为Vue在保留原数组功能的前提下，重新定义了数组部分方法(主要是增删改查的方法，push,pop,shift,unshift,splice,sort,reverse)。在src/core/observer/array.js里放这数组改写的相关代码。 123456789101112131415161718192021222324252627282930313233343536373839const arrayProto = Array.prototype;export const arrayMethods = Object.create(arrayProto);const methodsToPatch = [ 'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse']/** * Intercept mutating methods and emit events */methodsToPatch.forEach(function (method) &#123; // cache original method const original = arrayProto[method] // def函数用于快捷设置属性为不可枚举 def(arrayMethods, method, function mutator (...args) &#123; const result = original.apply(this, args) const ob = this.__ob__ let inserted switch (method) &#123; case 'push': case 'unshift': inserted = args break case 'splice': inserted = args.slice(2) break &#125; if (inserted) ob.observeArray(inserted) // notify change ob.dep.notify() return result &#125;)&#125;) 首先先会调用原始的数组方法进行运算，保证与原始数组类型的方法一致。之后取出ob(Observer实例)，调用ob.dep.notiify()进行依赖的派发更新。通过inserted来标志数组是否增加了元素，如果增加的元素时候数组对象类型，则触发observeArray方法对每个元素进行依赖收集。 Vue在对对象进行依赖收集的时候，会为对象的每个属性都进行收集依赖，而直接通过object.key添加的新属性并没有依赖收集的过程，因此当之后数据key发生改变时也不会进行依赖的更新。$set的方法定义在src/core/observer/index.js里。 12345678910111213141516171819202122232425262728293031323334353637function set (target, key, val) &#123; //target必须为非空对象 if (isUndef(target) || isPrimitive(target) ) &#123; warn(("Cannot set reactive property on undefined, null, or primitive value: " + ((target)))); &#125; // 数组场景，调用重写的splice方法，对新添加属性收集依赖。 if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123; target.length = Math.max(target.length, key); target.splice(key, 1, val); return val &#125; // 新增对象的属性存在时，直接返回新属性，触发依赖收集 if (key in target &amp;&amp; !(key in Object.prototype)) &#123; target[key] = val; return val &#125; // 拿到目标源的Observer 实例 var ob = (target).__ob__; // _isVue为Vue实例的标志 if (target._isVue || (ob &amp;&amp; ob.vmCount)) &#123; warn( 'Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.' ); return val &#125; // 目标源对象本身不是一个响应式对象，则不需要处理 if (!ob) &#123; target[key] = val; return val &#125; // 手动调用defineReactive，为新属性设置getter,setter defineReactive(ob.value, key, val); ob.dep.notify(); return val &#125; 主要做了以下几点事。 目标对象必须为非空的对象，可以是数组，否者抛出异常 如果目标对象是数组时，调用数组的splice方法，进而调用ob.observeArray(inserted)对数组新增的元素收集依赖 新增的属性值在原对象已经存在，则手动的访问该属性值，此操作会触发依赖收集 新的属性值在原对象不存在时，手动定义新属性的getter，setter方法，并通过notify触发依赖更新。 如果你觉得以上知识点还不过瘾～附赠本人学习时画的思维导图，希望对你有帮助^_^ vue源码解析思维导图.xmind 参考资料: 深入剖析Vue源码 参考资料: Vue.js技术揭秘]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Http缓存总结]]></title>
    <url>%2F2020%2F03%2F10%2Fhttp-cache%2F</url>
    <content type="text"><![CDATA[了解Http的缓存机制。 http缓存.xmind]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JS中的正则表达式]]></title>
    <url>%2F2020%2F01%2F01%2FRegExp%2F</url>
    <content type="text"><![CDATA[学一门前端工具，几年就过时了。学正则表达式，受用一辈子。 正则表达式，英文简称:RegExp，全称:Regular Expression。关于正则表达式的由来和介绍就不多说了，大家只要记住正则是匹配模式，要么匹配字符，要么匹配位置。 我们系统的学习知识和打游戏是一样的，初期只能挑战一些小喽啰，涨涨经验值，等级和装备齐全后就可以逐一去挑战boss们。所以我们先来看下正则世界里都有哪些小怪物。 友情提示：学习正则表达式对新手来说并不是很友好，一些基础的知识需要通过死记硬背来学习，你得先记住它，才能灵活运用它。 小怪：学习正则的语法 弄一个正则出来：使用字面量, 构造函数和工厂符号都可以写出一个正则表达式。 123/pattern/flagsnew RegExp(pattern [, flags])RegExp(pattern [, flags]) 其中pattern为正则表达式的文本，flags为修饰符，可以为一个，也可以是多个为一组。一般来说需要动态构造正则的时候才会用到构造函数的方式。因为字面量写法的正则性能更好一些。当一个正则实例创建出来以后，它都会有以下的实例属性： lastIndex属性。它的作用是全局匹配时标记下一次匹配开始的位置，全局匹配的抓手就是它。 source属性。它的作用是存储正则模式的主体。比如/abc/gi中的abc。 对应的修饰符属性。目前有global、ignoreCase、multiline、sticky、dotAll、unicode属性，返回布尔值表明是否开启对应修饰符。 flags属性。返回所有的修饰符。比如/abc/gi中的gi。 ps:如果以构造函数方式构造正则的时候，pattern中定义了修饰符，但flags中又有值，则以flags定义的修饰符为准，这是ES2015的新特性。 普通字符：何为普通字符？就是包括各种人类语言，24个英文字母(包括大小写)，没有特殊含义的符号，甚至emoji表情也算普通字符。普通字符在正则中的含义就是检索它本身，你看: 12&apos;hello 😀 regex&apos;.match(/😀/);// [&quot;😀&quot;, index: 6, input: &quot;hello 😀 regex&quot;, groups: undefined] 元字符：在正则世界里大部分符号都是作为普通字符的存在，但总是有钉子户的存在，还有几个符号是有自己的特殊含义的，这种符号被称为元字符。 常用 字符相关 \:将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\n”匹配一个换行符。串行“\”匹配“\”而“(”则匹配“(”。简单来说，转义符能将一些普通字符提升成元字符，转义符能将任何符号砭为庶民(普通字符)，包括它自己(我狠起来自己都打)，当然普通字符转义后还是转义字符。 |:|就代表或者。字符组其实也是一个多选结构，但是它们俩有本质区别。字符组最终只能匹配一个字符，而分支匹配的是左边所有的字符或者右边所有的字符。经常在()中使用。 \d:匹配一个数字字符，等价于[0-9]，这里的数字不是JS中的Number类型，指字符串中的数字。 \D:匹配一个非数字字符，等价于[^0-9]。 \s:匹配一个空白字符，空白字符不单单包括空格，它是一个总集空格\f\n\r\t\v，包括空格，换页符，换行符，回车符，水平制表符，垂直制表符。但是这个总集里大部分符号都是不可打印的符号，只有\n和我们经常接触了，如果你不需要区分空格与换行，可以大胆使用\s，如果你想只匹配一个空格，在正则的写法就是空一格。 \S:匹配任何非空白字符。等价于[^ \f\n\r\t\v]。 \w:匹配一个26个英文字母或者一个数字或者一个下划线，等价于[A-Za-z0-9_].注意这里会多一个下划线，因为在Javascript中的变量规则中，使用这三种命名是比较合理的。 \W:匹配任何非单词字符。等价于[^A-Za-z0-9_]。 .:所谓字越少，事情越大。这个小点号在正则世界里的能量非常大。它能匹配任意字符(但是行结束符除外：\n \r \u2028 或 \u2029),但是在字符组中它就是个点，无论你怎么转义都没有用。 位置相关 ^:通常匹配输入字符串的开始位置,说通常，因为它在字符组中[^abc]另有含义。 $:与上面的相反，匹配输入字符串的结束位置。需要注意的几点地方： 作为匹配文本开始元字符的时候必须是正则主体的第一个符号或者最后一个符号，否则正则无效。 它匹配的是一个位置，而不是具体的文本 多行匹配模式时(修饰符中带m)，二者分别是行开头和行结尾的概念 ^符号在正则的字符组中有其他含义，$在字符串方法replace中有其他含义。 \b:匹配一个单词边界(boundary)，匹配的是一个位置，而不是一个字符。单词和空格之间的位置，就是所谓单词边界，并且对汉字及其他语言是无效的。具体来讲就是匹配\w和\W之间的位置，也包括\w和^之间的位置，也包括\w和$之间的位置。 123'hello regex'.match(/\bregex$/); // ['regex']'hello regex'.match(/\b/g); // ["", "", "", ""] 有4个单词边界，分别为hello前后位置，regex前后位置'窝窝头 一块钱 4个'.match(/\b窝窝头\b/); // null \B:匹配一个非单词边界，匹配的一个不是单词边界的位置。具体说来就是匹配\w与\w、\W与\W、^与\W，\W与$之间的位置。 123'1234'.match(/1\B2/); // ['12']'1234'.match(/\B/g); // ["", "", ""] 有3个非单词边界，分别为12，23，34中间的位置'#'.match(/\B/g); // ["", ""] 不常用 \cx:匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。 \f:匹配一个换页符。等价于\x0c和\cL。 \n:匹配一个换行符。等价于\x0a和\cJ。 \r:匹配一个回车符。等价于\x0d和\cM。 \t:匹配一个制表符。等价于\x09和\cI。 \v:匹配一个垂直制表符。等价于\x0b和\cK。 量词：在正则的世界里，一个字符或者元字符也只能匹配对应的一个字符，但是如果需要匹配重复的字符，正则世界里量词就能帮助我们，量词加上元字符的使用，就像是加特林机枪加上了蓝光特效，强大并且炫酷。 ?：重复零次或者一次。很好记忆，就像我们理解的问号一样，不确定有没有。 +：重复一次或者多次，也就是至少一次。懂的自然懂，为东方长者+1s。 *：重复零次或者多次，也就是任意次数。可以把这个想象成天上的星星，有时候你看不到星星 ，有时候你可以看到数不完的星星。 {n}：重复n次，在正则中{}符号中间要是有个数字或者是数字加,是有特殊含义的，但是如果中间是其他东西是不需要转义的。 {n,}：重复n次或者更多次，{1,}相当于+，{0,}相当于*。 {n,m}：重复n次到m次之间的次数，包含n次和m次，{0,1}相当于?。 量词虽好，但还是需要注意以下几点： {n,m}中间不能有空格，空格在正则中是有含义的，{,m}是没有意义的，甚至不用对他进行转义，它就是普通的字符串。 量词后面跟着量词会报错(有特殊情况，下面说的非贪婪模式)。 /.*/功能强大，常用于匹配对我们没有价值的字符，能匹配若干除换行符之外的字符，但是性能不太好。 正则中不是所有地方的?都是做量词用的，?还有其他含义，在下面的内容我会都列出来。 贪婪模式与非贪婪模式：上面说到了量词后面不能跟量词，但是会有一种特殊情况，那就是通过?切换贪婪模式与非贪婪模式 正则世界的默认模式是贪婪模式，什么意思呢？比如&#39;Gooooogle&#39;.match(/o+/g)这个正则里，无论你有多少个o我都给你匹配出来。 当?紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式切换成非贪婪模式。非贪婪模式会尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。 12'gridsum good'.match(/g\w&#123;1,3&#125;/g) // ["grid", "good"] 既然你能给我3个，我就要3个'gridsum good'.match(/g\w&#123;1,3&#125;?/g) // ["gr", "go"] 我只要一个就好啦，不贪 正确的使用非贪婪模式可以无形的优化你的正则表达式，因为正则引擎在解析你写的正则的时候能更明确你所要的东西。 小练习：&#39;123 1234 12345 123456&#39;.match(/\d{2,5}/g)的匹配结果，&#39;123 1234 12345 123456&#39;.match(/\d{2,5}?/g)的匹配结果 字符组：在正则的世界里，一个字符只能匹配到它自己，但是如果你只知道这个字符是’abc’中的一种，这时候字符组就能帮助到我们。注意：字符组虽然里面带组，但是它是匹配一个字符的。 []:方括号在正则中表示一个区间,我们称它为字符组,字符组中的字符集合只是所有的可选项，最终它只能匹配一个字符,除了-和^在字符组中有特殊含义，其他字符一律作为普通字符处理。但是呢 ，带\的元字符还是可以正常使用的。 ^如果在字符组的最前面中表示取反，不再是文本开始的位置了。如果在字符组的其他位置就是个普通字符。 -本来是一个普通字符，在字符组中摇身一变成为连字符。但是注意，只能连接大小写英文字母和数字，比如数字-数字，数字-字母，字母-字母。如果-前后有一个地方是数字或者字母，但是另一边是其他符号，正则会报错哦，其中小写字母-大写字母这种方式也会报错，为什么会报错呢，我们想一下ASCII码，大写字母是在小写字母前面的。但是数字-小写字母或者数字-大写字母或者大写字母-小写字母这些方式不能乱用哦，因为这里面包含的不只是数字与字母了，还会有其他符号。所以可以看出字符组里的连接符是根据ASCII码来的。 1234var str = '123abcABC~!@#$%^&amp;*()_+=-&#123;&#125;[]\|:;,.?/&lt;&gt;`';str.match(/[A-z]/g) // ["a", "b", "c", "A", "B", "C", "^", "_", "[", "]", "`"]str.match(/[0-z]/g) // ["1", "2", "3", "a", "b", "c", "A", "B", "C", "@", "^", "_", "=", "[", "]", ":", ";", "?", "&lt;", "&gt;", "`"]str.match(/[0-Z]/g) // ["1", "2", "3", "A", "B", "C", "@", "=", ":", ";", "?", "&lt;", "&gt;"] 如果你只需要-和^作为普通字符，前面加\转义即可。 123'grey or gray'.match(/gr[ae]y/g); // ['grey','gray']'$'.match(/[$&amp;@]/); // ['$']'xyz-3'.match(/[0-c]/); // ['3'] 小练习：匹配24小时时间制：/^([01][0-9]|[2][0-3]):[0-5][0-9]$/ 捕获组与非捕获组：前面我们知道了普通字符加量词的组合，能够匹配出单个字符重复很多次的字符串，那么我要匹配一个重复的字符串呢？此时捕获组来了，它跨着大马步向我们走来。 在正则中()俩个圆括号代表着将它其中的字符集合打包成一个整体，然后量词就可以操作这个整体了。并且()的匹配结果默认是可以捕获的。如果你不想将括号内的字符捕获出来，只要在圆括号内最前面加上?:标识，像这样(?:)。 12'窝窝头 一块钱 一块钱 一块钱 4个'.match(/窝窝头 (一块钱 )+4个/); // ['窝窝头 一块钱 一块钱 一块钱 4个', '一块钱'] 默认情况下，括号内的内容也会匹配出来'窝窝头 一块钱 一块钱 一块钱 4个'.match(/窝窝头 (?:一块钱 )+4个/); // ['窝窝头 一块钱 一块钱 一块钱 4个'] ‘一块钱’没有了 捕获分为正则内捕获和正则外捕获 正则内捕获，正则内捕获使用\数字的形式，分别对应前面的圆括号捕获的内容。这种捕获的引用也叫反向引用。比如我们把html所有非自闭合标签都匹配出来，非自闭合标签的特性就是前后有对应的标签名，像&lt;div&gt;&lt;/div&gt;。如果在括号内使用了?:标示，\数字的反向引用方式就会失效。 12'&lt;App&gt;hello regex&lt;/App&gt;'.match(/&lt;([a-zA-Z]+)&gt;.*&lt;\/\1&gt;/); // ['&lt;App&gt;hello regex&lt;/App&gt;'] 这里的\1就是前面()捕获到的内容'&lt;App&gt;hello regex&lt;/App&gt;'.match(/&lt;(?:[a-zA-Z]+)&gt;.*&lt;\/\1&gt;/); // null 同时，括号内是可以继续加括号的，那么\数字是如何一一对应前面的括号的，记住一点深度优先的原则，同级捕获按前后顺序，同一个捕获内最外面一层优先(就像剥洋葱),比如下面的栗子： 12345'&lt;App&gt;hello regex&lt;/App&gt;&lt;p&gt;A&lt;/p&gt;&lt;p&gt;hello regex&lt;/p&gt;'.match(/&lt;((A|a)pp)&gt;(hello regex)+&lt;\/\1&gt;&lt;p&gt;\2&lt;\/p&gt;&lt;p&gt;\3&lt;\/p&gt;/);// ["&lt;App&gt;hello regex&lt;/App&gt;&lt;p&gt;A&lt;/p&gt;&lt;p&gt;hello regex&lt;/p&gt;", "App", "A", "hello regex"]// \1对应的是((A|a)pp)这个捕获，// \2对应的是(A|a)这个捕获，// \3对应的是(hello regex)这个捕获 (ps:小思考——既然反向应用是按照数字顺序来的，那么\10表示的是第十个括号，还是\1和0的意思呢？) 这个确实有点绕，如果你还没整明白，你可以尝试使用ES2018的新特性——捕获命名。在捕获组内部最前面加上?&lt;key&gt;，它就被命名了。使用\k&lt;key&gt;语法就可以引用已经命名的捕获组。捕获命名只在正则内捕获生效哦，对上面的代码该改造如下。 12345'&lt;App&gt;hello regex&lt;/App&gt;&lt;p&gt;A&lt;/p&gt;&lt;p&gt;hello regex&lt;/p&gt;'.match(/&lt;(?&lt;bar&gt;(?&lt;foo&gt;A|a)pp)&gt;(?&lt;tob&gt;hello regex)+&lt;\/\k&lt;bar&gt;&gt;&lt;p&gt;\k&lt;foo&gt;&lt;\/p&gt;&lt;p&gt;\k&lt;tob&gt;&lt;\/p&gt;/);// ["&lt;App&gt;hello regex&lt;/App&gt;&lt;p&gt;A&lt;/p&gt;&lt;p&gt;hello regex&lt;/p&gt;", "App", "A", "hello regex"]// \k&lt;bar&gt;对应的是((A|a)pp)这个捕获，// \k&lt;foo&gt;对应的是(A|a)这个捕获，// \k&lt;tob&gt;对应的是(hello regex)这个捕获 正则外捕获，我们先看下面这个栗子。 1234'@abc'.match(/@(abc)/);// ["@abc", "abc", index: 0, input: "@abc", groups: undefined]RegExp.$1;// "abc" 没错，RegExp就是构造正则的构造函数。如果有捕获组，它的实例属性$数字会显示对应的引用。如果有多个正则，RegExp构造函数的引用只显示最后一个正则的捕获。 其实正则外的捕获更加常用的是字符串的方法replace，replace是我们日常开发中比较常用的。在下面的环节中会详细介绍它。 12'hello **regex**'.replace(/\*&#123;2&#125;(.*)\*&#123;2&#125;/, '&lt;strong&gt;$1&lt;/strong&gt;');// "hello &lt;strong&gt;regex&lt;/strong&gt;" 修饰符：和vue指令后面跟着的修饰符一样，正则表达式有修饰符，它像小尾巴一样跟在正则主体后面。 g修饰符(常用):g是global的缩写。默认情况下，正则从左向右匹配，只要匹配到了结果就会收工。g修饰符会开启全局匹配模式，找到所有匹配的结果。 i修饰符(常用):i是ignoreCase的缩写。在正则世界里，大小写字母是有区别的,/z/小写的是无法匹配到大写的Z,i修饰符可以全局忽略大小写。 m修饰符(常用):m是multiline的缩写。这个修饰符有特定起作用的场景：它要和^和$搭配起来使用。默认情况下，^和$匹配的是文本的开始和结束，加上m修饰符，它们的含义就变成了行的开始和结束。在匹配换行文本的时候很有用 12345678910`abcxyz`.match(/^xyz$/);// 匹配结果为null。如果不加m，这里^和$还是代表文本的开始与结束，这里文本的开始和结束相邻的字符都是换行符，所以匹配不到东西`abcxyz`.match(/^xyz$/m); // 匹配结果为['xyz']。加了m，这里^和$还是代表行的开始与结束，其中xyz就为一行。 y修饰符(ES2015新特性，不常用):y是sticky的缩写。y修饰符有和g修饰符重合的功能，它们都是全局匹配。所以重点在sticky上，怎么理解这个粘连呢？g修饰符不挑食，匹配完一个接着匹配下一个，对于文本的位置没有要求。但是y修饰符要求必须从文本的开始实施匹配，因为它会开启全局匹配，匹配到的文本的下一个字符就是下一次文本的开始。这就是所谓的粘连。 s修饰符(ES2018新特性，不常用):s是singleline的缩写。s修饰符要和.搭配使用，默认情况下，.匹配除了换行符之外的任意单个字符，然而它还没有强大到无所不能的地步，所以正则索性给它开个挂。s修饰符的作用就是让.可以匹配任意单个字符。 u修饰符(ES2015新特性，不常用):u是unicode的缩写。有一些Unicode字符超过一个字节，正则就无法正确的识别它们。u修饰符就是用来处理这些不常见的情况的。 正则世界的武器：JS中与正则相关的方法经过前面一番小怪的历练，我们经验值逐渐涨了起来，但是光有等级，没有好使的武器可不行啊，所以我们接下来去正则世界里的”武器库”，看看有哪些好使的武器。 但是在进入武器库前，我们先解决一下看守武器库的小怪物。 看门小怪物——零宽断言在前面的元字符环节，我们了解到，正则里有一些元字符只匹配位置，不匹配字符。比如^,$,\b,\B等。当然正则还有一些比较高级的匹配位置的语法，它匹配的是：在这个位置之前或之后应该有什么内容。 所谓零宽指的就是它匹配一个位置，位置是没有宽度的(这句话很关键的，所以位置匹配可以无限重复的，所以上面说的位置相关元字符也是可以和断言搭配使用的)。所谓断言指的是一种判断，断言之前或之后应该有什么或应该没有什么。 零宽肯定先行断言:所谓的肯定就是判断有什么，而不是判断没有什么。而先行指的是向前看(lookahead)，断言的这个位置是为前面的正则规则服务的(人话：整个圆括号匹配的是个位置，那么匹配到这个位置的规则写在圆括号内，圆括号里的内容为括号前面的正则息息相关)。语法很简单：圆括号内最左边加上?=标识。看下面这个栗子： 1`CoffeeScript JavaScript Typescript`.match(/\b\w&#123;4&#125;(?=Script\b)/); // ["Java"] 这句正则什么意思呢？匹配4个字母，这4个字母最前面是一个单词边界，并且后面有一个符合一个规则的位置，这个规则为一个结尾为单词边界位置的Script字符串。在CoffeeScript JavaScript Typescript里，满足这个规则的只有前面俩个CoffeeScript JavaScript，其中CoffeeScript的Script前面为\b\w{6}，所以不符合正则要求，只有JavaScript符合，并且牢记断言是没有宽度的这个特性，所以只匹配出里Java出来。 为了说明没有宽度这个特性，我们接着看这个栗子： 1'CoffeeScript JavaScript javascript'.match(/\b\w&#123;4&#125;(?=Script\b)\w+/); // ['JavaScript'] 我们在(?=Script\b)后面新添里正则\w+，根据前面的解释，\b\w{4}(?=Script\b)依旧匹配的是Java，然后\w+匹配到里Script，所以匹配结果为JavaScript。 零宽否定先行断言:肯定是判断有什么，那么否定就是判断没有什么，语法是圆括号内最左边加上?!标识。 1'TypeScript Perl JavaScript'.match(/\b\w&#123;4&#125;(?!Script\b)/); // ['Perl'] 零宽肯定后行断言:前面说的先行是向前看，那么后行就是向后看(lookbehind)，断言的这个位置是为后面的规则服务的。语法很简单：圆括号内最左边加上?&lt;=标识。有一点要注意，后行断言是ES2018的新特性，目前桌面浏览器只有Chrome62和Opera49以上的版本才支持，其他浏览器都不支持，会报错 12'演员高圆圆 将军霍去病 演员霍思燕'.match(/(?&lt;=演员)霍\S+/);// 匹配结果为['霍思燕']。我们先看`霍\S+`这个正则的意思，霍开头并且后面有一个或者无数个为非空字符的字符组，满足这个正则条件的是`霍去病`和`霍思燕`，而后行断言是为后面的规则服务的，`(?&lt;=演员)`的意思就是谁前面的字符串为演员，很明显`霍思燕`是满足这个条件的。 零宽否定先行断言:同理，肯定是判断有什么，那么否定就是判断没有什么，语法是圆括号内最左边加上?&lt;!标识。 12'演员高圆圆 将军霍去病 演员霍思燕'.match(/(?&lt;!演员)霍\S+/);// 匹配结果为['霍去病'] 讲到这里，我们已经手撕了零宽断言，推开了武器库的大门，让我们看看都有哪些趁手的武器吧。 因为正则表达式是用来处理字符串的，所以大部分的方法与String类型有关。在上面的栗子中，使用的match，就是其中一种，下面我把所有和正则有关的的方法集结如下(有些MDN上标明已废弃的就不列出)，我们简单的过一下。 String相关: match: 检索返回一个字符串匹配正则表达式的的结果。 语法: str.match(regexp) 它接受一个正则表达式作为唯一参数，但是你传一个字符串进去，会隐式的将其转换为一个正则实例。 match的返回值可以分为三种情况 匹配失败的时候返回null。 非全局匹配：返回一个数组，数组的第一项为匹配结果，如果你没有传任何参数给match,匹配结果为空字符串，如果正则里有捕获组并且没有设置?:，那么从第二项开始依次排列捕获的结果。并且数组里有三个属性:index,input,groups。 12345'i love gridsum'.match(/\blo(v)(?&lt;key&gt;e)/)// ["love", "v", "e", index: 2, input: "i love gridsum", groups: &#123;key: "e"&#125;]// index属性，标明匹配结果在文本中的起始位置。// input属性，显示源文本。// groups属性，它存储的不是捕获组的信息，而是捕获命名的信息。 全局匹配：返回一个数组，匹配的结果会依次在数组列出，但是其他信息都不会列出来。 matchAll: 方法返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器。迭代器相关的知识可以参考阮一峰ECMAScript入门; 语法：str.matchAll(regexp) 12345const bar = '@gridsum1-good-$gridsum3'.matchAll(/([^-]+)gridsum(\d+)/g);bar.next(); // &#123;value:['@gridsum1', '@', '1'], done: false&#125;bar.next(); // &#123;value:['@gridsum3', '$', '3'], done: false&#125;bar.next(); // &#123;value:undefined, done: true&#125; 结束// value里的这个数组里，第一个数代表的是匹配的结果，后面依次为捕获组的内容 如果没有 g 标志则matchAll 只会返回首个匹配。当迭代器消耗尽了，无法再次复用，需要重新获取一个新的迭代器。 也可以通过扩展运算符或者Array.form()或者for...of来进行循环。 12345678var bar = '@gridsum1-good-$gridsum3'.matchAll(/([^-]+)gridsum(\d+)/g);var [bar1,bar2,bar3] = Array(3).fill(bar, 0 , 3);var arr1 = [...bar];// [["@gridsum1", "@", "1", index: 0, input: "@gridsum1-good-$gridsum3", groups: undefined],["$gridsum3", "$", "3", index: 15, input: "@gridsum1-good-$gridsum3", groups: undefined]];var arr2 = Array.from(bar2);for (i of bar3) &#123; i.next();&#125; replace: 根据给定的字符串或者正则替换匹配结果，并返回新的替换后的文本。源文本不会改变。它有俩个参数，第一个参数为 字符串或者正则表达式，作用为匹配（字符串只能替换一次，不如正则的表达能力强）。第二个参数为字符串或者一个函数，作用为替换。 语法: str.replace(regexp|substr, newSubStr|function) 我们在正则小怪中的捕获中埋了一个坑，说正则外捕获大部分与replace有关，现在我们就讲讲为啥与replace有关。 在替换字符串中，replace提供了一些特殊的变量名。 变量名 代表的值 示例 示例结果 $$ 插入一个 $。 &#39;-abcd-&#39;.replace(/-/g, &#39;$$&#39;) ‘$abcd$’ $&amp; 插入匹配的子串。 &#39;-abcd-&#39;.replace(/-abcd-/g, &#39;{$&amp;}&#39;) ‘{-abcd-}’ $` 插入当前匹配的子串左边的内容。 &#39;-abcd-&#39;.replace(/-/g, &#39;{$}’)` ‘{abcd-}abcd{}’ $&#39; 插入当前匹配的子串右边的内容。 &#39;-abcd-&#39;.replace(/-/g, &quot;{$&#39;}&quot;) ‘{abcd-}abcd{}’ $n 假如负责匹配的参数是一个正则，$n代表的是第n个括号匹配到的字符串(同样为内部没有?:的括号)，n是从1开始并且小于100的非负整数。 &#39;-abcd-&#39;.replace(/(-)(a)bcd-/g, &#39;$1$2&#39;) ‘-a’ 其中用的最多的还是$n这种方式。所以正则外捕获是与replace息息相关的。 当replace的第二个参数为一个函数时，当匹配执行时，该函数就会执行，函数的返回值作为替换字符串，如果你没设置返回值，默认返回undefined字符串，如果第一个参数是正则表达式，并且其为全局匹配模式，那么这个方法将被多次调用，每次匹配都会被调用。 该函数共有4个参数。 函数的第一个参数，是匹配结果。对应于上述的$&amp;。 1234'hello gridsum'.replace(/gridsum/g, (match) =&gt; `&#123;$&#123;match&#125;&#125;`);// "hello &#123;gridsum&#125;"'hello gridsum'.replace(/gridsum/g, (match) =&gt; &#123;&#125;);// "hello undefined" 如果replace方法第一个参数是正则表达式，函数的第二个参数开始与正则中的捕获组一一对应，对应与上诉的$n。 12'@gridsum1-good-$gridsum3'.replace(/([^-]+)gridsum(\d+)/g, (match, $1, $2) =&gt; `&#123;$&#123;$1&#125;$&#123;match&#125;$&#123;$2&#125;&#125;`);// "&#123;@@gridsum11&#125;-good-&#123;$$gridsum33&#125;"" 函数的倒数第二个参数是匹配结果在文本中的位置。 12'@gridsum-good-$gridsum'.replace(/([^-]+)gridsum/g, (match, $1, index) =&gt; `&#123;$&#123;match&#125;是位置是$&#123;index&#125;&#125;`);// "&#123;@gridsum是位置是0&#125;-good-&#123;$gridsum是位置是14&#125;" 函数的最后一个参数是被匹配的原字符串。 replace的用途很广泛，它能很好的达到我们想要替换字符串的操作。几个栗子。 转义HTML标签：&#39;&lt;p&gt;hello regex&lt;/p&gt;&#39;.replace(/&lt;/g, &#39;&amp;lt;&#39;).replace(/&gt;/g, &#39;&amp;gt;&#39;); 将华氏温度转换为对等的摄氏温度: &#39;70°F&#39;.replace(/(\d+)°F\b/g, (match, p1)=&gt; (p1-32)*5/9+&quot;°C&quot;); 获取指定标签内的值：&#39;&lt;span&gt;hello&lt;/span&gt;&#39;.replace(/&lt;span[^&gt;]*&gt;(.*?)&lt;\/span&gt;/g, &#39;$1&#39;); 模拟实现trim方法：str.replace(/^\s*(.*?)\s*$/g, &quot;$1&quot;); 单词大驼峰化：str.replace(/(^|[-_\s])+(.)?/g, (match, p1,p2)=&gt;p2?p2.toUpperCase():&#39;&#39;) search: 找出首次匹配项的索引。它的功能较单一，性能也更好。它接受一个正则表达式作为唯一参数。与match一样，如果传入一个非正则表达式，它会调用new RegExp()将其转换成一个正则实例。 语法: str.search(regexp) 12'gridsum-good-gridsum'.search(/good/);// 8 因为只能返回首次匹配的位置，所以全局匹配对它无效。如果匹配失败，返回-1。 split: 它的作用是根据传入的分隔符切割源文本。它返回一个由被切割单元组成的数组。它接受两个参数。第一个参数可以是字符串或者正则表达式，它是分隔符；第二个参数可选，限制返回数组的最大长度。 语法：str.split([separator[, limit]]) 12'abc-def_mno+xyz'.split(/[-_+]/g);// ["abc", "def", "mno", "xyz"] 因为split方法中的正则是用来匹配分隔符，所以全局匹配没有意义。 RegExp相关： exec:它的作用是根据参数返回匹配结果，与字符串方法match相似。 语法：regexObj.exec(str) 12/xyz/.exec('abc-xyz-abc');// ["xyz", index: 4, input: "abc-xyz-abc", groups: undefined] exec与match小小的区别在于参数为空的情况：exec直接返回null；match返回一个空字符串数组。 更大的区别在于全局匹配的时候，exec由于每次都只能匹配一个结果出来，所以全局匹配每次成功后，都需要更新正则实例的lastIndex属性，用于记录上次匹配成功后的下标，当最终匹配结果为null的时候，lastIndex会重归于0，所以这个匹配过程是可以无限重复的。lastIndex属性是属于正则实例的。所以使用exec一般配合正则实例使用。 如果直接使用字面量的正则搭配exec使用，就会一直在原地打转，因为每次都是一个新的正则实例，每次lastIndex都要从0开始。 exec还有与replace搭配使用的方法，看下面这个栗子： 12345var regex = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;var string = "2017-06-12";var result = string.replace(regex, function() &#123; return RegExp.$2 + "/" + RegExp.$3 + "/" + RegExp.$1;&#125;); 注意：RegExp是会被新的正则表达覆盖的。 test:方法执行一个检索，用来查看正则表达式与指定的字符串是否匹配。返回 true 或 false。与字符串方法search相似。多用于表单验证中。 语法：regexObj.test(str) test方法与search方法的区别主要体现在两点： search方法返回的是索引，test方法只返回布尔值。 因为是正则实例方法，全局匹配时也会更新正则实例的lastIndex属性，所以也可以多次执行。 boss：能看懂复杂的正则&amp;理解正则的运行模式 从武器库里认识了众多武器后，我们开始来挑战一些小boss。 匹配身份证 1/^(\d&#123;18&#125;|\d&#123;17&#125;[\dxX])$/.test(str) 这个正则比较简单，首先想到身份证一定是18位的，但是最后一位可能是x或者X，其他的都是数字，那么正则只要写个分支出来就好了。 匹配16进制颜色值 1/^#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)$/.test(str) 首先16进制的颜色都是#号开头，后面是3位数或者是6位数的，并且每个数都只能是‘0-9’或者‘a-f’或者‘A-F’，所以我们就可以写出个分支出来了。 金钱字符串千位符分割 12'1234567'.replace(/\B(?=(\d&#123;3&#125;)+(?!\d))/g,',');// 1,234,567 这个正则难点在于断言里套了一个断言，本来正则里的断言就不好理解，还是俄罗斯套娃版的断言，更加有难度。但是仔细把这个正则进行拆分，分步骤解读我们还是可以理解这个正则的。 首先我们先理解\B匹配出来的结果是[&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;]，这些玩意是1和2之间，2和3之间等等的位置，然后(?=(\d{3})+(?!\d))这个先行肯定断言语句能匹配出来一个跟在\B后面的位置，这个位置呢符合\B(\d{3})+(?!\d))这个规则，\d{3}+(?!\d)的意思呢是匹配某种长度至少为3的倍数的数字串，(?!\d)先行否定断言，就是说这个数字串后面的位置不能有数字啦。 分解以后我们就好理解该正则的含义了，比如，先找到1和2中间这个位置，这个位置后面跟着的数字串为’234567’，长度为6符合3的倍数，将该位置替换成’,’,接着检查2和3中间这个位置，这个位置后面的数字串为’34567’，长度为5，不符合3的倍数，跳过该位置，依次类推。所以这个正则正好符合金钱的计数法，从最右边开始算起，每隔3位数插入一个’,’。 当然处理金钱字符串肯定不止这一种方法，比如下面这个：&#39;1234567&#39;.replace(/(?!^)(?=(\d{3})+$)/g,&#39;,&#39;)，但是呢这种我觉得不好理解，当先行断言前面没有任何规则的时候，正则会对每一个位置发起匹配，每一个位置就是指\B与\b，我们看这个栗子： 1'1234'.match(/(?=\d)/g) // ["", "", "", ""] 因为最后一个位置后没有数字了，所以不会被匹配出来 所以我们就可以理解这个正则了，我们可以把俩个括号所服务的位置其实是同一位置，这个位置后面不是开头，并且后面跟着长度为3的倍数的字符串，这个字符串结尾一定是结尾，&#39;1234567&#39;.match(/(?!^)(?=(\d{3})+$)/g)匹配出来的东西是[&quot;&quot;,&quot;&quot;]，说明有俩个位置符合这个规则，哪俩个呢？1后面的位置和4后面的位置，1后面位置跟着直到末尾的字符串是’234567’，长度为6，符合规则，4后面位置跟着直到末尾的字符串是’567’，长度为3，符合规则。 所以解决同一个问题的时候，往往有多个版本的正则可以使用，并且对正则的理解可能也会有不同，所以具体使用哪种方法大家见仁见智了。 密码长度6-12位，由数字、小写字符和大写字母组成，但必须至少包括2种字符 12var reg = /^((?=.*[0-9])(?=.*[a-z])|(?=.*[0-9])(?=.*[A-Z])|(?=.*[a-z])(?=.*[A-Z]))[0-9A-Za-z]&#123;6,12&#125;$/;console.log( reg.test("abcdEF234") ); 这个正则完整的一看还挺长的，我们先分析需求，先看最简单的由数字、小写字符和大写字母组成,并且长度为6-12位，可以得出正则[0-9A-Za-z]{6,12}，至少包括2种字符，那么有3种组合：数字+小写字母，数字+大写字母，小写字母+大写字母，那么我们可以对开头这个位置处理，利用多个断言堆加一起，都是为前面的正则规则服务这个概念，我们可以写出3个分支(?=.*[0-9])(?=.*[a-z]),(?=.*[0-9])(?=.*[A-Z]),(?=.*[a-z])(?=.*[A-Z])。结合一下，就可以写出正则了。 输入框校验，避免特殊符号输入，允许-/${}符号输入，其他符号输入及空格输入视为非法，并且开头不允许数字或者符号，最长为32个字符。 12345var reg = /^(?!(\d|[\W]|_))[0-9a-zA-Z\-/$&#123;&#125;]&#123;1,32&#125;$/;console.log( reg.test("s-/$&#123;&#125;") ); // trueconsole.log( reg.test("-dsadsa") ); //falseconsole.log(reg.test("s32 13")); // falseconsole.log(reg.test("s1234567s1234567s1234567s1234567y")); // false 这是个与我们日常研发中比较相关的栗子，只允许-/${}符号输入，其他符号及空格输入视为非法，那么我们可以写出一个字符组[0-9a-zA-Z\-/${}]，开头不允许数字或者符号，我们知道\w相当于[0-9a-z-A-Z_]，但是里面有个_符号，所以要对它单独处理，所以配合先行否定断言可以写出正则^(?!(\d|[\W]|_))，最长为32个字符那么就是{1,32}，拼接一起后就可以得出正则了。 我们在尝试使用正则表达式去解决问题的时候，会无形中锻炼我们分析问题的能力与思维逻辑，正则与普通程序一样，也有流程的概念。比如上面的身份证匹配正则可视化流程图如下： 所以这里推荐几个的优秀的正则相关网站： 正则可视化流程图 拆分解析正则，切换不同语言环境下正则 简单的正则表达式手册 正则闯关 回溯 回溯这个概念呢，我们稍作了解(因为我懂的也不多- -)，正则在匹配的过程中，如果遇到了不正确的匹配，会回到上次匹配正确的步骤，重新开始发起匹配。看这个栗子 1'abbc'.match(/ab&#123;1,3&#125;c/) 一般发生回溯的地方有3个：贪婪量词，惰性量词，分支结构。 上面这个栗子就是贪婪量词的栗子，那为啥惰性量词也会发生回溯呢？因为有时候为了整体的正则成功，非贪婪模式下也不得不多匹配点东西。 1'12345'.match(/\d&#123;1,3&#125;?\d&#123;1,3&#125;/) 分支结构发生的回溯情况，可能前面的子模式会形成了局部匹配，如果接下来表达式整体不匹配时，仍会继续尝试剩下的分支。这种尝试也可以看成一种回溯。 1'candy'.match(/^(?:can|candy)$/) 正则如果存在过多的回溯就可能把cpu进程占满！之前网络安全实践分享中提到的 正则DOS攻击，就是黑客写的正则存在过多的正则回溯，把服务器的资源消耗过多，导致卡死，所以写出表达更正确的正则表达式是可以避免回溯的，比如.*这种写法就特别容易造成回溯，所以当你直到要匹配到哪个字符结束的时候，比如我知道要匹配到}结束，那你可以这么写[^}]*。 NFA引擎和DFA引擎 NFA与DFA是俩个合并的单词缩写，FA是有限自动机(Finite Automate)，我们可以有限自动机理解为一个机器人，在这个机器人眼里，所有的事物都是由有限节点组成的。机器人按照顺序读取有限节点，并表达成有限状态，最终机器人输出接受或者拒绝作为结束。 DFA是确定性有限自动机的缩写，NFA是非确定有限自动机的缩写，具体啥区别我没去研究过，总的来说，DFA可以称为文本主导的正则引擎，NFA可以称为表达式主导的正则引擎。我们平时写的正则都是用正则去匹配文本，这就是NFA的思路。 引擎的知识也是比较深层次的正则知识点了(我懂的也不是很多- -)，大家只需要知道大部分计算机语言的正则引擎是NFA的，JS环境下的正则引擎就是NFA的，意味着所有浏览器的正则引擎都是NFA。 讲到这呢，我们对正则已经有了一个比较全面的了解，希望本次分享能对大家有所帮助。如果大家对这些知识点消化后，工作中灵活运用正则是没问题的。但是正则是门非常”古老”的概念，它源于数学，比任何计算机语言出现都要早，想要把正则世界这个游戏打通关，我们需要走的路还很长～]]></content>
  </entry>
  <entry>
    <title><![CDATA[秀米集成到UEditor的配置过程]]></title>
    <url>%2F2019%2F10%2F22%2Fxiumi%2F</url>
    <content type="text"><![CDATA[秀米集成到UEditor的配置过程虽然秀米官方有提供文档说明如何将秀米插件集成至UEditor里(秀米官方文档)，但是该文档说明模糊不清，关键配置一句话带过，即使配置成功后还有坑留在里面。所以我重新整理了这个配置过程，回顾一下过程的同时也给以后需要用到的小伙伴提供便利。 一、将秀米图标集成至工具栏，并且成功弹出秀米弹框 首先我们需要一个秀米的html文件，这个html里主要就是弹框里的内容，里面有一个iframe指向秀米的网址。取名xiumi-ue-dialog-v5.html,放入ueditor1_4_3_3文件夹(UE的资源文件夹)下或者ueditor1_4_3_3下的dialogs文件夹里，这个只是涉及到后面引入它的路径，不是很重要，我是放在ueditor1_4_3_3文件夹下的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!-- ueditor1\_4\_3\_3/xiumi-ue-dialog-v5.html --&gt;&lt;!DOCTYPE html&gt;&lt;!-- saved from url=(0049)http://hgs.xiumi.us/uedit/xiumi-ue-dialog-v5.html --&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;XIUMI connect&lt;/title&gt; &lt;style&gt; html, body &#123; padding: 0; margin: 0; &#125; #xiumi &#123; position: absolute; width: 100%; height: 100%; border: none; box-sizing: border-box; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body style=""&gt;&lt;iframe id="xiumi" src="//xiumi.us/studio/v5#/paper"&gt;&lt;/iframe&gt;&lt;script type="text/javascript" src="./dialogs/internal.js"&gt;&lt;/script&gt;&lt;script&gt; var xiumi = document.getElementById('xiumi'); var xiumi_url = window.location.protocol + "//xiumi.us"; xiumi.onload = function () &#123; xiumi.contentWindow.postMessage('ready', xiumi_url); &#125;; document.addEventListener("mousewheel", function (event) &#123; event.preventDefault(); event.stopPropagation(); &#125;); window.addEventListener('message', function (event) &#123; if (event.origin == xiumi_url) &#123; editor.execCommand('insertHtml', event.data); // 这个方法用于触发UE的图片转存接口 editor.fireEvent('afterpaste'); dialog.close(); &#125; &#125;, false);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 秀米的文档里使用的是UE.registerUI(‘dialog’，fn）的方式动态在UE里添加一个秀米按钮并且在按钮里添加弹出弹框事件，但是这么做可能会影响到系统其他使用UE里的地方同样出现秀米图标，无法按需加载。所以我将此改进成在UE的前端配置中的toolbars数组里添加一个”xiumi”字符串即可展示出秀米的方式。步骤如下： 添加一个秀米的图标并添加样式。在ueditor1_4_3_3/themes/default/images文件夹里放入一个秀米图标; 在ueditor1_4_3_3/themes/default/css/ueditor.css 添加俩句样式 1234567891011/* xiumi-dialog */.edui-default .edui-for-xiumi .edui-dialog-content &#123; width: calc(100vw - 60px) !important; height: 90vh !important; overflow: hidden;&#125;.edui-default .edui-for-xiumi .edui-icon &#123; background-image: url("../images/xiumi-connect-icon.png") !important; background-size: contain;&#125; 在ueditor.all.js修改代码。在iframeUrlMap对象里添加键值对’xiumi’: ‘~/xiumi-ue-dialog-v5.html’，这个和刚刚那个html存放的地方有关。在btnCmds数组里添加一个’xiumi’字符串，在dialogBtns对象中的ok数组里添加’xiumi’字符串。 最后在UE的前端配置里toolbars数组里添加’xiumi’,即可成功展示出秀米图标与秀米的弹框。 效果如下 在ueditor.config.js的xss过滤白名单whitList配置里，修改section参数。同时将设置是否抓取远程图片catchRemoteImageEnable设置为true。 1section:['class', 'style'], 能成功弹出秀米的弹框，并且能将秀米里的模版成功勾选到本地的UE编辑器里，说明集成就成功了一半啦。 二、秀米域名的图片转存。要完成秀米图片的转存，首先我们要先完成UE对复制过来的网络图片的转存，图片的转存分为img标签与背景图片的抓取与转存。 设置抓取白名单catcherLocalDomain，在白名单里的地址，UE不会对其发起转存请求。可以使用两种方式设置： 使用UE.utils.extend方法强制在UE实例化后设置 123UE.utils.extend(editor.options, &#123; catcherLocalDomain: ['127.0.0.1', 'localhost', "static-alpha-engage.gridsumdissector.com", "static-beta-engage.gridsumdissector.com", "static-uat-engage.gridsumdissector.com", "static.engage-all.com"], &#125;); 修改ueditor.all.js里的初始配置代码，在这个js文件大概第8100行的地方，有一个loadServerConfig的函数，可以直接在这里将catcherLocalDomain的初始值设置为我们想要过滤的白名单域名。 修改抓取图片的后端请求地址。UE发起所有接口请求都依赖于一个名为serverUrl的前端配置，然后通过使用serverUrl这个唯一的请求地址，通过GET参数action指定不同请求类型，比如uploadimage(执行上传图片或截图的action名称), uploadvideo(执行上传视频的action名称), catchimage(执行抓取远程图片的action名称)等等，但是后端为了方便接口的管理，一般会将接口拆分出来，当然UE也支持自定义请求地址。UE推荐的方法如下： 12345678910UE.Editor.prototype._bkGetActionUrl = UE.Editor.prototype.getActionUrl;UE.Editor.prototype.getActionUrl = function(action) &#123; if (action == 'uploadimage' || action == 'uploadscrawl' || action == 'uploadimage') &#123; return 'http://a.b.com/upload.php'; &#125; else if (action == 'uploadvideo') &#123; return 'http://a.b.com/video.php'; &#125; else &#123; return this._bkGetActionUrl.call(this, action); &#125;&#125; 原理就是使用一个名为_bkGetActionUrl的临时变量承载原来的getActionUrl方法，然后重写getActionUrl方法，判断action的类型，来返回不同的接口，同时也还可以执行原来的getActionUrl方法。但是我在使用这种方法的时候，会偶尔碰到内存溢出，导致上传图片功能不可用的原因，可能是getActionUrl在其他地方也被重新赋值了，产生循环引用该函数的问题。所以我依旧在ueditor.all.js里修改了getActionUrl原始函数，大概在第8040行代码里，判断getActionUrl函数内部一个actionName的参数，来返回你想要的接口名。 到这里差不多能够抓取到img标签的src并且可以将其替换了，但需要注意俩点地方： 注意抓取后，后端返回的数据格式时候和UE里源码设置的一样，在ueditor.all.js找到UE.plugins[‘catchremoteimage’]这个函数，在其内部执行catchremoteimage的success回掉函数的地方注意获取源路径和新路径的数据路径的地方。 UE内部有一个判断是否跨域的方法，如果跨域会使用jsonp的方式请求接口，如果你是本地调试，并且后端已经对跨域crose处理，不需要使用jsonp的方式请求，你可以把它关了。同样在UE.plugins[‘catchremoteimage’]这个函数里，找到定义catchremoteimage函数的地方，将其内部ajax请求的option里，将dataType固定设置为空字符串即可。 除了img标签的src替换，背景图片也是需要进行图片抓取和替换的。其实就是依葫芦画瓢，看明白了UE是如何对img标签进行src替换的，也就明白该如何对背景图片进行替换了。 首先你需要在ueditor.all.js文件的domUtils参数里新添一个方法getElementsByTagNameStyle。通过元素的style来获取元素节点数组。 1234567891011121314151617181920212223/** * 方法getElementsByTagNameStyle的封装 * @method getElementsByTagNameStyle * @param &#123; e &#125; node 目标节点对象 * @param &#123; t &#125; tagName 需要查找的节点的tagName， 多个tagName以空格分割 * @param &#123; i &#125; style 节点对象的筛选条件 * @return &#123; Array &#125; 符合条件的节点集合 */ getElementsByTagNameStyle: function (e, t, i) &#123; if (i &amp;&amp; utils.isString(i)) &#123; var n = i; i = function (e) &#123; for (var t, i = n.split(","), o = !0, r = e.getAttribute("style"), a = 0; t = i[a++];) if (!r || r.indexOf(t) &lt; 0) &#123; o = !1; break &#125; return o &#125; &#125; t = utils.trim(t).replace(/[ ]&#123;2,&#125;/g, " ").split(" "); for (var o, r = [], a = 0; o = t[a++];) for (var s, l = e.getElementsByTagName(o), d = 0; s = l[d++];) i &amp;&amp; !i(s) || r.push(s); return r &#125;, 在UE.plugins[‘catchremoteimage’]下的catchRemoteImage监听函数里添加代码。首先你得的到有背景图片的的元素节点数组。使用刚刚新添的方法 1backgroundimagestags = domUtils.getElementsByTagNameStyle(me.document, "section div p", "background,url")//抓取背景图片所在的标签 然后将该元素节点数组里的图片地址都抽取出来，放在一个存放图片地址的数组里 12345678910111213141516var backgroundimages = [];for (var i = 0, backci; backci = backgroundimagestags[i++];) &#123; var bstyle = backci.style; var backgroundimgurltag = bstyle['background-image'] || bstyle['background'] || ""; if (backgroundimgurltag != null &amp;&amp; backgroundimgurltag != "") &#123; var backsrc = backgroundimgurltag.split("(")[1].split(")")[0].replace(/\"/g, "") || backgroundimgurltag.split("(")[1].split(")")[0].replace(/\"/g, "") || ""; if (backsrc != null &amp;&amp; backsrc != "") &#123; if (/^(https?|ftp):/i.test(backsrc) &amp;&amp; !test(backsrc, catcherLocalDomain)) &#123; backgroundimages.push(encodeURI(backsrc)); &#125; &#125; &#125;&#125; 最后依葫芦画瓢，对该图片地址数组循环，依次发起转存请求，并且将对应的节点内的背景图片url进行替换。 123456789101112131415161718192021222324252627282930313233343536373839404142if(backgroundimages.length) &#123; catchremoteimage(backgroundimages, &#123; //成功抓取 success: function (r) &#123; try &#123; var info = r.state !== undefined ? r:eval("(" + r.responseText + ")"); &#125; catch (e) &#123; return; &#125; /* 获取源路径和新路径 */ var i, j, ci, cj, oldSrc, newSrc, styleText ,list = info.data.list; for (i = 0; ci = backgroundimagestags[i++];) &#123; styleText = ci.getAttribute("style"); oldSrc = styleText; if (oldSrc.indexOf('url("') &gt; 0) &#123; oldSrc = oldSrc.split('url("')[1].split('")')[0]; &#125; else if (oldSrc.indexOf("url('") &gt; 0) &#123; oldSrc = oldSrc.split("url('")[1].split("')")[0]; &#125; else &#123; if (!(oldSrc.indexOf("url(") &gt; 0)) continue; oldSrc = oldSrc.split("url(")[1].split(")")[0]; &#125; if (oldSrc.indexOf("?") &gt;= 0) &#123; oldSrc = oldSrc.split("?")[0]; &#125; for (j = 0; cj = list[j++];) &#123; if (oldSrc == cj.source &amp;&amp; "SUCCESS" == cj.state) &#123; newSrc = catcherUrlPrefix + cj.url, styleText = styleText.replace(oldSrc, newSrc), domUtils.setAttributes(ci, &#123; style: styleText &#125;), domUtils.setAttributes(ci, &#123; is_updata: "true" &#125;); break &#125; &#125; &#125; me.fireEvent('catchremotesuccess') &#125;, //回调失败，本次请求超时 error: function () &#123; me.fireEvent("catchremoteerror"); &#125; &#125;); &#125; 到这里，UE对普通的img标签及背景图片的抓取与转存已经成功了，如果想要对秀米过来的图片进行转存需要注意以下俩点： 对某些秀米图片地址的后缀进行处理，去掉?号之后类似?x-oss-process=所有的部分。这个在catchremoteimage函数里对imgs进行一步map循环，将？后面的东西去掉即可，同时注意在图片地址数组循环的过程中oldSrc？后面的内容也要去掉，否则oldSrc == cj.source &amp;&amp; “SUCCESS” == cj.state这一步判断不会通过，就无法进行图片地址的替换了。 从秀米回到本地UE编辑器的时候不会触发图片转存请求，这也是秀米文档埋下的一个坑！解决这个问题，你需要在xiumi-ue-dialog-v5.html文件里，在dialog.close();代码前添加一句editor.fireEvent(&#39;afterpaste&#39;);来主动触发afterpaste这个监听函数。 大功告成]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[原型链的理解]]></title>
    <url>%2F2019%2F05%2F11%2Fprototype%2F</url>
    <content type="text"><![CDATA[123456[].__proto__ === Array.prototypeArray.__proto__ === Function.prototypeArray.prototype.__proto__ === Object.prototypeFunction.__proto__ === Function.prototype // Function.prototype 是个方法，是通过继承Object.prototype而产生的,Function.__proto__.__proto__ === Object.prototype // Object.prototype 原型链顶端，是对象，但它不是通过Object函数创建的。是浏览器引擎按照ECMAScript规范创造的一个对象Object.prototype.__proto__ === null]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue如何与TypeScript搭配使用]]></title>
    <url>%2F2019%2F05%2F07%2Fvue-ts%2F</url>
    <content type="text"><![CDATA[最近真的陷入了TypeScript无法自拔，我甚至有一种感觉ts可能会成为前端必须要掌握的一项技术(就像现在前端从业者必须得掌握三大框架之一一样)。 但现在使用vue+TypeScript来开发项目的其实还是比较少的，Vue的作者尤雨溪在知乎上回答过这么一个问题TypeScript 不适合在 vue 业务开发中使用吗？,根据他本人的回答，现在的vue2.x版本对TS的支持是远不如React和Angular的，所以在即将发布的vue3.0要加强这一块。 但是因为vue-class-component与vue-property-decorator(前者的升级版本，加入了Vue，Watch，Emit等功能)的存在，现在使用TS+vue来写项目也不是什么问题，虽然还有些稍许的bug，不过无伤大雅 在前面的博客里我介绍过如何使用TypeScript如何搭建store文件夹，所以这篇博文主要做一个用JS与TS编写vue文件的区别。(引入的是vue-property-decorator，全部介绍完基本上是不可能的，这里结束的是平时用的多的) #data,computed,methodsJS写法123456789101112131415161718192021222324252627export default &#123; name:'HelloWorld', data()&#123; return &#123; bar:'hello', foo:1 &#125; &#125;, computed:&#123; comBar()&#123; return this.bar+'world' &#125; comFoo:&#123; get:function()&#123; return this.foo+1 &#125; set:function(newVal)&#123; console.log(newVal) &#125; &#125; &#125;, methods:&#123; handleFn()&#123; // ...do something &#125; &#125;&#125; TS写法12345678910111213141516171819import &#123;Component,Vue&#125; from 'vue-property-decorator';@Component(&#123; name:'HelloWorld'&#125;)export default class HelloWorld extends Vue &#123; bar:string = 'hello'; foo:number = 1; get comBar():string&#123; return this.bar + 'world' &#125; set comBar(val:string)&#123; // 注意，这里不能标返回值类型，就算写void也不行 console.log(val) &#125; handleFn():voids&#123; //...do something &#125;&#125; @Component({options}) 中接受的options就是传统的配置，mixin,自定义指令,子组件的注册都要在这里声明 #watchJS写法1234567891011export default &#123; watch:&#123; 'foo':&#123; handler:function(newVal,oldVal)&#123; console.log(newVal,oldVal) &#125;, deep:true, // 开启深度监听 immediate:true // 该回调(handler函数)将会在侦听开始之后被立即调用 &#125; &#125;&#125; TS写法12345678import &#123;Vue,Watch,Component&#125; from 'vue-property-decorator'export default class HelloWorld extends Vue &#123; @Watch('foo',&#123;deep:true,immediate:true&#125;) onWatchFoo(newVal:string,oldVal:string)&#123; // 监听的方法名是可以自定义的 // do something... &#125;&#125; #props #directivesJS写法1234567891011121314151617181920212223242526272829303132333435363738394041export default &#123; name:'childComponent', props:&#123; bar:Boolean, foo:&#123; type:String, defalut:'abc' &#125;, obj:&#123; type:Object, default:function()&#123; return &#123; a:1 &#125; &#125;, required:true // 定义该prop是否是必填项 validator:function(value)&#123; // 自定义验证函数 return出来一个boolean值 return Object.keys(values).includes('a') &#125; &#125; &#125;, directives:&#123; focus:&#123; inserted:function(el,binding,vnode,oldVnode)&#123; // el:指令所绑定的元素，可以用来直接操作DOM el.focus(); // binding:一个对象，包括以下属性 // name: 指令名--focus // value： 指令的绑定值，例如v-my-directives="1+1"中，value的值为2 // oldValue：指令绑定的前一个值。仅在update和componentUpdated钩子中可用。无论值是否改变都可用 // expression：字符串形式的指令表达式。例如v-my-directives="1+1"中，表达式为‘1+1’ // arg：传给指令的参数，例如 v-my-directives:foo='...'中,参数为‘foo’ // modifiers：一个包含修饰符的对象。例如：v-my-directives.stop.prevent中，修饰符对象为&#123;stop:true,prevent:true&#125; let &#123;name,value,oldValue,expression,arg,modifiers&#125; = binding; // vnode: Vue 编译生成的虚拟节点 // oldVnode：上一个虚拟节点，仅在update和componentUpdated钩子中使用 &#125; &#125; &#125;&#125; TS写法123456789101112131415161718192021222324252627282930313233343536373839404142import &#123;Vue,Component,Prop&#125; from 'vue-property-decorator';// 第一种你可以在在@Component里@Component(&#123; props:&#123; bar:&#123; type:Boolean, default:false &#125; &#125;, directives:&#123; focus:&#123; inserted:function(el,binding,vnode,oldvnode)&#123; el.focus() &#125; &#125; &#125;&#125;)// 第二种使用@Prop的方式interface ObjProp &#123; a:number&#125;@Component()export default class HelloWorld extends Vue &#123; @Prop(&#123;default:false&#125;) bar!:boolean //!: 表示强制解析，告诉ts我这里一定有值 如果没有写！，虽然不会报错但是代码会有红线提示 @Prop( &#123; default:function()&#123; return &#123;msg:'haha3'&#125; &#125;, required:true, validator:function(value)&#123; return Object.keys(value).includes('a') &#125; &#125; ) obj!:ObjProp // 好像直接写一个&#123;&#125;作为默认值也没问题 obj!:&#123; a:number &#125;&#125; @Model 前提条件，在父组件中，对子组件使用了v-mode=&quot;checked&quot; 父组件1&lt;checkbox v-mode="checked" &gt;&lt;/checkbox&gt; 子组件1&lt;input type="checkbox" :checked="checked" @change="change"/&gt; JS写法12345678910111213141516// 子组件中export defalut &#123; // model 参数为2.2.0新增，允许一个自定义组件在使用v-model时定制prop和event model:&#123; prop:"checked", event:"change" &#125;, props:&#123; checked:Boolean &#125;, methods:&#123; change:function(e)&#123; this.$emit('change',e.target.checked) &#125; &#125;&#125; TS写法12345678import &#123;Vue,Component,Model,Emit&#125; from "vue-property-decorator";@Component()export default class HelloWorld extends Vue &#123; @Model('checked',&#123;type:Boolean&#125;) checked!:boolean, @Emit('change') change(e:MouseEvent)&#125; @Emit父组件1&lt;add-component @on-add="addFunction"&gt;&lt;/add-component&gt; 有一个可以做加减法的子组件,如下12345&lt;div&gt; &lt;button @click="onSub"&gt;-&lt;/button&gt; &lt;input tepe="test" v-model="count"/&gt; &lt;button @click="onAdd"&gt;+&lt;/button&gt;&lt;/div&gt; JS写法 12345678910111213141516export default &#123; data()&#123; return &#123; count:0 &#125; &#125;, name:'addcomponent', methods:&#123; onSub()&#123; this.$emit('on-sub',this.count) &#125;, onAdd()&#123; this.$emit('on-add',this.count) &#125; &#125;&#125; TS写法123456789101112131415161718import &#123;Vue,Component,Emit&#125; from 'vue-property-decorator';@Component(&#123; name:'addcomponent'&#125;)export default class AddComponent extends Vue &#123; count:numer = 0; @Emit() // 如果父组件传过来的方法是 on-add 那么，@Emit里可以省略方法名 onAdd()&#123; this.count += 1; return this.count // 通过return的方式，在父组件的方法中才能在event中拿到值 &#125; @Emit('otherFnName') onSub()&#123; this.count -=1; return this.count &#125;&#125; @Provide @Inject通常provide与inject是配合使用的，一般使用在插件与组件库中，在父组件中通过provide提供一些数据，他的所有子组件，都能都通过inject注入到自己的组件中，并且通过this来调用。 provide：Object | () =&gt; Objectinject：Array&lt;string&gt; | { [key: string]: string | Symbol | Object } JS用法1234567891011121314151617181920212223// 父组件export default &#123; name:"father-component", provide:&#123; bar:1, foo:2 &#125;&#125;...// 任意子组件export default &#123; inject:['bar','foo'] // 如果需要定义默认值 inject:&#123; bar:&#123; default:'heihei' &#125;, foo1:&#123; form:'foo', // 声明从不同名字的属性注入 defalut:'haha' // 非原始属性，已工厂方法返回 ()=&gt;[1,2,3] &#125; &#125;&#125; TS用法123456789101112131415// 父组件import &#123;Vue,Component,Provide&#125; from 'vue-property-decorator';@Componentexport default class Father extends Vue &#123; @Provide() foo = "hello vue"&#125;// 子组件import &#123;Vue,Component,Inject&#125; from 'vue-property-decorator';@Componentexport default class Child extends Vue &#123; @Inject() foo !:string&#125; 综上所写，使用TS与使用JS编写vue文件的区别就全部罗列完了 但应该还有很多遗漏的点，如果你有什么补充，欢迎在留言区评论。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[记第一次去深大]]></title>
    <url>%2F2019%2F05%2F05%2Fdiary1%2F</url>
    <content type="text"><![CDATA[期待很久的五一假期已经过完了╥﹏╥…不出意外的,大部分时间还是宅在家里玩游戏为什么不想出门呢？第一: 比较反感去人多的地方第二: 这种天气宅着真的很舒服，如何形容呢，窗外下着忽大忽小的雨，家里蓝胖子又在沙发上打盹，温度适合穿着单薄的羽织，无论是窝在被子里，还是在游戏世界里激情厮杀都很舒服，玩累了就抱着蓝胖子一顿狂撸，不得不说惬意十分了。 总是在睡觉的蓝胖子然鹅…总是在家里宅着，身上会长蘑菇吧于是，选了个不下雨的下午，起身去了深圳大学。离家里不远，2站地铁就到了，步行10分钟，就能到深大的北门。也许第一次来，也许不是深大的学生，我踏进大门后居然有点点紧张(我也不知道我紧张个锤子)因为深大就在深南大道的路边，不同于马路上呼啸而过的汽车，深大就显得很安静，让人一下就放松下来，假期的校园没有什么人，但有不少带小孩过来散步的家庭。沿着大路往下走，左拐进入了一个田径场，去观众席上坐着，看着田径场上跑步的陌生人，我陷入了自己大学生活的回忆中，记忆中我离开大学的最后一件事也是像这样，坐在观众席上，看着跑步的陌生人发呆。何曾几时，我也是校园里无忧无虑的一名学子。真怀念那段时光讷…深大北门的田径场离开了田径场，随便挑选一条路，继续往下走，深大的绿化做的真的不错，有路的地方旁边一定有树。不知名的小路1在这里上学一定很辛福吧，每条路都很适合闲暇时光的闲逛。(当年咋就不加点油，考个深大呢！)不知名的小路2然后，在乱走一通后，路过了深大的宿舍楼，在宿舍楼下发现了一只花不溜秋的小猫，和他的小食堂。小猫当时似乎在草丛里上厕所…真的非常不好意思偷拍了你…小花猫和他的食堂继续往下走还看到了一只非常漂亮的小白猫，忘记拍照了，真可惜。相比外面的小野猫，深大的猫咪似乎都不怎么怕人，猫咪们能在深大生活也是一件幸运的事吧，毕竟照顾他们的都是一群心善的年轻人。漫无目的的继续走，好像来到了深大的图书馆，从外面看建筑比较老式的了，没有进去看，偶尔有学生进出，果然每个学校都有学霸即使在假期还继续在图书馆里奋斗。汉京集团的大楼就矗立在不远处，那几个 “I love SZ”大字，从这个角度看好像显的更加年轻呢。图书馆离开了图书馆后，步行来到了一个人工湖的旁边，这里男女成双出现的概率大了许多，不得不说，每个学校的人工湖都是小情侣们的约会圣地，风景漂亮，散步在湖边的小路上说说笑笑，都是爱情的样子。比较惊讶的是，这里有很多黑天鹅。上回见到黑天鹅还是几年前去厦大的时候，难道黑天鹅和名校是标配吗？深大的湖黑天鹅在人工湖旁的凉亭坐了一会，心里想着这个季节是大学毕业生们拍摄毕业照，喝毕业酒的时候吧。真好呢。深大真的很美，也很安静。适合散步放松心情。然后天差不多要黑了，起身拍了拍屁股上的灰，就寻路回家了。——————我是分割线——————怀念过往像香烟一样，会让人沉迷。所以，不要在过往中无法自拔，也不要割断自己的过往。将美好的过往像美酒一样密封，常年埋藏在地下。或在夜深的时候，或在孤身一人的时候，或在疲惫于生活的时候，将美酒拿出，取其一瓢，慢慢品尝。所以，偶尔怀念过往，让自己的灵魂暂时脱离这个车水马龙的世界，回到那段最珍贵的时光，回到那些最难忘的人们的身旁，一起嬉笑，一起挥霍时光。如果有时光机，你最想回到哪段时光呢？]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[看懂vue源码-理解数据双向绑定的实现]]></title>
    <url>%2F2019%2F04%2F29%2Fvue-databind%2F</url>
    <content type="text"><![CDATA[如果你是一名前端从业者，并且在简历上写了会使用vue框架，那么在拿着这份简历去面试的时候，面试官有很大的概率会问你vue的数据双向绑定是如何实现的。打开goole，输入vue双向绑定，有非常多优秀的博主已经对vue数据双向绑定作了一个全方位的刨析，阅读之后，你会大概了解，双向绑定涉及到javascript的核心api是Object.defineProperty,通过set与get这俩个存取描述符来监听数据的实时改变，并且在对模版作出相应改变。那么为了更加了解vue是如何实现数据双向绑定的，我花了一下午的时间阅读vue的源码，并将我的对vue实现数据双向绑定的方式理解记录了下来。 打开vue源码目录这几个文件夹都是分别负责什么的，我们暂且不管(其实是我不知道),我们找到入口文件src/core/index.js。看到一大推第一次见并且不熟的代码，谁都会感动头疼。所以我看源码的基本方针是 不清楚应用方法的具体实现，先靠他的命名猜一下(所以英文好很关键，哭)。 如果有一大堆if..else-if..else,先找到按正常流程走的代码,其他分支先放一放… 不用钻牛角尖，看的懂的代码就好好理解，看不懂的了解个大概足已！看源码的目的是更好的理解框架的实现原理，并不是要把整个框架吃透(关键也吃不透啊，vue源代码那么多，咱也不是啥大神，难道看不懂去问尤雨溪吗，咱也不敢问讷) 12345678910111213141516171819202122232425262728// src/core/index.jsimport Vue from './instance/index' //从Vue这个关键词来看，这个应该是vue的核型方法import &#123; initGlobalAPI &#125; from './global-api/index' // 初始化全局API？import &#123; isServerRendering &#125; from 'core/util/env' // 判断是不是ssr？import &#123; FunctionalRenderContext &#125; from 'core/vdom/create-functional-component'// 调用方法咯，初始化全局变量initGlobalAPI(Vue)// 给vue原型添加$isServer属性 --当前 Vue 实例是否运行于服务器。Object.defineProperty(Vue.prototype, '$isServer', &#123; get: isServerRendering&#125;)// 给vue原型添加$ssrContext 不认识这玩意Object.defineProperty(Vue.prototype, '$ssrContext', &#123; get () &#123; /* istanbul ignore next */ return this.$vnode &amp;&amp; this.$vnode.ssrContext &#125;&#125;)// 不认识// expose FunctionalRenderContext for ssr runtime helper installationObject.defineProperty(Vue, 'FunctionalRenderContext', &#123; value: FunctionalRenderContext&#125;)Vue.version = '__VERSION__'export default Vue 我就是以上面这种方式来一点点看源码的。根据上面得到的提示，我们应该去看看./instance/index里写了啥。123456// src/core/instance/indeximport &#123; initMixin &#125; from './init'...initMixin(Vue)...export default Vue 其他初始化函数我们先不看，从initMixin这个名字和第一个引入的骄傲位置来说，他应该和我们要找的data属性有一腿。所以我们打开./init看一下。12345// src/core/instance/initimport &#123; initState &#125; from './state'...initState(vm)... 从命名上来讲，state应该是与data联系更多的，也许是因为在react里，初始化数据就叫作state吧，所以我们打开./state找到initState方法1234567891011121314151617// src/core/instance/stateexport function initState (vm: Component) &#123; vm._watchers = [] // 看起来像清空一个观察者队列 const opts = vm.$options if (opts.props) initProps(vm, opts.props) // 初始化props参数 if (opts.methods) initMethods(vm, opts.methods) // 初始化methods参数 if (opts.data) &#123; initData(vm) // 如果有data参数，初始化data参数 &#125; else &#123; observe(vm._data = &#123;&#125;, true /* asRootData */) // 如果没有，触发observe方法(这个方法很关键！)，给一个&#123;&#125;作为默认值并且作为rootdata &#125; if (opts.computed) initComputed(vm, opts.computed) // 初始化computed参数 if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123; // watch存在并且 这个watch不是Firefox(火狐浏览器)在Object.prototype上有一个“监视”功能,初始化 initWatch(vm, opts.watch) &#125;&#125; 从上面的代码中，我们看到很多脸熟的代码了，并且终于找到我们想找的data属性，顺水推舟继续往下走吧，找到initData的方法定义。1234567891011121314151617181920212223242526272829303132333435363738394041424344function initData (vm: Component) &#123; let data = vm.$options.data data = vm._data = typeof data === 'function' ? getData(data, vm) : data || &#123;&#125; // 判断data是不是个函数，如果时执行getData（往一个targetStack push进去？） if (!isPlainObject(data)) &#123; // isPlainObject判断data是不是个对象 data = &#123;&#125; process.env.NODE_ENV !== 'production' &amp;&amp; warn( 'data functions should return an object:\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm ) &#125; // proxy data on instance const keys = Object.keys(data) const props = vm.$options.props const methods = vm.$options.methods let i = keys.length while (i--) &#123; // 判断data里定义的key是否与methods和props的冲突 const key = keys[i] if (process.env.NODE_ENV !== 'production') &#123; if (methods &amp;&amp; hasOwn(methods, key)) &#123; warn( `Method "$&#123;key&#125;" has already been defined as a data property.`, vm ) &#125; &#125; if (props &amp;&amp; hasOwn(props, key)) &#123; process.env.NODE_ENV !== 'production' &amp;&amp; warn( `The data property "$&#123;key&#125;" is already declared as a prop. ` + `Use prop default value instead.`, vm ) &#125; else if (!isReserved(key)) &#123; proxy(vm, `_data`, key) &#125; &#125; // observe data observe(data, true /* asRootData */)&#125; 到这里，我们已经很接近实现数据双向绑定的函数了，那就observe，接下来去../observer/index里看看，observe函数到底写了些什么东西。在export function observe()的函数里，return出来的是一个名为Observer的类1234567891011121314151617181920212223242526272829303132333435363738394041424344// src/core/observer/index.jsexport class Observer &#123; value: any; dep: Dep; vmCount: number; // number of vms that have this object as root $data constructor (value: any) &#123; this.value = value this.dep = new Dep() this.vmCount = 0 def(value, '__ob__', this) if (Array.isArray(value)) &#123; if (hasProto) &#123; protoAugment(value, arrayMethods) &#125; else &#123; copyAugment(value, arrayMethods, arrayKeys) &#125; this.observeArray(value) &#125; else &#123; this.walk(value) &#125; &#125; /** * Walk through all properties and convert them into * getter/setters. This method should only be called when * value type is Object. */ walk (obj: Object) &#123; const keys = Object.keys(obj) for (let i = 0; i &lt; keys.length; i++) &#123; defineReactive(obj, keys[i]) &#125; &#125; /** * Observe a list of Array items. */ observeArray (items: Array&lt;any&gt;) &#123; for (let i = 0, l = items.length; i &lt; l; i++) &#123; observe(items[i]) &#125; &#125;&#125; 当我们调用new Oberver(value)的时候，会执行this.walk(value)这个方法，看方法里的作用应该是，遍历value,执行defineReactive方法，而在defineReactive方法里主要就是通过Object.defineProperty方法来定义响应式数据。123456789101112131415161718192021222324// src/core/observer/index.jsexport function defineReactive ( obj: Object, key: string, val: any, customSetter?: ?Function, shallow?: boolean) &#123; const dep = new Dep() ... Object.defineProperty(obj, key, &#123; ... get: function reactiveGetter () &#123; ... dep.depend() ... return value &#125;, set: function reactiveSetter (newVal) &#123; ... dep.notify() &#125; &#125;)&#125; 省略了部分代码后，我们注意到在get和set里分别执行了dep.depend()和dep.notify(),而Dep就是我们常说的订阅发布管理中心，这时候我们来看一张，vue实现数据双向绑定的示例图。大概解释一下上图，上图实现的设计模式为 订阅-发布 模式。可以从俩个入口分别说起 1.从init Data说起，比如我们在vue实例中定义了初始化的data属性，接着会触发new Observer(),data里所有的数据都会通过上面介绍的那样，通过defineReactive这个方法为每一个属性挂载Object.defineProperty(也可以说在get里为每一个属性都添加了一个订阅，在set里做一个通知订阅者的操作),如果触发了setter，也就是在业务代码里改变了data里的值，会通知Watcher，Wathcer更新指令系统对应绑定的data值2.从编译侧说起，Dom 上通过指令或者双大括号绑定的数据，经过编译以后，会为数据进行添加观察者Watcher，当实例化Watcher的时候 会触发属性的getter方法，此时会调用dep.depend()，并且会将Watcher的依赖收集起来。 那么我们可以看一下dep.depend()和dep.depend()1234567891011121314151617181920// src/core/observer/dep.js depend () &#123; if (Dep.target) &#123; Dep.target.addDep(this) &#125; &#125; notify () &#123; // stabilize the subscriber list first const subs = this.subs.slice() if (process.env.NODE_ENV !== 'production' &amp;&amp; !config.async) &#123; // subs aren't sorted in scheduler if not running async // we need to sort them now to make sure they fire in correct // order subs.sort((a, b) =&gt; a.id - b.id) &#125; for (let i = 0, l = subs.length; i &lt; l; i++) &#123; subs[i].update() &#125; &#125; 首先我们得先知道注入到Dep里的一般都是Watcher类，像Dep.target.addDep(this)和subs[i].update()这俩个方法是可以在定义Watcher的文件下找到的。12345678910111213141516171819202122// src/core/observer/watcher.js addDep (dep: Dep) &#123; const id = dep.id if (!this.newDepIds.has(id)) &#123; this.newDepIds.add(id) this.newDeps.push(dep) if (!this.depIds.has(id)) &#123; dep.addSub(this) &#125; &#125; &#125; ... update () &#123; /* istanbul ignore else */ if (this.lazy) &#123; this.dirty = true &#125; else if (this.sync) &#123; this.run() &#125; else &#123; queueWatcher(this) &#125; &#125; 一系列操作的主要作用就是让Dep与Wathcer建立双向的联系。 代码真是太多了，解释不完，感觉要烂尾了 最后vue有一个很关键的指令解析系统，在src/compiler/directives文件中可以找到v-bind,v-on,v-model相应的源码。能力有限，看不下去了。越挖越深。 说的我自己都乱了 言简意赅的总结一下，Observer就是对data里到所有值进行一个数据劫持，强行给每个数据注入set(能监听到数据改变，没有return)与get(该数据具体呈现出来的值，能return出数据)方法，Observer操作完以后，data可以理解成房子资源。然后Dep是个订阅器（订阅管理中心，可以理解成房地产中介），Watcher是订阅者(有钱买房的人)，Watcher把需求和联系方式通过dep.depend()告诉中介dep，dep中介找到了合适的房子通过dep.notify()打电话通知我们忽悠买房。那Wathcer没有钱之前就是被绑定在dom上的一些数据，通过了v-model,v-test,双大括号等途径赚到了钱（也就是vue的compile编译系统），升级成了一个Wathcer，赚钱和买房总是无穷无尽的，dom发生了更新（比如input事件），赚到钱了就去问中介dep有没有房，同时如果房源发生了变化（data发生了更新），中介dep会通知Wathcer买房不? 最后祝大家早日能买到房。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[加深了解vuex及使用typescript如何搭建store文件夹]]></title>
    <url>%2F2019%2F04%2F24%2Fvuex%2F</url>
    <content type="text"><![CDATA[自从使用vue作为项目开发框架后，vue的全家桶每天都会与我见面，其中vuex更是常客。对于专门作为vue的状态管理模式，我认为这应该是每一位前端从业者都必须深入掌握的一项技能，可是在这段时间的面试中，我问了一些vuex相关的知识，却很少有人回答全面，即使他们的简历上写了3-4年的从业经验。比如以下这些vuex最基础的问题。 如何调用store.js里的Mutation与Actions里定义的方法？ 大部分人回答的都是以通过this.$store.commit或者this.$store.dispatch这种通过调用vue实例中的$store的方式，而且只知道这一种调用方法。其实还有两种方式:1.通过import store from &#39;store.js&#39;的方式引入文件，通过store.commit和store.dispatch的方式调用。2.使用mapActions,mapMutation等辅助函数将组件的methods映射为store对应的方法名。 使用过vuex的module概念吗？在.vue文件中如何使用module里的Mutation与Actions里定义的方法？ 这个基本上就全军覆没了，仅知道vuex有这么一个概念，但项目中没有用过，所以对于模块化的store不了解。对于vuex的module概念，其实真的不难，个人觉得，即使项目中没有用过，但vuex作为我们日常开发中的老朋友，认真了解一下他5个孩子State,Getter,Mutation,Action,Module，从时间成本上来说，也许一个晚上就可以搞定，即使现在项目中使用不到，那未来的项目再碰到至少不会措手不及吧。 从以上俩个基础问题可以看出，很多前端对vuex的学习并不深入，觉得能在项目中使用就可以了，毕竟代码不是浮现在页面上的东西，只要功能能正确实现，很少有人对你的代码会有兴趣。这怎么说呢，多少是有点道理的，但是对知识的追求不该止步于实现功能这一步，既然尤雨溪开源了vue这么好的前端框架，如果我们不更加深入了解vuex，是不是对别人的知识成果不尊重呢？ Vuex到底是什么东西？在说vuex之前，可以先了解一下Flux与Redux。每一位前端对MVC框架与MVVM框架都不陌生，如果略显遗忘，可以参考阮一峰老师的对这几个框架的解释,简单来说Flux是一种架构思想，专门解决软件的结构问题，而Redux则是将Flux与函数式编程结合在一起,使收Flux启发的简介版Flux。其实这些概念都不重要，随便百度一下就好啦︿(￣︶￣)︿按照官方的说法Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。按照惯例放一张官方的图vuex的五个核心概念State,Getter,Mutation,Action,Module,基本用法我就不再一一列举了，参考vue官网一定比我介绍的详细。 以下只介绍一些我个人对这几个概念中比较少用的知识点的罗列。 State 如何获取模块内的state12345678910import &#123;mapState&#125; from 'vuex';export default &#123; computed:&#123; ...mapState([&#123; count:state=&gt;state.moduleName.count &#125;]) &#125;&#125;orthis.$store.state.moduleName.count Module 如何使用mapState, mapGetters, mapActions 和 mapMutations 这些函数来绑定带命名空间的模块。 在辅助函数第一个参数可以填模块名 12...mapGetters('moduleName',['foo','bar'])...mapActions('moduleName',['fn1','fn2']) 使用 createNamespacedHelpers 创建基于某个命名空间辅助函数 123const &#123; mapState, mapActions &#125; = createNamespacedHelpers('moduleName')...mapGetters('moduleName',['foo','bar'])...mapActions('moduleName',['fn1','fn2']) 通过this.$store调用,比如现在模块名叫child 123this.$store.getters['child/foo']this.$store.commit('child/addCount',1)this.$store.dispatch('child/fn',data) 在带命名空间的模块内访问全局内容 getters有四个参数state,getters,rootState,rootGetters,后面两个是全局内容。actions第一个参数是个object，他里面包含{ dispatch, commit, getters, rootGetters }，最后一个是全局内容。在actions里如果要分发 action 或提交 mutation，将 { root: true } 作为第三参数传给 dispatch 或 commit 即可。 12dispatch('someOtherAction', null, &#123; root: true &#125;) // -&gt; 'someOtherAction'commit('someMutation', null, &#123; root: true &#125;) // -&gt; 'someMutation' 在带命名空间的模块注册全局 action若需要在带命名空间的模块注册全局 action，你可添加 root: true，并将这个 action 的定义放在函数 handler 中。 1234567// module/child.js actions: &#123; someAction: &#123; root: true, handler (&#123; dispatch, commit, getters, rootGetters &#125;, payload) &#123; ... &#125; // -&gt; 'someAction' &#125; &#125; 使用Typescript开发的项目如何写vuex的store文件夹这个就有意思啦，既然选择了ts代替了js，那么ts的一些特性就要使用起来，于是我写了一个demo。下图是我demo的文件结构，有木有觉得分的很清晰，很详细，哈哈。其中list是一个模块。接下来就一个一个文件看过去吧。 index.ts store的对外暴露文件123456789101112131415161718 import Vue from 'vue' import Vuex ,&#123;StoreOptions&#125;from 'vuex' import &#123;RootState&#125; from './type'; import &#123;todolist&#125; from './module/list/index'; Vue.use(Vuex) const store: StoreOptions&lt;RootState&gt; = &#123; state: &#123; version:'1.0.0' &#125;, //注册全局state getters:&#123;&#125;, //注册全局getters mutations: &#123;&#125;, //注册全局mutations actions: &#123;&#125;, //注册全局actions modules:&#123; todolist &#125; &#125;export default new Vuex.Store&lt;RootState&gt;(store); 如果你对StoreOptions&lt;RootState&gt;这种写法有疑问，你可以参考vuex的源代码，在vuex/types/index.d.ts文件中有相关介绍。并且你需要了解ts的泛型与类型变量。 type.ts 暴露全局state的接口，如果要新添state，要提前在这里定义类型，因为类型检查器会检查接口里的属性 123export interface RootState &#123; version: string&#125; module/list/index.ts store模块list的对外暴露文件 123456789101112131415161718import &#123;Module&#125; from 'vuex';import &#123;ListState&#125; from './type';import &#123;getters&#125; from './getters';import &#123;mutations&#125; from './mutations';import &#123;actions&#125; from './actions';import &#123;RootState&#125; from '../../type'const namespaced:boolean = true; //开启命名空间export const state:ListState = &#123; listArr:[], foo:'hello'&#125;export const todolist:Module&lt;ListState,RootState&gt; = &#123; namespaced, state, getters, mutations, actions&#125; 如果你对namespaced有疑问，可以参看vue的官网对命名空间的解释，点我 module/list/type.ts 暴露模块list的state的接口。 1234export interface ListState &#123; listArr ?: any[], foo ?: string&#125; module/list/getters.ts 暴露模块list的getters参数。 123456789import &#123;GetterTree&#125; from 'vuex';import &#123;ListState&#125; from './type';import &#123;RootState&#125; from '../../type';export const getters:GetterTree&lt;ListState,RootState&gt; = &#123; bar(state,getters,rootState,rootGetters): string &#123; return state.foo+' world' &#125;&#125; module/list/mutations.ts 暴露模块list的mutation参数。 12345678import &#123;MutationTree&#125; from 'vuex';import &#123;ListState&#125; from './type';export const mutations:MutationTree&lt;ListState&gt;=&#123; addFuHao(state,payload:string)&#123; state.foo += payload &#125;&#125; module/list/actions.ts 暴露模块list的actions参数。 123456789101112131415161718import &#123;ActionTree&#125; from 'vuex';import &#123;ListState&#125; from './type';import &#123;RootState&#125; from '../../type';export const actions:ActionTree&lt;ListState,RootState&gt;=&#123; fetchData(&#123;commit,dispatch,getters,rootGetters&#125;,payload):any&#123; setTimeout(()=&gt;&#123; commit('addFuHao','!!!!') &#125;,3000) &#125;, rootActionTestFn:&#123; //注册全局action root:true, handler(...a):any&#123; console.log('触发了rootActionTestFn') console.log(a) &#125; &#125;&#125; 一般来说模块内是很少嵌套子模块的，除非项目特别要求。如果需要，照葫芦画瓢就好啦。 那么定义好了store,如何使用呢？主要使用的是vuex-class。参考以下代码123456789101112131415161718192021import &#123; Component, Vue &#125; from 'vue-property-decorator';import &#123;State, Getter ,Mutation,Action&#125; from 'vuex-class';import &#123;ListState&#125; from '../store/module/list/type'const namespace:string = 'todolist'; //这里要注意，名称需要和模块暴露出来的参数名保持一致@Component(&#123; name:'todolist'&#125;)export default class ToDoList extends Vue&#123; @State('list') list:any; @Getter('bar',&#123;namespace&#125;) bar:any; @Mutation('addFuHao',&#123;namespace&#125;) addFuHao:any; @Action('fetchData',&#123;namespace&#125;) fetchData:any; //引入模块list的action @Action('rootActionTestFn') rootActionTestFn:any; //引入全局action mounted() &#123; console.log(this.bar) this.fetchData(); this.addFuHao(); &#125;&#125;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Nginx初体验]]></title>
    <url>%2F2019%2F04%2F20%2Fnginx%2F</url>
    <content type="text"><![CDATA[在有了自己的服务器后，不好好玩玩Nginx怎么行呢！毕竟花了钱的正好之前在学习TypeScript的时候，自己在github上有一个项目，所以想把这个项目丢到线上去玩玩～目标: 将github上的项目丢进服务器，并且能够正确访问 www.zijunfe.cn;前端要学习的东西真的很多，不过我们的征途是星辰大海！学习使我秃头 如何在CentOS服务器里下载Nginx 下载epel-release EPEL (Extra Packages for Enterprise Linux)是基于Fedora的一个项目，为“红帽系”的操作系统提供额外的软件包，适用于RHEL、CentOS和Scientific Linux. 1sudo yum install epel-release 下载nginx 1sudo yum install nginx Nginx 开机启动 1sudo systemctl enable nginx Systemctl是一个systemd工具，主要负责控制systemd系统和服务管理器。Nginx 关闭开机启动 1关闭开机启动 Nginx 启动 Nginx 1sudo systemctl start nginx 检查 Nginx 的运行状态 1sudo systemctl status nginx 如果你的服务器开启了防火墙，则需要同时打开 80（HTTP）和 443（HTTPS）端口,通过下面的命令来打开这两个端口： 123sudo firewall-cmd --permanent --zone=public --add-service=httpsudo firewall-cmd --permanent --zone=public --add-service=httpssudo firewall-cmd --reload 验证 Nginx 是否成功启动，可以在浏览器中打开 http://YOUR_IP，您将看到默认的 Nginx 欢迎页面 停止Nginx 1sudo systemctl stop nginx 重启Nginx 1sudo systemctl restart nginx 修改 Nginx 配置后，重新加载 1sudo systemctl reload nginx 如何免密登陆服务器 把自己电脑的私钥复制出来，例如在mac里私钥在～/.ssh/*.pub文件里，如果没有私钥和公钥，可以先生成，如何生成，执行ssh-keygen,一路回车。 登陆服务器，把刚刚复制的私钥放入 服务器~/.ssh/authorized_keys文件中 执行命令ssh-add k id_rsa,id_rsa就是那个以.pub结尾的文件名，如果执行报错，则先执行命令ssh-agent bashen,再执行添加命令 进入服务器只需要执行ssh root@ip地址就能免密登陆啦！ 如何添加nginx代理文件 在etc/nginx/conf.d中新增以.conf结尾的配置文件，比如你的域名叫做zijunfe.cn，那最好新增的文件名就叫zijunfe-cn.conf作为文件名。 vim *.conf进入文件，添加配置，如下： 123456789server &#123; listen 80; server_name www.zijunfe.cn; root /www/typescript-project/dist; index index.html; location ~* ^.+\.(jpg|jpeg|gif|png|ico|css|js|pdf|txt)&#123; root /www/typescript-project/dist; &#125;&#125; 保存退出。 执行命令nginx -t看看配置有没有报错，执行nginx -s reload重启nginx服务。 如果执行完以上操作后发现访问网址没有变化，可以在访问etc/nginx/nginx.conf文件，找到include /usr/share/nginx/modules/*.conf;,将它放到文件最后，然后重新启动nginx服务。 如何在服务器上下载nodejs 在服务器上找一个文件夹，比如在/新建app文件夹 1mkdir app &amp;&amp; cd app 下载对应版本的nodejs版本，我的服务器系统centos，也就是Linux 64位的，nodejs建议下载稳定版本，在app文件夹里执行命令。 1wget -c https://nodejs.org/dist/v10.14.2/node-v10.14.2-linux-x64.tar.xz 解压文件夹 1tar -xvf node-v10.14.2-linux-x64.tar.xz 为了美观，对解压后的文件夹进行改名 1mv node-v10.14.2-linux-x64 nodejs 建立node,npm软连接 12sudo ln -s /app/nodejs/bin/node /usr/local/bin/nodesudo ln -s /app/nodejs/bin/npm /usr/local/bin/npm 检查是否安装成功，执行node -v，如果有版本号，则安装成功，如果报错，看一下是不是建立软连接的时候，对应的路径有没有写正确。 未完待续]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[面试]]></title>
    <url>%2F2019%2F04%2F12%2Finterview%2F</url>
    <content type="text"><![CDATA[这两天面试了一些前端同行，面试别人同样是宝贵的经验，因为在问别人的同时，自己也会思考，这题的答案是什么，除了这种解法还有没有其他解法呢？所以这篇博文，我把自己问的问题作一个归纳与总结，并分为三个层次，基础，提升，高级，并且写一些比较冷门的前端知识。 Vue基础篇vue-rouer有几种模式，区别是什么？ 两种模式，hash模式与history模式 ，vue-router默认使用hash模式，hash模式的url格式一般为http://.../#/...,history模式则没有/#/，并且history模式需要后端配合，因为vue一般写的是单页面应用，如果后端没有正确的配置，用户直接访问http://oursite.com/user/id则回提示404错误。 vue-router路由传参有几种方法？ 通过params或query传参，前者参数不在url上显示，刷新页面会丢失参数，后者会在url上显示，刷新页面不会丢失参数。路由的动态传参，这种方式首先要在router.js中配置路由对应的path为{ path: &#39;/user/:id&#39;, component: User }这种格式，在对应得页面可以通过this.$route.params来获取对应的参数。 vue-router的导航守卫有哪些？ 前置守卫:router.beforeEach(常用)当一个导航触发时，全局前置守卫按照创建顺序调用解析守卫:router.beforeResolve(不常用)与前置守卫相识，区别在于导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。后置守卫:router.afterEach(不常用)不会接受 next 函数也不会改变导航本身：独享守卫:beforeEnter(不常用)在路由配置里定义，用来对单独的路由作处理守卫一般有三个参数 to:Route:即将要进入的目标 路由对象 from: Route:当前导航正要离开的路由 next: Function:必须调用的跳转方法，否则不会进行路由跳转 简单介绍一下vue 的生命周期函数？ beforeCreate: 初始化之前的函数，vue实例不可访问，data未定义，一个基本不怎么用的函数created: 初始化函数，data已被定义，可以访问data里的数据，可以进行绑定，判断是否有el选项，有则继续进行，没有则停止编译(生命周期停止)，直到在该vue实例上调用vm.$mount(el)。接着判断是否有template选项，如果有，则会将template作为模板编译成render函数，如果没有，则将外部HTML作为模板编译。如果同时存在，template模版优先级是高于外部HTML的。同时vue对象中还有一个render函数，以createElement作为参数，然后做渲染操作，而且我们可以直接嵌入JSX，这个优先级是最高的。综上所述，模版优先级：render函数&gt;template模版&gt;外部HTML。beforeMount: 给vue添加$el成员，并且替换挂载的DOM元素。建立虚拟dom，data还是以参数名的方式挂载在节点中，没有注入数据。mounted: 第一次对组件进行渲染，将data里的数据注入节点中,这时已经形成了真实dom。这个函数vue的整个生命周期中只会执行一次，如果还有数据的变化，只会触发updated相关函数。beforeUpdate: 检测到data发生变化，准备对相应的组件再次渲染。首先重新渲染虚拟dom，再对真实的dom打补丁。updated: 完成对data发生变化的对应组件渲染beforeDestory: 实例销毁之前调用。在这一步，实例仍然完全可用。destoryed: 在Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。帖一张官方的生命周期图 vuex的核心概念包括哪些内容。内容比较多，详情看vuex官网 state:存放状态数据的字段，辅助函数mapStategetter:可以认为是 store 的计算属性,辅助函数mapGettermutation:更改store状态的唯一方法，必须是同步操作，辅助函数mapMutationaction:action类似于mutation,不过无法直接变更状态，需要通过提交mutation来更改，可以包含任意的异步操作，辅助函数mapActionmodule:store的模块，每个模块拥有自己的state、mutation、action、getter、甚至是嵌套子模块。通过设置namespaced: true的方式使其成为带命名空间的模块，如果需要在带命名空间的模块访问全局内容，rootState 和 rootGetter 会作为第三和第四参数传入 getter，若需要在全局命名空间内分发 action 或提交 mutation，将 { root: true } 作为第三参数传给 dispatch 或 commit 即可。 JS基础篇说一些与Array相关的api，并且挑几个详细说明它们的作用？ concat: 合并两个或多个数组，不会改变原数组，返回一个新数组every: 测试数组所有元素是否通过制定函数的测试some: 测试数组是否存在元素是否通过制定函数的测试forEach: 对数组的每个元素执行一次提供的函数。reduce:对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。第一个参数为执行函数，第二个参数为执行函数第一次调用时它第一个参数的值map: 创建一个新数组，结果为该数组每个元素调用函数的结果filter: 过滤，创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。entries: 返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对。find: 返回数组中满足提供的测试函数第一个元素的值findIndex: 返回数组中满足提供的测试函数第一个元素的索引，没有返回-1flat: 按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。（IE不支持该方法）includes: 判断一个数组是否包含一个指定的值concat: 合并两个或多个数组，不会改变原数组，返回一个新数组join: 将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。如果数组只有一个项目，那么将返回该项目而不使用分隔符。splice: 通过删除或替换现有元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。三个参数，start(指定下标)，deleteCount(移除的个数),[item1,item2,…]从start位置开始插入的元素。slice: 返回一个新的数组对象，这一对象是一个由 begin和 end（不包括end）决定的原数组的浅拷贝。原始数组不会被改变。reverse: 倒序sort: 排序push,pop,shift,unshift 数组堆栈操作 js的基础类型有哪些？ String,Boolean,Number,Object,Undefined,Null,Symbol var,let,const三种声明变量的方式有什么区别？ var 声明变量有变量提升的功能 能重复声明let 声明一个具有块级作用域的变量，不具备变量提升功能，重复声明会报错const 声明一个具有块级作用域的常量，并且常用大写字母作为变量名，不具备变量提升功能，重复声明会报错，重新赋值也会报错 提升篇Object.assign()方法只会拷贝源对象自身并且可枚举的属性到目标对象，那么如何拷贝不可枚举的属性和继承属性呢？首先说一下如何拷贝不可枚举的属性。何为不可枚举属性，其实对象里每一个键值对都有6个配置选项。比如obj = {a:1}这样的数据结构，他是与123456789Object.defineProperty(obj,'a',&#123; configurable:true, // 该属性的描述符是否能被改变 enumerable:true, // 该属性是否可枚举 value: 1 // 数据描述符 该属性对应的值 writeable: true // 数据描述符 value是否能被赋值运算符改变 // 数据描述符与存取描述符不可同时存在 // get:function()&#123;return aValue&#125;, // 一个给属性提供getter的方法，当访问该属性时，该方法会被执行 // set:function(newValue)&#123;aValue = newValue&#125; // 一个给属性提供setter的方法，当值修改时，触发执行该方法&#125;) 当设置了属性的enumerable为false时，这条属性就是不可枚举属性，即无法通过for..in..与Object.keys()获取到首先你得通过Object.getOwnPropertyNames(obj)(能获取到不可枚举的属性的键名，但是获取不到以Symbol作为键名的属性)或者Reflect.ownKeys(obj)(获取到所有属性的键名)的方法获取到包括不可枚举属性的一个数组。然后循环这个数组，通过Object.getOwnPropertyDescriptor(obj,propkey)的方法得知每一个属性的描述符，然后筛选出enumerable:false的属性，重新通过Object.definePropertires(newObj,{&#39;propkey1&#39;:{...},&#39;propkey2&#39;:{...}})的方式放入新的obj里，其他可枚举的属性通过Object.assign({},obj1,...,objn)的方式放入就好了。至于继承属性的问题，可以通过Object.getPrototypeOf(obj)的方式获取指定对象的原型，然后设置新数组的__proto__为这个原型。问题就解决了。当然有一种更好的方法。配合使用Object.create()可用达到同样的目的12let newObj = Object.create(Object.getPrototypeOf(obj),Object.getOwnPropertyDescriptors(obj))let target = Object.assign(&#123;&#125;,newObj,newObj1,...,newObjN) CSS基础篇display:none与visibility:hidden与opacity:0(兼容写法filter：alpha(opacity=0))的区别? 他们都能让元素消失不见。display:none会让元素从渲染树中消失，渲染时不占任何空间，从而达到消失的目的。visibility:hidden与opacity:0只是让元素不可见，元素不会从渲染树消失不见，继续占据空间。display:none是非继承属性，元素直接消失了，修改子孙节点属性无法显示。visibility:hidden是继承属性，通过修改子孙属性visibility:visible可以让子孙节点显示。opacity:0，消失的原理是将元素的透明度设置为0，是继承属性，子孙节点通过设置opacity:1无法显示，可以继续触发元素上绑定的事件。修改元素的display通常会造成文档的回流，修改visibility与opacity属性只会造成本元素的重绘。 技巧基础篇对手机号做加密处理，将中间四位数字用*代替 replace方法 1phone.replace(/(?&lt;=.&#123;3&#125;).(?=.&#123;4&#125;)/g,'*') substring方法,或substr方法 123phone.substring(0,3)+'****'+phone.substring(6,4)//orphone.substr(0,3)+'****'+phone.substr(-4) 数组splice方法 1arr=phone.split();arr.splice(3,4,'****');arr.join('') 处理金钱字符串，例如‘1234567’=&gt;’1,234,567’ 正则法 1str.replace(/\B(?=(\d&#123;3&#125;)+(?!\d))/g,',') js法 12345function formarMoney(str)&#123; return str.split('').reverse().reduce((pre,next,index)=&gt;&#123; return （(index%3) ? next : (next+',')) + pre &#125;)&#125; toLocaleString 法(这个是真的牛皮) 1(23333333).toLocaleString('en-US') 介绍一下ES模块语法 使用export关键字导出一个变量或者类型 1234567891011export const someVar = 1;export type someType = &#123; foo:string&#125;export interface someInterface = &#123; foo ?:string&#125;// 在提前定义好变量或者类型后，可以这样导出export &#123;someVar,someType&#125;// 重命名变量导出export &#123;someVar as aDifferentName&#125; 使用import关键字导入一个变量或者一个类型 1234567891011import &#123;someVar,someType&#125; from './foo'// 重命名导入变量或者类型import &#123; someVar as aDifferentName &#125; from './foo';// 使用整体加载import * as foo from './foo'; // 你可以这样使用foo.someVar了// 仅导入模块import 'core-js'; //工具库// 从其他模块导入后整体导出：export * from './foo';// 从其他模块导入后，部分导出export &#123; someVar &#125; from './foo'; 使用默认导入/导出 export default 使用export defalut与export的区别: 导入使用时可以根据需要自定义导入命名,比如这样的语法import someName from &#39;someModule&#39; 导出变量，函数，类不需要提前定义，比如123export default (someVar = 123);export default function someFunction() &#123;&#125;export default class someClass &#123;&#125; 重写类型的动态查找 在项目里可以通过declare module &#39;somePath&#39;来声明一个全局模块的方式，用来解决查找模块路径的问题全局类型声明写法 123456789// 全局类型声明写法// **暴露**declare module 'foo' &#123;// some variable declarationsexport var bar: number;&#125;// **引入**import * as foo from 'foo'; 模块导出声明写法 123456789// 模块导出声明写法declare interface funcAbcSign &#123; (s: string): string&#125;export declare let abc: funcAbcSign;export declare function fn();// 引入import &#123;funcAbcSign,abc&#125; from 'foo'; 全局类型声明里的名称将被引入整个 TypeScript 全局命名空间中，从引用这个 声明文件起就可以自由使用。模块导出声明里的名称必须通过 import/require 才能使用。 提升篇介绍一下你了解的排序方式冒泡排序 冒泡排序是一种非常简单的排序方式，这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。排序基本思想为循环序列内每一个元素，循环到的元素与相邻的元素作对比，每次循环会将最小或者最大值冒泡至最底部，直到整个循环结束。 123456789for(let i=0,l=arr.length;i&lt;l;i++)&#123; for(let j=0;j&lt;l-1-i;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; let tmp = arr[j+1]; arr[j+1] = arr[j]; arr[j] = tmp; &#125; &#125;&#125; 改进冒泡排序: 设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。改进后如下 12345678910111213let i = arr.length-1;while(i &gt; 0)&#123; var pos = 0; for(let j=0;j&lt;i;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; pos = j; var tmp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = tmp; &#125; &#125; i = pos;&#125; 选择排序 选择排序是一种简单直观的排序算法，它的原理是:首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 123456789101112let tmp,minIndex; for(let i=0,l=arr.length;i&lt;l-1;i++)&#123; minIndex = i; for(let j=i+1;j&lt;l;j++)&#123; if(arr[j]&lt;arr[minIndex])&#123; minIndex = j; &#125; &#125; tmp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = tmp; &#125; 插入排序 插入排序的远离应该是最容易理解的了，就像打扑克牌，摸到牌以后，你需要对牌进行从小到大的排序，如果你打扑克从不排序，那当我没说…它的工作原理是，构造一个有序序列，然后拿未排序的数据在已排序序列中从后向前扫描，找到相应位置插入。 123456789for(let i=1,l=arr.length;i&lt;l;i++)&#123; let key = arr[i]; var j = i-1; while(j&gt;=0 &amp;&amp; arr[j]&gt;key)&#123; arr[j+1] = arr[j]; j--; &#125; arr[j+1]=key;&#125; 未完待续…]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何给自己的博客添加评论系统]]></title>
    <url>%2F2019%2F04%2F11%2Fblog-comments%2F</url>
    <content type="text"><![CDATA[想要做一个骚气的博主，没有一个评论系统怎么行呢 打开我的Google复制一下别人的，呸，打开我的Google搜索一下前辈们的经验。首先，我了解到的是next官网推荐的几种评论插件，分别是以下这几个哥们DISQUS Facebook Comments HyperComments 网易云跟帖 来必力 从名字上来说，我选择最后一个试一下(绝对不是我看不懂别人官网，绝对不是!) 来必力来必力(这特喵的居然是个韩文网站) 这款评论系统比较简单，首先要去人家官网注册一个账号，登陆以后根据提示申请一个免费的city版什么鬼的，然后在代码里能得到一串LiveRe UID，在next 的_config.yml文件里编辑livere_uid字段，就完成啦，系不系很简单？效果如下然后我觉得太丑了，不符合next的黑白简约主题，而且很大概率进入页面后需要重新刷新才能显示出来，所以我就放弃了。 Gitment接下来我又在茫茫Google中搜索，然后找到了它，看介绍说是通过github提issue的方式来创建一个评论系统，看到github我嘴角疯狂上扬，符合我的气质，这个我看行，开搞！ 首先在https://github.com/settings/developers申请一个免费的application，根据提示填写如下内容， 1234Application name：blog-comments // 随便写啥，你能记住就好 Homepage URL：https://网站地址/ // 你的博客地址Application description：Blog comment system // 随便写Authorization callback URL：https://网站地址/ // 你的博客地址 创建完成后先不要关闭，client_id与client_secret下面要用 接着在你的github新建一个空的仓库来存放评论，比如叫做blog-comments 然后在主题配置文件_config.yml里填写gitment的相关配置12345678910111213gitment: enable: true // 这个改成true mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: false # Hide &apos;Powered by ...&apos; on footer, and more language: zh-Hans # Force language, or auto switch by theme github_user: BiYangJun # MUST HAVE, Your Github ID github_repo: blog-comments # MUST HAVE, The repo you use to store Gitment comments 这是你新建的存放评论的库 client_id: # MUST HAVE, Github client id for the Gitment 刚刚创建application里有的 client_secret: # EITHER this or proxy_gateway, Github access secret token for the Gitment 刚刚创建application里有的 proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled 全部配置完后，一切看起来很顺利，页面底部也出来了评论框，就差最后一步登陆自己的github来初始化了，一开始本地登陆不了，我以为是要部署后才能登陆，然后我部署了上去，心里想着这下成了! 部署后，我点击登陆后，一直给我报错[object ProgressEvent]，试了很多次，我还一度怀疑是不是我github密码输错了，纳闷的我去看了一下gitment的issue，最后发现原因大概是gitment的网站证书到期了，gitment需要这个为接口，所以一直报错。辛辛苦苦1小时，我… 哎，接着在茫茫Google找吧… Gitalk接着，在茫茫博客中，我发现了戳兔专家这位大哥的博文，跟着他的教程开始了安装Gitalk,帖个官网。 首先刚刚申请的application和新建存放评论的仓库不要丢，裹上鸡蛋液，放在油锅里炸一炸，隔壁小孩…住嘴！由于next还没有集成gitalk，所以配置起来相当繁琐 首先还是要在github上申请一个application和新建一个存放评论的仓库(上面的就可以用) 在 /layout/_third-party/comments/ 目录下新建 gitalk.swig 文件，内容如下： 12345678910111213141516&#123;% if page.comments &amp;&amp; theme.gitalk.enable %&#125; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/gitalk/dist/gitalk.css&quot;&gt; &lt;script src=&quot;https://unpkg.com/gitalk/dist/gitalk.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var gitalk = new Gitalk(&#123; clientID: &apos;&#123;&#123; theme.gitalk.ClientID &#125;&#125;&apos;, clientSecret: &apos;&#123;&#123; theme.gitalk.ClientSecret &#125;&#125;&apos;, repo: &apos;&#123;&#123; theme.gitalk.repo &#125;&#125;&apos;, owner: &apos;&#123;&#123; theme.gitalk.owner &#125;&#125;&apos;, admin: [&apos;&#123;&#123; theme.gitalk.adminUser &#125;&#125;&apos;], id: location.pathname, distractionFreeMode: &apos;&#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;&apos; &#125;) gitalk.render(&apos;gitalk-container&apos;) &lt;/script&gt;&#123;% endif %&#125; 修改 /layout/_partials/comments.swig，在最后一个 elseif 后添加字段，修改后如下： 1234567891011121314151617181920 &#123;% elseif theme.gitment.enable %&#125; &lt;div class=&quot;comments&quot; id=&quot;comments&quot;&gt; &#123;% if theme.gitment.lazy %&#125; &lt;div onclick=&quot;showGitment()&quot; id=&quot;gitment-display-button&quot;&gt;&#123;&#123; __(&apos;gitmentbutton&apos;) &#125;&#125;&lt;/div&gt; &lt;div id=&quot;gitment-container&quot; style=&quot;display:none&quot;&gt;&lt;/div&gt; &#123;% else %&#125; &lt;div id=&quot;gitment-container&quot;&gt;&lt;/div&gt; &#123;% endif %&#125; &lt;/div&gt; &#123;% elseif theme.valine.appid and theme.valine.appkey %&#125; &lt;div class=&quot;comments&quot; id=&quot;comments&quot;&gt; &lt;/div&gt; &#123;% elseif theme.gitalk.enable %&#125; &lt;div id=&quot;gitalk-container&quot;&gt;&lt;/div&gt; &#123;% endif %&#125;&#123;% endif %&#125; 修改 /layout/_third-party/comments/index.swig，在其末尾添加如下字段： 1&#123;% include &apos;gitalk.swig&apos; %&#125; 设置 gitalk 的样式，参考1： 在 /source/css/_common/components/third-party/ 目录下新建 gitalk.styl 文件，内容如下： 1234.gt-header a, .gt-comments a, .gt-popup a border-bottom: none;.gt-container .gt-popup .gt-action.is--active:before top: 0.7em; 修改 /source/css/_common/components/third-party/third-party.styl 文件，在末尾添加如下字段： 1@import &quot;gitalk&quot;; 最后在主题配置文件 _config.yml 中添加如下项： 12345678gitalk: enable: true owner: 你的github帐号 # lzcwr repo: 存放评论的仓库名称 # Gitalk-comments ClientID: 在申请好application的页面中有 ClientSecret: 在申请好application的页面中有 adminUser: 你的github帐号 # 可初始化评论的账户 distractionFreeMode: true 完整无误地完成上述步骤后，在本地可以看到gitalk的按钮，然后通过hexo d部署到线上后，登陆你的github进行初始化就大功告成了啦！ 如果你给一篇博文的文件命名有中文的话，你可能会碰到这个报错Error: Validation Failed。哎，真是一波三折啊 Error: Validation Failed 解决方案 修改前文提到的gitalk.swig，先下载一个md5.js,更改完毕后的gitalk.swig如下： 1234567891011121314151617&#123;% if page.comments &amp;&amp; theme.gitalk.enable %&#125; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/gitalk/dist/gitalk.css&quot;&gt; &lt;script src=&quot;/js/md5.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/gitalk/dist/gitalk.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var gitalk = new Gitalk(&#123; clientID: &apos;&#123;&#123; theme.gitalk.ClientID &#125;&#125;&apos;, clientSecret: &apos;&#123;&#123; theme.gitalk.ClientSecret &#125;&#125;&apos;, repo: &apos;&#123;&#123; theme.gitalk.repo &#125;&#125;&apos;, owner: &apos;&#123;&#123; theme.gitalk.owner &#125;&#125;&apos;, admin: [&apos;&#123;&#123; theme.gitalk.adminUser &#125;&#125;&apos;], id: md5(location.pathname), distractionFreeMode: &apos;&#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;&apos; &#125;) gitalk.render(&apos;gitalk-container&apos;) &lt;/script&gt;&#123;% endif %&#125; 批量修改博客文件名，例如以时间戳的方式命名md文件，具体可以参考这位大哥的博文 避免使用中文命名，英文不好咱们就用拼音吧！ 忙活了一晚上我的评论系统终于搞定了… 感谢万能的Google和戳兔专家这位大哥。看完的小伙伴记得评论、关注、收藏三连哦～呸、什么坏毛病能给评论就感激不尽啦～]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[记录一下搭建第一个博客的经历]]></title>
    <url>%2F2019%2F04%2F10%2Ffirst-blog%2F</url>
    <content type="text"><![CDATA[起因，在论坛闲逛的时候发现一个老哥把很多知识点，问题都记录在自己的个人博客里，知识罗列的很清楚。虽然我平时也会把一些问题和有趣的东西记录在MacDown里，可时如果要看的话还需要打开mac，很不方便。so～在网上找了一篇搭建博客的教程，干了一晚上终于成了，中间碰到很多曲折的问题，所以在这里记录一下。 一、搭建条件及环境 Github Pages + Hexo + Node.js Mac电脑的OSX系统/windows二、搭建步骤 首先你得有个github账号(作为新时代的码农，这是必备的)，创建一个新的repository，项目名称格式为yourname.github.io，如图 全局安装Hexo，npm install -g hexo-cli 创建一个空文件夹，进入该文件夹，依次执行以下命令 123hexo initnpm installnpm install hexo-deployer-git --save 在所有依赖都安装完成后，就可以在本地环境看一下hexo的博客内容啦，执行以下命令 12hexo generate hexo server 这两条命令可以缩写成hexo g hexo s作用分别是：将md文件生成html，css文件；启动本地hexo。打开http://localhost:4000就能看到本地效果啦。 修改 _config.yml 文件，这是博客网站 的配置文件，在这里你可以更改你的网页title，description等，最主要的是修改你在github上的仓库地址。 在最下面一行 1234deploy: type: git repository: git@github.com:BiYangJun/zijun.github.io.git branch: master 写上自己的仓库地址。至于是SSH公钥方式提交还是https方式提交，看个人喜好啦。 在写完自己的博客后，执行以下命令 12hexo generatehexo deploy hexo deploy 可以缩写成 hexo d意思为部署 接着你会上传文件到github上。接着就可以在线访问啦。 那么如何在线访问呢？ 打开你的github。点击environment， 然后在点击 View deployment,打开后的网址就是你的线上博客地址辣，easy～ 三、遇到的坑 如果发现线上博客一直是404，看一下repository中的setting，在GitHub Pages 这一栏中Source有没有选中master分支 能打开线上博客后，如果发现样式没有加载出来，在_config.yml修改root为自己的项目名称 其他hexo命令。hexo clean#缓存，在网页不正常的时候可以使用。hexo new ‘我的博客’#新建我的博客，hexo server -p 5000#更改端口 如何插入图片。 在主题的source下面新建一个文件夹images专门放置图片资源，使用markdown的语法 ![](/images/test.jpg) Hexo方式，设置_config.yml文件中post_asset_folder为true，之后新建一个文章后，会同时创建一个同名的空文件夹用来放图片资源，执行命令npm install hexo-asset-image --save，下载安装一个可以上传本地图片的插件，之后使用的时候，只需要图片名![](test.jpg) 网络图片插入‘#’ Hexo 支持使用特定的语法，插入指定大小的图片，如下： 123456// 语法&#123;% img [class names] /path/to/image [width] [height] [title text [alt text]] %&#125;// 实例&#123;% img full-image /hexo-experiences/PL01.jpg 180 180 hello %&#125;// 生成的代码&lt;img src=&quot;/blog/hexo-experiences/PL01.jpg&quot; class=&quot;full-image&quot; width=&quot;180&quot; height=&quot;180&quot; title=&quot;hello&quot;&gt; 如果发现怎么都不行，看下你这个博客是不是在二级域名下的，如果是，要设置_config.yml文件中的url与root。]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
</search>
