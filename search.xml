<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[秀米集成到UEditor的配置过程]]></title>
    <url>%2F2019%2F10%2F22%2Fxiumi%2F</url>
    <content type="text"><![CDATA[秀米集成到UEditor的配置过程虽然秀米官方有提供文档说明如何将秀米插件集成至UEditor里(秀米官方文档)，但是该文档说明模糊不清，关键配置一句话带过，即使配置成功后还有坑留在里面。所以我重新整理了这个配置过程，回顾一下过程的同时也给以后需要用到的小伙伴提供便利。 一、将秀米图标集成至工具栏，并且成功弹出秀米弹框 首先我们需要一个秀米的html文件，这个html里主要就是弹框里的内容，里面有一个iframe指向秀米的网址。取名xiumi-ue-dialog-v5.html,放入ueditor1_4_3_3文件夹(UE的资源文件夹)下或者ueditor1_4_3_3下的dialogs文件夹里，这个只是涉及到后面引入它的路径，不是很重要，我是放在ueditor1_4_3_3文件夹下的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!-- ueditor1\_4\_3\_3/xiumi-ue-dialog-v5.html --&gt;&lt;!DOCTYPE html&gt;&lt;!-- saved from url=(0049)http://hgs.xiumi.us/uedit/xiumi-ue-dialog-v5.html --&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;XIUMI connect&lt;/title&gt; &lt;style&gt; html, body &#123; padding: 0; margin: 0; &#125; #xiumi &#123; position: absolute; width: 100%; height: 100%; border: none; box-sizing: border-box; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body style=""&gt;&lt;iframe id="xiumi" src="//xiumi.us/studio/v5#/paper"&gt;&lt;/iframe&gt;&lt;script type="text/javascript" src="./dialogs/internal.js"&gt;&lt;/script&gt;&lt;script&gt; var xiumi = document.getElementById('xiumi'); var xiumi_url = window.location.protocol + "//xiumi.us"; xiumi.onload = function () &#123; xiumi.contentWindow.postMessage('ready', xiumi_url); &#125;; document.addEventListener("mousewheel", function (event) &#123; event.preventDefault(); event.stopPropagation(); &#125;); window.addEventListener('message', function (event) &#123; if (event.origin == xiumi_url) &#123; editor.execCommand('insertHtml', event.data); // 这个方法用于触发UE的图片转存接口 editor.fireEvent('afterpaste'); dialog.close(); &#125; &#125;, false);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 秀米的文档里使用的是UE.registerUI(‘dialog’，fn）的方式动态在UE里添加一个秀米按钮并且在按钮里添加弹出弹框事件，但是这么做可能会影响到系统其他使用UE里的地方同样出现秀米图标，无法按需加载。所以我将此改进成在UE的前端配置中的toolbars数组里添加一个”xiumi”字符串即可展示出秀米的方式。步骤如下： 添加一个秀米的图标并添加样式。在ueditor1_4_3_3/themes/default/images文件夹里放入一个秀米图标; 在ueditor1_4_3_3/themes/default/css/ueditor.css 添加俩句样式 1234567891011/* xiumi-dialog */.edui-default .edui-for-xiumi .edui-dialog-content &#123; width: calc(100vw - 60px) !important; height: 90vh !important; overflow: hidden;&#125;.edui-default .edui-for-xiumi .edui-icon &#123; background-image: url("../images/xiumi-connect-icon.png") !important; background-size: contain;&#125; 在ueditor.all.js修改代码。在iframeUrlMap对象里添加键值对’xiumi’: ‘~/xiumi-ue-dialog-v5.html’，这个和刚刚那个html存放的地方有关。在btnCmds数组里添加一个’xiumi’字符串，在dialogBtns对象中的ok数组里添加’xiumi’字符串。 最后在UE的前端配置里toolbars数组里添加’xiumi’,即可成功展示出秀米图标与秀米的弹框。 效果如下 在ueditor.config.js的xss过滤白名单whitList配置里，修改section参数。同时将设置是否抓取远程图片catchRemoteImageEnable设置为true。 1section:['class', 'style'], 能成功弹出秀米的弹框，并且能将秀米里的模版成功勾选到本地的UE编辑器里，说明集成就成功了一半啦。 二、秀米域名的图片转存。要完成秀米图片的转存，首先我们要先完成UE对复制过来的网络图片的转存，图片的转存分为img标签与背景图片的抓取与转存。 设置抓取白名单catcherLocalDomain，在白名单里的地址，UE不会对其发起转存请求。可以使用两种方式设置： 使用UE.utils.extend方法强制在UE实例化后设置 123UE.utils.extend(editor.options, &#123; catcherLocalDomain: ['127.0.0.1', 'localhost', "static-alpha-engage.gridsumdissector.com", "static-beta-engage.gridsumdissector.com", "static-uat-engage.gridsumdissector.com", "static.engage-all.com"], &#125;); 修改ueditor.all.js里的初始配置代码，在这个js文件大概第8100行的地方，有一个loadServerConfig的函数，可以直接在这里将catcherLocalDomain的初始值设置为我们想要过滤的白名单域名。 修改抓取图片的后端请求地址。UE发起所有接口请求都依赖于一个名为serverUrl的前端配置，然后通过使用serverUrl这个唯一的请求地址，通过GET参数action指定不同请求类型，比如uploadimage(执行上传图片或截图的action名称), uploadvideo(执行上传视频的action名称), catchimage(执行抓取远程图片的action名称)等等，但是后端为了方便接口的管理，一般会将接口拆分出来，当然UE也支持自定义请求地址。UE推荐的方法如下： 12345678910UE.Editor.prototype._bkGetActionUrl = UE.Editor.prototype.getActionUrl;UE.Editor.prototype.getActionUrl = function(action) &#123; if (action == 'uploadimage' || action == 'uploadscrawl' || action == 'uploadimage') &#123; return 'http://a.b.com/upload.php'; &#125; else if (action == 'uploadvideo') &#123; return 'http://a.b.com/video.php'; &#125; else &#123; return this._bkGetActionUrl.call(this, action); &#125;&#125; 原理就是使用一个名为_bkGetActionUrl的临时变量承载原来的getActionUrl方法，然后重写getActionUrl方法，判断action的类型，来返回不同的接口，同时也还可以执行原来的getActionUrl方法。但是我在使用这种方法的时候，会偶尔碰到内存溢出，导致上传图片功能不可用的原因，可能是getActionUrl在其他地方也被重新赋值了，产生循环引用该函数的问题。所以我依旧在ueditor.all.js里修改了getActionUrl原始函数，大概在第8040行代码里，判断getActionUrl函数内部一个actionName的参数，来返回你想要的接口名。 到这里差不多能够抓取到img标签的src并且可以将其替换了，但需要注意俩点地方： 注意抓取后，后端返回的数据格式时候和UE里源码设置的一样，在ueditor.all.js找到UE.plugins[‘catchremoteimage’]这个函数，在其内部执行catchremoteimage的success回掉函数的地方注意获取源路径和新路径的数据路径的地方。 UE内部有一个判断是否跨域的方法，如果跨域会使用jsonp的方式请求接口，如果你是本地调试，并且后端已经对跨域crose处理，不需要使用jsonp的方式请求，你可以把它关了。同样在UE.plugins[‘catchremoteimage’]这个函数里，找到定义catchremoteimage函数的地方，将其内部ajax请求的option里，将dataType固定设置为空字符串即可。 除了img标签的src替换，背景图片也是需要进行图片抓取和替换的。其实就是依葫芦画瓢，看明白了UE是如何对img标签进行src替换的，也就明白该如何对背景图片进行替换了。 首先你需要在ueditor.all.js文件的domUtils参数里新添一个方法getElementsByTagNameStyle。通过元素的style来获取元素节点数组。 1234567891011121314151617181920212223/** * 方法getElementsByTagNameStyle的封装 * @method getElementsByTagNameStyle * @param &#123; e &#125; node 目标节点对象 * @param &#123; t &#125; tagName 需要查找的节点的tagName， 多个tagName以空格分割 * @param &#123; i &#125; style 节点对象的筛选条件 * @return &#123; Array &#125; 符合条件的节点集合 */ getElementsByTagNameStyle: function (e, t, i) &#123; if (i &amp;&amp; utils.isString(i)) &#123; var n = i; i = function (e) &#123; for (var t, i = n.split(","), o = !0, r = e.getAttribute("style"), a = 0; t = i[a++];) if (!r || r.indexOf(t) &lt; 0) &#123; o = !1; break &#125; return o &#125; &#125; t = utils.trim(t).replace(/[ ]&#123;2,&#125;/g, " ").split(" "); for (var o, r = [], a = 0; o = t[a++];) for (var s, l = e.getElementsByTagName(o), d = 0; s = l[d++];) i &amp;&amp; !i(s) || r.push(s); return r &#125;, 在UE.plugins[‘catchremoteimage’]下的catchRemoteImage监听函数里添加代码。首先你得的到有背景图片的的元素节点数组。使用刚刚新添的方法 1backgroundimagestags = domUtils.getElementsByTagNameStyle(me.document, "section div p", "background,url")//抓取背景图片所在的标签 然后将该元素节点数组里的图片地址都抽取出来，放在一个存放图片地址的数组里 12345678910111213141516var backgroundimages = [];for (var i = 0, backci; backci = backgroundimagestags[i++];) &#123; var bstyle = backci.style; var backgroundimgurltag = bstyle['background-image'] || bstyle['background'] || ""; if (backgroundimgurltag != null &amp;&amp; backgroundimgurltag != "") &#123; var backsrc = backgroundimgurltag.split("(")[1].split(")")[0].replace(/\"/g, "") || backgroundimgurltag.split("(")[1].split(")")[0].replace(/\"/g, "") || ""; if (backsrc != null &amp;&amp; backsrc != "") &#123; if (/^(https?|ftp):/i.test(backsrc) &amp;&amp; !test(backsrc, catcherLocalDomain)) &#123; backgroundimages.push(encodeURI(backsrc)); &#125; &#125; &#125;&#125; 最后依葫芦画瓢，对该图片地址数组循环，依次发起转存请求，并且将对应的节点内的背景图片url进行替换。 123456789101112131415161718192021222324252627282930313233343536373839404142if(backgroundimages.length) &#123; catchremoteimage(backgroundimages, &#123; //成功抓取 success: function (r) &#123; try &#123; var info = r.state !== undefined ? r:eval("(" + r.responseText + ")"); &#125; catch (e) &#123; return; &#125; /* 获取源路径和新路径 */ var i, j, ci, cj, oldSrc, newSrc, styleText ,list = info.data.list; for (i = 0; ci = backgroundimagestags[i++];) &#123; styleText = ci.getAttribute("style"); oldSrc = styleText; if (oldSrc.indexOf('url("') &gt; 0) &#123; oldSrc = oldSrc.split('url("')[1].split('")')[0]; &#125; else if (oldSrc.indexOf("url('") &gt; 0) &#123; oldSrc = oldSrc.split("url('")[1].split("')")[0]; &#125; else &#123; if (!(oldSrc.indexOf("url(") &gt; 0)) continue; oldSrc = oldSrc.split("url(")[1].split(")")[0]; &#125; if (oldSrc.indexOf("?") &gt;= 0) &#123; oldSrc = oldSrc.split("?")[0]; &#125; for (j = 0; cj = list[j++];) &#123; if (oldSrc == cj.source &amp;&amp; "SUCCESS" == cj.state) &#123; newSrc = catcherUrlPrefix + cj.url, styleText = styleText.replace(oldSrc, newSrc), domUtils.setAttributes(ci, &#123; style: styleText &#125;), domUtils.setAttributes(ci, &#123; is_updata: "true" &#125;); break &#125; &#125; &#125; me.fireEvent('catchremotesuccess') &#125;, //回调失败，本次请求超时 error: function () &#123; me.fireEvent("catchremoteerror"); &#125; &#125;); &#125; 到这里，UE对普通的img标签及背景图片的抓取与转存已经成功了，如果想要对秀米过来的图片进行转存需要注意以下俩点： 对某些秀米图片地址的后缀进行处理，去掉?号之后类似?x-oss-process=所有的部分。这个在catchremoteimage函数里对imgs进行一步map循环，将？后面的东西去掉即可，同时注意在图片地址数组循环的过程中oldSrc？后面的内容也要去掉，否则oldSrc == cj.source &amp;&amp; “SUCCESS” == cj.state这一步判断不会通过，就无法进行图片地址的替换了。 从秀米回到本地UE编辑器的时候不会触发图片转存请求，这也是秀米文档埋下的一个坑！解决这个问题，你需要在xiumi-ue-dialog-v5.html文件里，在dialog.close();代码前添加一句editor.fireEvent(&#39;afterpaste&#39;);来主动触发afterpaste这个监听函数。 大功告成]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[原型链的理解]]></title>
    <url>%2F2019%2F05%2F11%2Fprototype%2F</url>
    <content type="text"><![CDATA[123456[].__proto__ === Array.prototypeArray.__proto__ === Function.prototypeArray.prototype.__proto__ === Object.prototypeFunction.__proto__ === Function.prototype // Function.prototype 是个方法，是通过继承Object.prototype而产生的,Function.__proto__.__proto__ === Object.prototype // Object.prototype 原型链顶端，是对象，但它不是通过Object函数创建的。是浏览器引擎按照ECMAScript规范创造的一个对象Object.prototype.__proto__ === null]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue如何与TypeScript搭配使用]]></title>
    <url>%2F2019%2F05%2F07%2Fvue-ts%2F</url>
    <content type="text"><![CDATA[最近真的陷入了TypeScript无法自拔，我甚至有一种感觉ts可能会成为前端必须要掌握的一项技术(就像现在前端从业者必须得掌握三大框架之一一样)。 但现在使用vue+TypeScript来开发项目的其实还是比较少的，Vue的作者尤雨溪在知乎上回答过这么一个问题TypeScript 不适合在 vue 业务开发中使用吗？,根据他本人的回答，现在的vue2.x版本对TS的支持是远不如React和Angular的，所以在即将发布的vue3.0要加强这一块。 但是因为vue-class-component与vue-property-decorator(前者的升级版本，加入了Vue，Watch，Emit等功能)的存在，现在使用TS+vue来写项目也不是什么问题，虽然还有些稍许的bug，不过无伤大雅 在前面的博客里我介绍过如何使用TypeScript如何搭建store文件夹，所以这篇博文主要做一个用JS与TS编写vue文件的区别。(引入的是vue-property-decorator，全部介绍完基本上是不可能的，这里结束的是平时用的多的) #data,computed,methodsJS写法123456789101112131415161718192021222324252627export default &#123; name:'HelloWorld', data()&#123; return &#123; bar:'hello', foo:1 &#125; &#125;, computed:&#123; comBar()&#123; return this.bar+'world' &#125; comFoo:&#123; get:function()&#123; return this.foo+1 &#125; set:function(newVal)&#123; console.log(newVal) &#125; &#125; &#125;, methods:&#123; handleFn()&#123; // ...do something &#125; &#125;&#125; TS写法12345678910111213141516171819import &#123;Component,Vue&#125; from 'vue-property-decorator';@Component(&#123; name:'HelloWorld'&#125;)export default class HelloWorld extends Vue &#123; bar:string = 'hello'; foo:number = 1; get comBar():string&#123; return this.bar + 'world' &#125; set comBar(val:string)&#123; // 注意，这里不能标返回值类型，就算写void也不行 console.log(val) &#125; handleFn():voids&#123; //...do something &#125;&#125; @Component({options}) 中接受的options就是传统的配置，mixin,自定义指令,子组件的注册都要在这里声明 #watchJS写法1234567891011export default &#123; watch:&#123; 'foo':&#123; handler:function(newVal,oldVal)&#123; console.log(newVal,oldVal) &#125;, deep:true, // 开启深度监听 immediate:true // 该回调(handler函数)将会在侦听开始之后被立即调用 &#125; &#125;&#125; TS写法12345678import &#123;Vue,Watch,Component&#125; from 'vue-property-decorator'export default class HelloWorld extends Vue &#123; @Watch('foo',&#123;deep:true,immediate:true&#125;) onWatchFoo(newVal:string,oldVal:string)&#123; // 监听的方法名是可以自定义的 // do something... &#125;&#125; #props #directivesJS写法1234567891011121314151617181920212223242526272829303132333435363738394041export default &#123; name:'childComponent', props:&#123; bar:Boolean, foo:&#123; type:String, defalut:'abc' &#125;, obj:&#123; type:Object, default:function()&#123; return &#123; a:1 &#125; &#125;, required:true // 定义该prop是否是必填项 validator:function(value)&#123; // 自定义验证函数 return出来一个boolean值 return Object.keys(values).includes('a') &#125; &#125; &#125;, directives:&#123; focus:&#123; inserted:function(el,binding,vnode,oldVnode)&#123; // el:指令所绑定的元素，可以用来直接操作DOM el.focus(); // binding:一个对象，包括以下属性 // name: 指令名--focus // value： 指令的绑定值，例如v-my-directives="1+1"中，value的值为2 // oldValue：指令绑定的前一个值。仅在update和componentUpdated钩子中可用。无论值是否改变都可用 // expression：字符串形式的指令表达式。例如v-my-directives="1+1"中，表达式为‘1+1’ // arg：传给指令的参数，例如 v-my-directives:foo='...'中,参数为‘foo’ // modifiers：一个包含修饰符的对象。例如：v-my-directives.stop.prevent中，修饰符对象为&#123;stop:true,prevent:true&#125; let &#123;name,value,oldValue,expression,arg,modifiers&#125; = binding; // vnode: Vue 编译生成的虚拟节点 // oldVnode：上一个虚拟节点，仅在update和componentUpdated钩子中使用 &#125; &#125; &#125;&#125; TS写法123456789101112131415161718192021222324252627282930313233343536373839404142import &#123;Vue,Component,Prop&#125; from 'vue-property-decorator';// 第一种你可以在在@Component里@Component(&#123; props:&#123; bar:&#123; type:Boolean, default:false &#125; &#125;, directives:&#123; focus:&#123; inserted:function(el,binding,vnode,oldvnode)&#123; el.focus() &#125; &#125; &#125;&#125;)// 第二种使用@Prop的方式interface ObjProp &#123; a:number&#125;@Component()export default class HelloWorld extends Vue &#123; @Prop(&#123;default:false&#125;) bar!:boolean //!: 表示强制解析，告诉ts我这里一定有值 如果没有写！，虽然不会报错但是代码会有红线提示 @Prop( &#123; default:function()&#123; return &#123;msg:'haha3'&#125; &#125;, required:true, validator:function(value)&#123; return Object.keys(value).includes('a') &#125; &#125; ) obj!:ObjProp // 好像直接写一个&#123;&#125;作为默认值也没问题 obj!:&#123; a:number &#125;&#125; @Model 前提条件，在父组件中，对子组件使用了v-mode=&quot;checked&quot; 父组件1&lt;checkbox v-mode="checked" &gt;&lt;/checkbox&gt; 子组件1&lt;input type="checkbox" :checked="checked" @change="change"/&gt; JS写法12345678910111213141516// 子组件中export defalut &#123; // model 参数为2.2.0新增，允许一个自定义组件在使用v-model时定制prop和event model:&#123; prop:"checked", event:"change" &#125;, props:&#123; checked:Boolean &#125;, methods:&#123; change:function(e)&#123; this.$emit('change',e.target.checked) &#125; &#125;&#125; TS写法12345678import &#123;Vue,Component,Model,Emit&#125; from "vue-property-decorator";@Component()export default class HelloWorld extends Vue &#123; @Model('checked',&#123;type:Boolean&#125;) checked!:boolean, @Emit('change') change(e:MouseEvent)&#125; @Emit父组件1&lt;add-component @on-add="addFunction"&gt;&lt;/add-component&gt; 有一个可以做加减法的子组件,如下12345&lt;div&gt; &lt;button @click="onSub"&gt;-&lt;/button&gt; &lt;input tepe="test" v-model="count"/&gt; &lt;button @click="onAdd"&gt;+&lt;/button&gt;&lt;/div&gt; JS写法 12345678910111213141516export default &#123; data()&#123; return &#123; count:0 &#125; &#125;, name:'addcomponent', methods:&#123; onSub()&#123; this.$emit('on-sub',this.count) &#125;, onAdd()&#123; this.$emit('on-add',this.count) &#125; &#125;&#125; TS写法123456789101112131415161718import &#123;Vue,Component,Emit&#125; from 'vue-property-decorator';@Component(&#123; name:'addcomponent'&#125;)export default class AddComponent extends Vue &#123; count:numer = 0; @Emit() // 如果父组件传过来的方法是 on-add 那么，@Emit里可以省略方法名 onAdd()&#123; this.count += 1; return this.count // 通过return的方式，在父组件的方法中才能在event中拿到值 &#125; @Emit('otherFnName') onSub()&#123; this.count -=1; return this.count &#125;&#125; @Provide @Inject通常provide与inject是配合使用的，一般使用在插件与组件库中，在父组件中通过provide提供一些数据，他的所有子组件，都能都通过inject注入到自己的组件中，并且通过this来调用。 provide：Object | () =&gt; Objectinject：Array&lt;string&gt; | { [key: string]: string | Symbol | Object } JS用法1234567891011121314151617181920212223// 父组件export default &#123; name:"father-component", provide:&#123; bar:1, foo:2 &#125;&#125;...// 任意子组件export default &#123; inject:['bar','foo'] // 如果需要定义默认值 inject:&#123; bar:&#123; default:'heihei' &#125;, foo1:&#123; form:'foo', // 声明从不同名字的属性注入 defalut:'haha' // 非原始属性，已工厂方法返回 ()=&gt;[1,2,3] &#125; &#125;&#125; TS用法123456789101112131415// 父组件import &#123;Vue,Component,Provide&#125; from 'vue-property-decorator';@Componentexport default class Father extends Vue &#123; @Provide() foo = "hello vue"&#125;// 子组件import &#123;Vue,Component,Inject&#125; from 'vue-property-decorator';@Componentexport default class Child extends Vue &#123; @Inject() foo !:string&#125; 综上所写，使用TS与使用JS编写vue文件的区别就全部罗列完了 但应该还有很多遗漏的点，如果你有什么补充，欢迎在留言区评论。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[记第一次去深大]]></title>
    <url>%2F2019%2F05%2F05%2Fdiary1%2F</url>
    <content type="text"><![CDATA[期待很久的五一假期已经过完了╥﹏╥…不出意外的,大部分时间还是宅在家里玩游戏为什么不想出门呢？第一: 比较反感去人多的地方第二: 这种天气宅着真的很舒服，如何形容呢，窗外下着忽大忽小的雨，家里蓝胖子又在沙发上打盹，温度适合穿着单薄的羽织，无论是窝在被子里，还是在游戏世界里激情厮杀都很舒服，玩累了就抱着蓝胖子一顿狂撸，不得不说惬意十分了。 总是在睡觉的蓝胖子然鹅…总是在家里宅着，身上会长蘑菇吧于是，选了个不下雨的下午，起身去了深圳大学。离家里不远，2站地铁就到了，步行10分钟，就能到深大的北门。也许第一次来，也许不是深大的学生，我踏进大门后居然有点点紧张(我也不知道我紧张个锤子)因为深大就在深南大道的路边，不同于马路上呼啸而过的汽车，深大就显得很安静，让人一下就放松下来，假期的校园没有什么人，但有不少带小孩过来散步的家庭。沿着大路往下走，左拐进入了一个田径场，去观众席上坐着，看着田径场上跑步的陌生人，我陷入了自己大学生活的回忆中，记忆中我离开大学的最后一件事也是像这样，坐在观众席上，看着跑步的陌生人发呆。何曾几时，我也是校园里无忧无虑的一名学子。真怀念那段时光讷…深大北门的田径场离开了田径场，随便挑选一条路，继续往下走，深大的绿化做的真的不错，有路的地方旁边一定有树。不知名的小路1在这里上学一定很辛福吧，每条路都很适合闲暇时光的闲逛。(当年咋就不加点油，考个深大呢！)不知名的小路2然后，在乱走一通后，路过了深大的宿舍楼，在宿舍楼下发现了一只花不溜秋的小猫，和他的小食堂。小猫当时似乎在草丛里上厕所…真的非常不好意思偷拍了你…小花猫和他的食堂继续往下走还看到了一只非常漂亮的小白猫，忘记拍照了，真可惜。相比外面的小野猫，深大的猫咪似乎都不怎么怕人，猫咪们能在深大生活也是一件幸运的事吧，毕竟照顾他们的都是一群心善的年轻人。漫无目的的继续走，好像来到了深大的图书馆，从外面看建筑比较老式的了，没有进去看，偶尔有学生进出，果然每个学校都有学霸即使在假期还继续在图书馆里奋斗。汉京集团的大楼就矗立在不远处，那几个 “I love SZ”大字，从这个角度看好像显的更加年轻呢。图书馆离开了图书馆后，步行来到了一个人工湖的旁边，这里男女成双出现的概率大了许多，不得不说，每个学校的人工湖都是小情侣们的约会圣地，风景漂亮，散步在湖边的小路上说说笑笑，都是爱情的样子。比较惊讶的是，这里有很多黑天鹅。上回见到黑天鹅还是几年前去厦大的时候，难道黑天鹅和名校是标配吗？深大的湖黑天鹅在人工湖旁的凉亭坐了一会，心里想着这个季节是大学毕业生们拍摄毕业照，喝毕业酒的时候吧。真好呢。深大真的很美，也很安静。适合散步放松心情。然后天差不多要黑了，起身拍了拍屁股上的灰，就寻路回家了。——————我是分割线——————怀念过往像香烟一样，会让人沉迷。所以，不要在过往中无法自拔，也不要割断自己的过往。将美好的过往像美酒一样密封，常年埋藏在地下。或在夜深的时候，或在孤身一人的时候，或在疲惫于生活的时候，将美酒拿出，取其一瓢，慢慢品尝。所以，偶尔怀念过往，让自己的灵魂暂时脱离这个车水马龙的世界，回到那段最珍贵的时光，回到那些最难忘的人们的身旁，一起嬉笑，一起挥霍时光。如果有时光机，你最想回到哪段时光呢？]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[看懂vue源码-理解数据双向绑定的实现]]></title>
    <url>%2F2019%2F04%2F29%2Fvue-databind%2F</url>
    <content type="text"><![CDATA[如果你是一名前端从业者，并且在简历上写了会使用vue框架，那么在拿着这份简历去面试的时候，面试官有很大的概率会问你vue的数据双向绑定是如何实现的。打开goole，输入vue双向绑定，有非常多优秀的博主已经对vue数据双向绑定作了一个全方位的刨析，阅读之后，你会大概了解，双向绑定涉及到javascript的核心api是Object.defineProperty,通过set与get这俩个存取描述符来监听数据的实时改变，并且在对模版作出相应改变。那么为了更加了解vue是如何实现数据双向绑定的，我花了一下午的时间阅读vue的源码，并将我的对vue实现数据双向绑定的方式理解记录了下来。 打开vue源码目录这几个文件夹都是分别负责什么的，我们暂且不管(其实是我不知道),我们找到入口文件src/core/index.js。看到一大推第一次见并且不熟的代码，谁都会感动头疼。所以我看源码的基本方针是 不清楚应用方法的具体实现，先靠他的命名猜一下(所以英文好很关键，哭)。 如果有一大堆if..else-if..else,先找到按正常流程走的代码,其他分支先放一放… 不用钻牛角尖，看的懂的代码就好好理解，看不懂的了解个大概足已！看源码的目的是更好的理解框架的实现原理，并不是要把整个框架吃透(关键也吃不透啊，vue源代码那么多，咱也不是啥大神，难道看不懂去问尤雨溪吗，咱也不敢问讷) 12345678910111213141516171819202122232425262728// src/core/index.jsimport Vue from './instance/index' //从Vue这个关键词来看，这个应该是vue的核型方法import &#123; initGlobalAPI &#125; from './global-api/index' // 初始化全局API？import &#123; isServerRendering &#125; from 'core/util/env' // 判断是不是ssr？import &#123; FunctionalRenderContext &#125; from 'core/vdom/create-functional-component'// 调用方法咯，初始化全局变量initGlobalAPI(Vue)// 给vue原型添加$isServer属性 --当前 Vue 实例是否运行于服务器。Object.defineProperty(Vue.prototype, '$isServer', &#123; get: isServerRendering&#125;)// 给vue原型添加$ssrContext 不认识这玩意Object.defineProperty(Vue.prototype, '$ssrContext', &#123; get () &#123; /* istanbul ignore next */ return this.$vnode &amp;&amp; this.$vnode.ssrContext &#125;&#125;)// 不认识// expose FunctionalRenderContext for ssr runtime helper installationObject.defineProperty(Vue, 'FunctionalRenderContext', &#123; value: FunctionalRenderContext&#125;)Vue.version = '__VERSION__'export default Vue 我就是以上面这种方式来一点点看源码的。根据上面得到的提示，我们应该去看看./instance/index里写了啥。123456// src/core/instance/indeximport &#123; initMixin &#125; from './init'...initMixin(Vue)...export default Vue 其他初始化函数我们先不看，从initMixin这个名字和第一个引入的骄傲位置来说，他应该和我们要找的data属性有一腿。所以我们打开./init看一下。12345// src/core/instance/initimport &#123; initState &#125; from './state'...initState(vm)... 从命名上来讲，state应该是与data联系更多的，也许是因为在react里，初始化数据就叫作state吧，所以我们打开./state找到initState方法1234567891011121314151617// src/core/instance/stateexport function initState (vm: Component) &#123; vm._watchers = [] // 看起来像清空一个观察者队列 const opts = vm.$options if (opts.props) initProps(vm, opts.props) // 初始化props参数 if (opts.methods) initMethods(vm, opts.methods) // 初始化methods参数 if (opts.data) &#123; initData(vm) // 如果有data参数，初始化data参数 &#125; else &#123; observe(vm._data = &#123;&#125;, true /* asRootData */) // 如果没有，触发observe方法(这个方法很关键！)，给一个&#123;&#125;作为默认值并且作为rootdata &#125; if (opts.computed) initComputed(vm, opts.computed) // 初始化computed参数 if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123; // watch存在并且 这个watch不是Firefox(火狐浏览器)在Object.prototype上有一个“监视”功能,初始化 initWatch(vm, opts.watch) &#125;&#125; 从上面的代码中，我们看到很多脸熟的代码了，并且终于找到我们想找的data属性，顺水推舟继续往下走吧，找到initData的方法定义。1234567891011121314151617181920212223242526272829303132333435363738394041424344function initData (vm: Component) &#123; let data = vm.$options.data data = vm._data = typeof data === 'function' ? getData(data, vm) : data || &#123;&#125; // 判断data是不是个函数，如果时执行getData（往一个targetStack push进去？） if (!isPlainObject(data)) &#123; // isPlainObject判断data是不是个对象 data = &#123;&#125; process.env.NODE_ENV !== 'production' &amp;&amp; warn( 'data functions should return an object:\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm ) &#125; // proxy data on instance const keys = Object.keys(data) const props = vm.$options.props const methods = vm.$options.methods let i = keys.length while (i--) &#123; // 判断data里定义的key是否与methods和props的冲突 const key = keys[i] if (process.env.NODE_ENV !== 'production') &#123; if (methods &amp;&amp; hasOwn(methods, key)) &#123; warn( `Method "$&#123;key&#125;" has already been defined as a data property.`, vm ) &#125; &#125; if (props &amp;&amp; hasOwn(props, key)) &#123; process.env.NODE_ENV !== 'production' &amp;&amp; warn( `The data property "$&#123;key&#125;" is already declared as a prop. ` + `Use prop default value instead.`, vm ) &#125; else if (!isReserved(key)) &#123; proxy(vm, `_data`, key) &#125; &#125; // observe data observe(data, true /* asRootData */)&#125; 到这里，我们已经很接近实现数据双向绑定的函数了，那就observe，接下来去../observer/index里看看，observe函数到底写了些什么东西。在export function observe()的函数里，return出来的是一个名为Observer的类1234567891011121314151617181920212223242526272829303132333435363738394041424344// src/core/observer/index.jsexport class Observer &#123; value: any; dep: Dep; vmCount: number; // number of vms that have this object as root $data constructor (value: any) &#123; this.value = value this.dep = new Dep() this.vmCount = 0 def(value, '__ob__', this) if (Array.isArray(value)) &#123; if (hasProto) &#123; protoAugment(value, arrayMethods) &#125; else &#123; copyAugment(value, arrayMethods, arrayKeys) &#125; this.observeArray(value) &#125; else &#123; this.walk(value) &#125; &#125; /** * Walk through all properties and convert them into * getter/setters. This method should only be called when * value type is Object. */ walk (obj: Object) &#123; const keys = Object.keys(obj) for (let i = 0; i &lt; keys.length; i++) &#123; defineReactive(obj, keys[i]) &#125; &#125; /** * Observe a list of Array items. */ observeArray (items: Array&lt;any&gt;) &#123; for (let i = 0, l = items.length; i &lt; l; i++) &#123; observe(items[i]) &#125; &#125;&#125; 当我们调用new Oberver(value)的时候，会执行this.walk(value)这个方法，看方法里的作用应该是，遍历value,执行defineReactive方法，而在defineReactive方法里主要就是通过Object.defineProperty方法来定义响应式数据。123456789101112131415161718192021222324// src/core/observer/index.jsexport function defineReactive ( obj: Object, key: string, val: any, customSetter?: ?Function, shallow?: boolean) &#123; const dep = new Dep() ... Object.defineProperty(obj, key, &#123; ... get: function reactiveGetter () &#123; ... dep.depend() ... return value &#125;, set: function reactiveSetter (newVal) &#123; ... dep.notify() &#125; &#125;)&#125; 省略了部分代码后，我们注意到在get和set里分别执行了dep.depend()和dep.notify(),而Dep就是我们常说的订阅发布管理中心，这时候我们来看一张，vue实现数据双向绑定的示例图。大概解释一下上图，上图实现的设计模式为 订阅-发布 模式。可以从俩个入口分别说起 1.从init Data说起，比如我们在vue实例中定义了初始化的data属性，接着会触发new Observer(),data里所有的数据都会通过上面介绍的那样，通过defineReactive这个方法为每一个属性挂载Object.defineProperty(也可以说在get里为每一个属性都添加了一个订阅，在set里做一个通知订阅者的操作),如果触发了setter，也就是在业务代码里改变了data里的值，会通知Watcher，Wathcer更新指令系统对应绑定的data值2.从编译侧说起，Dom 上通过指令或者双大括号绑定的数据，经过编译以后，会为数据进行添加观察者Watcher，当实例化Watcher的时候 会触发属性的getter方法，此时会调用dep.depend()，并且会将Watcher的依赖收集起来。 那么我们可以看一下dep.depend()和dep.depend()1234567891011121314151617181920// src/core/observer/dep.js depend () &#123; if (Dep.target) &#123; Dep.target.addDep(this) &#125; &#125; notify () &#123; // stabilize the subscriber list first const subs = this.subs.slice() if (process.env.NODE_ENV !== 'production' &amp;&amp; !config.async) &#123; // subs aren't sorted in scheduler if not running async // we need to sort them now to make sure they fire in correct // order subs.sort((a, b) =&gt; a.id - b.id) &#125; for (let i = 0, l = subs.length; i &lt; l; i++) &#123; subs[i].update() &#125; &#125; 首先我们得先知道注入到Dep里的一般都是Watcher类，像Dep.target.addDep(this)和subs[i].update()这俩个方法是可以在定义Watcher的文件下找到的。12345678910111213141516171819202122// src/core/observer/watcher.js addDep (dep: Dep) &#123; const id = dep.id if (!this.newDepIds.has(id)) &#123; this.newDepIds.add(id) this.newDeps.push(dep) if (!this.depIds.has(id)) &#123; dep.addSub(this) &#125; &#125; &#125; ... update () &#123; /* istanbul ignore else */ if (this.lazy) &#123; this.dirty = true &#125; else if (this.sync) &#123; this.run() &#125; else &#123; queueWatcher(this) &#125; &#125; 一系列操作的主要作用就是让Dep与Wathcer建立双向的联系。 代码真是太多了，解释不完，感觉要烂尾了 最后vue有一个很关键的指令解析系统，在src/compiler/directives文件中可以找到v-bind,v-on,v-model相应的源码。能力有限，看不下去了。越挖越深。 说的我自己都乱了 言简意赅的总结一下，Observer就是对data里到所有值进行一个数据劫持，强行给每个数据注入set(能监听到数据改变，没有return)与get(该数据具体呈现出来的值，能return出数据)方法，Observer操作完以后，data可以理解成房子资源。然后Dep是个订阅器（订阅管理中心，可以理解成房地产中介），Watcher是订阅者(有钱买房的人)，Watcher把需求和联系方式通过dep.depend()告诉中介dep，dep中介找到了合适的房子通过dep.notify()打电话通知我们忽悠买房。那Wathcer没有钱之前就是被绑定在dom上的一些数据，通过了v-model,v-test,双大括号等途径赚到了钱（也就是vue的compile编译系统），升级成了一个Wathcer，赚钱和买房总是无穷无尽的，dom发生了更新（比如input事件），赚到钱了就去问中介dep有没有房，同时如果房源发生了变化（data发生了更新），中介dep会通知Wathcer买房不? 最后祝大家早日能买到房。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[加深了解vuex及使用typescript如何搭建store文件夹]]></title>
    <url>%2F2019%2F04%2F24%2Fvuex%2F</url>
    <content type="text"><![CDATA[自从使用vue作为项目开发框架后，vue的全家桶每天都会与我见面，其中vuex更是常客。对于专门作为vue的状态管理模式，我认为这应该是每一位前端从业者都必须深入掌握的一项技能，可是在这段时间的面试中，我问了一些vuex相关的知识，却很少有人回答全面，即使他们的简历上写了3-4年的从业经验。比如以下这些vuex最基础的问题。 如何调用store.js里的Mutation与Actions里定义的方法？ 大部分人回答的都是以通过this.$store.commit或者this.$store.dispatch这种通过调用vue实例中的$store的方式，而且只知道这一种调用方法。其实还有两种方式:1.通过import store from &#39;store.js&#39;的方式引入文件，通过store.commit和store.dispatch的方式调用。2.使用mapActions,mapMutation等辅助函数将组件的methods映射为store对应的方法名。 使用过vuex的module概念吗？在.vue文件中如何使用module里的Mutation与Actions里定义的方法？ 这个基本上就全军覆没了，仅知道vuex有这么一个概念，但项目中没有用过，所以对于模块化的store不了解。对于vuex的module概念，其实真的不难，个人觉得，即使项目中没有用过，但vuex作为我们日常开发中的老朋友，认真了解一下他5个孩子State,Getter,Mutation,Action,Module，从时间成本上来说，也许一个晚上就可以搞定，即使现在项目中使用不到，那未来的项目再碰到至少不会措手不及吧。 从以上俩个基础问题可以看出，很多前端对vuex的学习并不深入，觉得能在项目中使用就可以了，毕竟代码不是浮现在页面上的东西，只要功能能正确实现，很少有人对你的代码会有兴趣。这怎么说呢，多少是有点道理的，但是对知识的追求不该止步于实现功能这一步，既然尤雨溪开源了vue这么好的前端框架，如果我们不更加深入了解vuex，是不是对别人的知识成果不尊重呢？ Vuex到底是什么东西？在说vuex之前，可以先了解一下Flux与Redux。每一位前端对MVC框架与MVVM框架都不陌生，如果略显遗忘，可以参考阮一峰老师的对这几个框架的解释,简单来说Flux是一种架构思想，专门解决软件的结构问题，而Redux则是将Flux与函数式编程结合在一起,使收Flux启发的简介版Flux。其实这些概念都不重要，随便百度一下就好啦︿(￣︶￣)︿按照官方的说法Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。按照惯例放一张官方的图vuex的五个核心概念State,Getter,Mutation,Action,Module,基本用法我就不再一一列举了，参考vue官网一定比我介绍的详细。 以下只介绍一些我个人对这几个概念中比较少用的知识点的罗列。 State 如何获取模块内的state12345678910import &#123;mapState&#125; from 'vuex';export default &#123; computed:&#123; ...mapState([&#123; count:state=&gt;state.moduleName.count &#125;]) &#125;&#125;orthis.$store.state.moduleName.count Module 如何使用mapState, mapGetters, mapActions 和 mapMutations 这些函数来绑定带命名空间的模块。 在辅助函数第一个参数可以填模块名 12...mapGetters('moduleName',['foo','bar'])...mapActions('moduleName',['fn1','fn2']) 使用 createNamespacedHelpers 创建基于某个命名空间辅助函数 123const &#123; mapState, mapActions &#125; = createNamespacedHelpers('moduleName')...mapGetters('moduleName',['foo','bar'])...mapActions('moduleName',['fn1','fn2']) 通过this.$store调用,比如现在模块名叫child 123this.$store.getters['child/foo']this.$store.commit('child/addCount',1)this.$store.dispatch('child/fn',data) 在带命名空间的模块内访问全局内容 getters有四个参数state,getters,rootState,rootGetters,后面两个是全局内容。actions第一个参数是个object，他里面包含{ dispatch, commit, getters, rootGetters }，最后一个是全局内容。在actions里如果要分发 action 或提交 mutation，将 { root: true } 作为第三参数传给 dispatch 或 commit 即可。 12dispatch('someOtherAction', null, &#123; root: true &#125;) // -&gt; 'someOtherAction'commit('someMutation', null, &#123; root: true &#125;) // -&gt; 'someMutation' 在带命名空间的模块注册全局 action若需要在带命名空间的模块注册全局 action，你可添加 root: true，并将这个 action 的定义放在函数 handler 中。 1234567// module/child.js actions: &#123; someAction: &#123; root: true, handler (&#123; dispatch, commit, getters, rootGetters &#125;, payload) &#123; ... &#125; // -&gt; 'someAction' &#125; &#125; 使用Typescript开发的项目如何写vuex的store文件夹这个就有意思啦，既然选择了ts代替了js，那么ts的一些特性就要使用起来，于是我写了一个demo。下图是我demo的文件结构，有木有觉得分的很清晰，很详细，哈哈。其中list是一个模块。接下来就一个一个文件看过去吧。 index.ts store的对外暴露文件123456789101112131415161718 import Vue from 'vue' import Vuex ,&#123;StoreOptions&#125;from 'vuex' import &#123;RootState&#125; from './type'; import &#123;todolist&#125; from './module/list/index'; Vue.use(Vuex) const store: StoreOptions&lt;RootState&gt; = &#123; state: &#123; version:'1.0.0' &#125;, //注册全局state getters:&#123;&#125;, //注册全局getters mutations: &#123;&#125;, //注册全局mutations actions: &#123;&#125;, //注册全局actions modules:&#123; todolist &#125; &#125;export default new Vuex.Store&lt;RootState&gt;(store); 如果你对StoreOptions&lt;RootState&gt;这种写法有疑问，你可以参考vuex的源代码，在vuex/types/index.d.ts文件中有相关介绍。并且你需要了解ts的泛型与类型变量。 type.ts 暴露全局state的接口，如果要新添state，要提前在这里定义类型，因为类型检查器会检查接口里的属性 123export interface RootState &#123; version: string&#125; module/list/index.ts store模块list的对外暴露文件 123456789101112131415161718import &#123;Module&#125; from 'vuex';import &#123;ListState&#125; from './type';import &#123;getters&#125; from './getters';import &#123;mutations&#125; from './mutations';import &#123;actions&#125; from './actions';import &#123;RootState&#125; from '../../type'const namespaced:boolean = true; //开启命名空间export const state:ListState = &#123; listArr:[], foo:'hello'&#125;export const todolist:Module&lt;ListState,RootState&gt; = &#123; namespaced, state, getters, mutations, actions&#125; 如果你对namespaced有疑问，可以参看vue的官网对命名空间的解释，点我 module/list/type.ts 暴露模块list的state的接口。 1234export interface ListState &#123; listArr ?: any[], foo ?: string&#125; module/list/getters.ts 暴露模块list的getters参数。 123456789import &#123;GetterTree&#125; from 'vuex';import &#123;ListState&#125; from './type';import &#123;RootState&#125; from '../../type';export const getters:GetterTree&lt;ListState,RootState&gt; = &#123; bar(state,getters,rootState,rootGetters): string &#123; return state.foo+' world' &#125;&#125; module/list/mutations.ts 暴露模块list的mutation参数。 12345678import &#123;MutationTree&#125; from 'vuex';import &#123;ListState&#125; from './type';export const mutations:MutationTree&lt;ListState&gt;=&#123; addFuHao(state,payload:string)&#123; state.foo += payload &#125;&#125; module/list/actions.ts 暴露模块list的actions参数。 123456789101112131415161718import &#123;ActionTree&#125; from 'vuex';import &#123;ListState&#125; from './type';import &#123;RootState&#125; from '../../type';export const actions:ActionTree&lt;ListState,RootState&gt;=&#123; fetchData(&#123;commit,dispatch,getters,rootGetters&#125;,payload):any&#123; setTimeout(()=&gt;&#123; commit('addFuHao','!!!!') &#125;,3000) &#125;, rootActionTestFn:&#123; //注册全局action root:true, handler(...a):any&#123; console.log('触发了rootActionTestFn') console.log(a) &#125; &#125;&#125; 一般来说模块内是很少嵌套子模块的，除非项目特别要求。如果需要，照葫芦画瓢就好啦。 那么定义好了store,如何使用呢？主要使用的是vuex-class。参考以下代码123456789101112131415161718192021import &#123; Component, Vue &#125; from 'vue-property-decorator';import &#123;State, Getter ,Mutation,Action&#125; from 'vuex-class';import &#123;ListState&#125; from '../store/module/list/type'const namespace:string = 'todolist'; //这里要注意，名称需要和模块暴露出来的参数名保持一致@Component(&#123; name:'todolist'&#125;)export default class ToDoList extends Vue&#123; @State('list') list:any; @Getter('bar',&#123;namespace&#125;) bar:any; @Mutation('addFuHao',&#123;namespace&#125;) addFuHao:any; @Action('fetchData',&#123;namespace&#125;) fetchData:any; //引入模块list的action @Action('rootActionTestFn') rootActionTestFn:any; //引入全局action mounted() &#123; console.log(this.bar) this.fetchData(); this.addFuHao(); &#125;&#125;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Nginx初体验]]></title>
    <url>%2F2019%2F04%2F20%2Fnginx%2F</url>
    <content type="text"><![CDATA[在有了自己的服务器后，不好好玩玩Nginx怎么行呢！毕竟花了钱的正好之前在学习TypeScript的时候，自己在github上有一个项目，所以想把这个项目丢到线上去玩玩～目标: 将github上的项目丢进服务器，并且能够正确访问 www.zijunfe.cn;前端要学习的东西真的很多，不过我们的征途是星辰大海！学习使我秃头 如何在CentOS服务器里下载Nginx 下载epel-release EPEL (Extra Packages for Enterprise Linux)是基于Fedora的一个项目，为“红帽系”的操作系统提供额外的软件包，适用于RHEL、CentOS和Scientific Linux. 1sudo yum install epel-release 下载nginx 1sudo yum install nginx Nginx 开机启动 1sudo systemctl enable nginx Systemctl是一个systemd工具，主要负责控制systemd系统和服务管理器。Nginx 关闭开机启动 1关闭开机启动 Nginx 启动 Nginx 1sudo systemctl start nginx 检查 Nginx 的运行状态 1sudo systemctl status nginx 如果你的服务器开启了防火墙，则需要同时打开 80（HTTP）和 443（HTTPS）端口,通过下面的命令来打开这两个端口： 123sudo firewall-cmd --permanent --zone=public --add-service=httpsudo firewall-cmd --permanent --zone=public --add-service=httpssudo firewall-cmd --reload 验证 Nginx 是否成功启动，可以在浏览器中打开 http://YOUR_IP，您将看到默认的 Nginx 欢迎页面 停止Nginx 1sudo systemctl stop nginx 重启Nginx 1sudo systemctl restart nginx 修改 Nginx 配置后，重新加载 1sudo systemctl reload nginx 如何免密登陆服务器 把自己电脑的私钥复制出来，例如在mac里私钥在～/.ssh/*.pub文件里，如果没有私钥和公钥，可以先生成，如何生成，执行ssh-keygen,一路回车。 登陆服务器，把刚刚复制的私钥放入 服务器~/.ssh/authorized_keys文件中 执行命令ssh-add k id_rsa,id_rsa就是那个以.pub结尾的文件名，如果执行报错，则先执行命令ssh-agent bashen,再执行添加命令 进入服务器只需要执行ssh root@ip地址就能免密登陆啦！ 如何添加nginx代理文件 在etc/nginx/conf.d中新增以.conf结尾的配置文件，比如你的域名叫做zijunfe.cn，那最好新增的文件名就叫zijunfe-cn.conf作为文件名。 vim *.conf进入文件，添加配置，如下： 123456789server &#123; listen 80; server_name www.zijunfe.cn; root /www/typescript-project/dist; index index.html; location ~* ^.+\.(jpg|jpeg|gif|png|ico|css|js|pdf|txt)&#123; root /www/typescript-project/dist; &#125;&#125; 保存退出。 执行命令nginx -t看看配置有没有报错，执行nginx -s reload重启nginx服务。 如果执行完以上操作后发现访问网址没有变化，可以在访问etc/nginx/nginx.conf文件，找到include /usr/share/nginx/modules/*.conf;,将它放到文件最后，然后重新启动nginx服务。 如何在服务器上下载nodejs 在服务器上找一个文件夹，比如在/新建app文件夹 1mkdir app &amp;&amp; cd app 下载对应版本的nodejs版本，我的服务器系统centos，也就是Linux 64位的，nodejs建议下载稳定版本，在app文件夹里执行命令。 1wget -c https://nodejs.org/dist/v10.14.2/node-v10.14.2-linux-x64.tar.xz 解压文件夹 1tar -xvf node-v10.14.2-linux-x64.tar.xz 为了美观，对解压后的文件夹进行改名 1mv node-v10.14.2-linux-x64 nodejs 建立node,npm软连接 12sudo ln -s /app/nodejs/bin/node /usr/local/bin/nodesudo ln -s /app/nodejs/bin/npm /usr/local/bin/npm 检查是否安装成功，执行node -v，如果有版本号，则安装成功，如果报错，看一下是不是建立软连接的时候，对应的路径有没有写正确。 未完待续]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[面试]]></title>
    <url>%2F2019%2F04%2F12%2Finterview%2F</url>
    <content type="text"><![CDATA[这两天面试了一些前端同行，面试别人同样是宝贵的经验，因为在问别人的同时，自己也会思考，这题的答案是什么，除了这种解法还有没有其他解法呢？所以这篇博文，我把自己问的问题作一个归纳与总结，并分为三个层次，基础，提升，高级，并且写一些比较冷门的前端知识。 Vue基础篇vue-rouer有几种模式，区别是什么？ 两种模式，hash模式与history模式 ，vue-router默认使用hash模式，hash模式的url格式一般为http://.../#/...,history模式则没有/#/，并且history模式需要后端配合，因为vue一般写的是单页面应用，如果后端没有正确的配置，用户直接访问http://oursite.com/user/id则回提示404错误。 vue-router路由传参有几种方法？ 通过params或query传参，前者参数不在url上显示，刷新页面会丢失参数，后者会在url上显示，刷新页面不会丢失参数。路由的动态传参，这种方式首先要在router.js中配置路由对应的path为{ path: &#39;/user/:id&#39;, component: User }这种格式，在对应得页面可以通过this.$route.params来获取对应的参数。 vue-router的导航守卫有哪些？ 前置守卫:router.beforeEach(常用)当一个导航触发时，全局前置守卫按照创建顺序调用解析守卫:router.beforeResolve(不常用)与前置守卫相识，区别在于导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。后置守卫:router.afterEach(不常用)不会接受 next 函数也不会改变导航本身：独享守卫:beforeEnter(不常用)在路由配置里定义，用来对单独的路由作处理守卫一般有三个参数 to:Route:即将要进入的目标 路由对象 from: Route:当前导航正要离开的路由 next: Function:必须调用的跳转方法，否则不会进行路由跳转 简单介绍一下vue 的生命周期函数？ beforeCreate: 初始化之前的函数，vue实例不可访问，data未定义，一个基本不怎么用的函数created: 初始化函数，data已被定义，可以访问data里的数据，可以进行绑定，判断是否有el选项，有则继续进行，没有则停止编译(生命周期停止)，直到在该vue实例上调用vm.$mount(el)。接着判断是否有template选项，如果有，则会将template作为模板编译成render函数，如果没有，则将外部HTML作为模板编译。如果同时存在，template模版优先级是高于外部HTML的。同时vue对象中还有一个render函数，以createElement作为参数，然后做渲染操作，而且我们可以直接嵌入JSX，这个优先级是最高的。综上所述，模版优先级：render函数&gt;template模版&gt;外部HTML。beforeMount: 给vue添加$el成员，并且替换挂载的DOM元素。建立虚拟dom，data还是以参数名的方式挂载在节点中，没有注入数据。mounted: 第一次对组件进行渲染，将data里的数据注入节点中,这时已经形成了真实dom。这个函数vue的整个生命周期中只会执行一次，如果还有数据的变化，只会触发updated相关函数。beforeUpdate: 检测到data发生变化，准备对相应的组件再次渲染。首先重新渲染虚拟dom，再对真实的dom打补丁。updated: 完成对data发生变化的对应组件渲染beforeDestory: 实例销毁之前调用。在这一步，实例仍然完全可用。destoryed: 在Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。帖一张官方的生命周期图 vuex的核心概念包括哪些内容。内容比较多，详情看vuex官网 state:存放状态数据的字段，辅助函数mapStategetter:可以认为是 store 的计算属性,辅助函数mapGettermutation:更改store状态的唯一方法，必须是同步操作，辅助函数mapMutationaction:action类似于mutation,不过无法直接变更状态，需要通过提交mutation来更改，可以包含任意的异步操作，辅助函数mapActionmodule:store的模块，每个模块拥有自己的state、mutation、action、getter、甚至是嵌套子模块。通过设置namespaced: true的方式使其成为带命名空间的模块，如果需要在带命名空间的模块访问全局内容，rootState 和 rootGetter 会作为第三和第四参数传入 getter，若需要在全局命名空间内分发 action 或提交 mutation，将 { root: true } 作为第三参数传给 dispatch 或 commit 即可。 JS基础篇说一些与Array相关的api，并且挑几个详细说明它们的作用？ concat: 合并两个或多个数组，不会改变原数组，返回一个新数组every: 测试数组所有元素是否通过制定函数的测试some: 测试数组是否存在元素是否通过制定函数的测试forEach: 对数组的每个元素执行一次提供的函数。reduce:对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。第一个参数为执行函数，第二个参数为执行函数第一次调用时它第一个参数的值map: 创建一个新数组，结果为该数组每个元素调用函数的结果filter: 过滤，创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。entries: 返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对。find: 返回数组中满足提供的测试函数第一个元素的值findIndex: 返回数组中满足提供的测试函数第一个元素的索引，没有返回-1flat: 按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。（IE不支持该方法）includes: 判断一个数组是否包含一个指定的值concat: 合并两个或多个数组，不会改变原数组，返回一个新数组join: 将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。如果数组只有一个项目，那么将返回该项目而不使用分隔符。splice: 通过删除或替换现有元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。三个参数，start(指定下标)，deleteCount(移除的个数),[item1,item2,…]从start位置开始插入的元素。slice: 返回一个新的数组对象，这一对象是一个由 begin和 end（不包括end）决定的原数组的浅拷贝。原始数组不会被改变。reverse: 倒序sort: 排序push,pop,shift,unshift 数组堆栈操作 js的基础类型有哪些？ String,Boolean,Number,Object,Undefined,Null,Symbol var,let,const三种声明变量的方式有什么区别？ var 声明变量有变量提升的功能 能重复声明let 声明一个具有块级作用域的变量，不具备变量提升功能，重复声明会报错const 声明一个具有块级作用域的常量，并且常用大写字母作为变量名，不具备变量提升功能，重复声明会报错，重新赋值也会报错 提升篇Object.assign()方法只会拷贝源对象自身并且可枚举的属性到目标对象，那么如何拷贝不可枚举的属性和继承属性呢？首先说一下如何拷贝不可枚举的属性。何为不可枚举属性，其实对象里每一个键值对都有6个配置选项。比如obj = {a:1}这样的数据结构，他是与123456789Object.defineProperty(obj,'a',&#123; configurable:true, // 该属性的描述符是否能被改变 enumerable:true, // 该属性是否可枚举 value: 1 // 数据描述符 该属性对应的值 writeable: true // 数据描述符 value是否能被赋值运算符改变 // 数据描述符与存取描述符不可同时存在 // get:function()&#123;return aValue&#125;, // 一个给属性提供getter的方法，当访问该属性时，该方法会被执行 // set:function(newValue)&#123;aValue = newValue&#125; // 一个给属性提供setter的方法，当值修改时，触发执行该方法&#125;) 当设置了属性的enumerable为false时，这条属性就是不可枚举属性，即无法通过for..in..与Object.keys()获取到首先你得通过Object.getOwnPropertyNames(obj)(能获取到不可枚举的属性的键名，但是获取不到以Symbol作为键名的属性)或者Reflect.ownKeys(obj)(获取到所有属性的键名)的方法获取到包括不可枚举属性的一个数组。然后循环这个数组，通过Object.getOwnPropertyDescriptor(obj,propkey)的方法得知每一个属性的描述符，然后筛选出enumerable:false的属性，重新通过Object.definePropertires(newObj,{&#39;propkey1&#39;:{...},&#39;propkey2&#39;:{...}})的方式放入新的obj里，其他可枚举的属性通过Object.assign({},obj1,...,objn)的方式放入就好了。至于继承属性的问题，可以通过Object.getPrototypeOf(obj)的方式获取指定对象的原型，然后设置新数组的__proto__为这个原型。问题就解决了。当然有一种更好的方法。配合使用Object.create()可用达到同样的目的12let newObj = Object.create(Object.getPrototypeOf(obj),Object.getOwnPropertyDescriptors(obj))let target = Object.assign(&#123;&#125;,newObj,newObj1,...,newObjN) CSS基础篇display:none与visibility:hidden与opacity:0(兼容写法filter：alpha(opacity=0))的区别? 他们都能让元素消失不见。display:none会让元素从渲染树中消失，渲染时不占任何空间，从而达到消失的目的。visibility:hidden与opacity:0只是让元素不可见，元素不会从渲染树消失不见，继续占据空间。display:none是非继承属性，元素直接消失了，修改子孙节点属性无法显示。visibility:hidden是继承属性，通过修改子孙属性visibility:visible可以让子孙节点显示。opacity:0，消失的原理是将元素的透明度设置为0，是继承属性，子孙节点通过设置opacity:1无法显示，可以继续触发元素上绑定的事件。修改元素的display通常会造成文档的回流，修改visibility与opacity属性只会造成本元素的重绘。 技巧基础篇对手机号做加密处理，将中间四位数字用*代替 replace方法 1phone.replace(/(?&lt;=.&#123;3&#125;).(?=.&#123;4&#125;)/g,'*') substring方法,或substr方法 123phone.substring(0,3)+'****'+phone.substring(6,4)//orphone.substr(0,3)+'****'+phone.substr(-4) 数组splice方法 1arr=phone.split();arr.splice(3,4,'****');arr.join('') 处理金钱字符串，例如‘1234567’=&gt;’1,234,567’ 正则法 1str.replace(/\B(?=(\d&#123;3&#125;)+(?!\d))/g,',') js法 12345function formarMoney(str)&#123; return str.split('').reverse().reduce((pre,next,index)=&gt;&#123; return （(index%3) ? next : (next+',')) + pre &#125;)&#125; toLocaleString 法(这个是真的牛皮) 1(23333333).toLocaleString('en-US') 介绍一下ES模块语法 使用export关键字导出一个变量或者类型 1234567891011export const someVar = 1;export type someType = &#123; foo:string&#125;export interface someInterface = &#123; foo ?:string&#125;// 在提前定义好变量或者类型后，可以这样导出export &#123;someVar,someType&#125;// 重命名变量导出export &#123;someVar as aDifferentName&#125; 使用import关键字导入一个变量或者一个类型 1234567891011import &#123;someVar,someType&#125; from './foo'// 重命名导入变量或者类型import &#123; someVar as aDifferentName &#125; from './foo';// 使用整体加载import * as foo from './foo'; // 你可以这样使用foo.someVar了// 仅导入模块import 'core-js'; //工具库// 从其他模块导入后整体导出：export * from './foo';// 从其他模块导入后，部分导出export &#123; someVar &#125; from './foo'; 使用默认导入/导出 export default 使用export defalut与export的区别: 导入使用时可以根据需要自定义导入命名,比如这样的语法import someName from &#39;someModule&#39; 导出变量，函数，类不需要提前定义，比如123export default (someVar = 123);export default function someFunction() &#123;&#125;export default class someClass &#123;&#125; 重写类型的动态查找 在项目里可以通过declare module &#39;somePath&#39;来声明一个全局模块的方式，用来解决查找模块路径的问题全局类型声明写法 123456789// 全局类型声明写法// **暴露**declare module 'foo' &#123;// some variable declarationsexport var bar: number;&#125;// **引入**import * as foo from 'foo'; 模块导出声明写法 123456789// 模块导出声明写法declare interface funcAbcSign &#123; (s: string): string&#125;export declare let abc: funcAbcSign;export declare function fn();// 引入import &#123;funcAbcSign,abc&#125; from 'foo'; 全局类型声明里的名称将被引入整个 TypeScript 全局命名空间中，从引用这个 声明文件起就可以自由使用。模块导出声明里的名称必须通过 import/require 才能使用。 提升篇介绍一下你了解的排序方式冒泡排序 冒泡排序是一种非常简单的排序方式，这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。排序基本思想为循环序列内每一个元素，循环到的元素与相邻的元素作对比，每次循环会将最小或者最大值冒泡至最底部，直到整个循环结束。 123456789for(let i=0,l=arr.length;i&lt;l;i++)&#123; for(let j=0;j&lt;l-1-i;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; let tmp = arr[j+1]; arr[j+1] = arr[j]; arr[j] = tmp; &#125; &#125;&#125; 改进冒泡排序: 设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。改进后如下 12345678910111213let i = arr.length-1;while(i &gt; 0)&#123; var pos = 0; for(let j=0;j&lt;i;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; pos = j; var tmp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = tmp; &#125; &#125; i = pos;&#125; 选择排序 选择排序是一种简单直观的排序算法，它的原理是:首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 123456789101112let tmp,minIndex; for(let i=0,l=arr.length;i&lt;l-1;i++)&#123; minIndex = i; for(let j=i+1;j&lt;l;j++)&#123; if(arr[j]&lt;arr[minIndex])&#123; minIndex = j; &#125; &#125; tmp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = tmp; &#125; 插入排序 插入排序的远离应该是最容易理解的了，就像打扑克牌，摸到牌以后，你需要对牌进行从小到大的排序，如果你打扑克从不排序，那当我没说…它的工作原理是，构造一个有序序列，然后拿未排序的数据在已排序序列中从后向前扫描，找到相应位置插入。 123456789for(let i=1,l=arr.length;i&lt;l;i++)&#123; let key = arr[i]; var j = i-1; while(j&gt;=0 &amp;&amp; arr[j]&gt;key)&#123; arr[j+1] = arr[j]; j--; &#125; arr[j+1]=key;&#125; 未完待续…]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何给自己的博客添加评论系统]]></title>
    <url>%2F2019%2F04%2F11%2Fblog-comments%2F</url>
    <content type="text"><![CDATA[想要做一个骚气的博主，没有一个评论系统怎么行呢 打开我的Google复制一下别人的，呸，打开我的Google搜索一下前辈们的经验。首先，我了解到的是next官网推荐的几种评论插件，分别是以下这几个哥们DISQUS Facebook Comments HyperComments 网易云跟帖 来必力 从名字上来说，我选择最后一个试一下(绝对不是我看不懂别人官网，绝对不是!) 来必力来必力(这特喵的居然是个韩文网站) 这款评论系统比较简单，首先要去人家官网注册一个账号，登陆以后根据提示申请一个免费的city版什么鬼的，然后在代码里能得到一串LiveRe UID，在next 的_config.yml文件里编辑livere_uid字段，就完成啦，系不系很简单？效果如下然后我觉得太丑了，不符合next的黑白简约主题，而且很大概率进入页面后需要重新刷新才能显示出来，所以我就放弃了。 Gitment接下来我又在茫茫Google中搜索，然后找到了它，看介绍说是通过github提issue的方式来创建一个评论系统，看到github我嘴角疯狂上扬，符合我的气质，这个我看行，开搞！ 首先在https://github.com/settings/developers申请一个免费的application，根据提示填写如下内容， 1234Application name：blog-comments // 随便写啥，你能记住就好 Homepage URL：https://网站地址/ // 你的博客地址Application description：Blog comment system // 随便写Authorization callback URL：https://网站地址/ // 你的博客地址 创建完成后先不要关闭，client_id与client_secret下面要用 接着在你的github新建一个空的仓库来存放评论，比如叫做blog-comments 然后在主题配置文件_config.yml里填写gitment的相关配置12345678910111213gitment: enable: true // 这个改成true mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: false # Hide &apos;Powered by ...&apos; on footer, and more language: zh-Hans # Force language, or auto switch by theme github_user: BiYangJun # MUST HAVE, Your Github ID github_repo: blog-comments # MUST HAVE, The repo you use to store Gitment comments 这是你新建的存放评论的库 client_id: # MUST HAVE, Github client id for the Gitment 刚刚创建application里有的 client_secret: # EITHER this or proxy_gateway, Github access secret token for the Gitment 刚刚创建application里有的 proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled 全部配置完后，一切看起来很顺利，页面底部也出来了评论框，就差最后一步登陆自己的github来初始化了，一开始本地登陆不了，我以为是要部署后才能登陆，然后我部署了上去，心里想着这下成了! 部署后，我点击登陆后，一直给我报错[object ProgressEvent]，试了很多次，我还一度怀疑是不是我github密码输错了，纳闷的我去看了一下gitment的issue，最后发现原因大概是gitment的网站证书到期了，gitment需要这个为接口，所以一直报错。辛辛苦苦1小时，我… 哎，接着在茫茫Google找吧… Gitalk接着，在茫茫博客中，我发现了戳兔专家这位大哥的博文，跟着他的教程开始了安装Gitalk,帖个官网。 首先刚刚申请的application和新建存放评论的仓库不要丢，裹上鸡蛋液，放在油锅里炸一炸，隔壁小孩…住嘴！由于next还没有集成gitalk，所以配置起来相当繁琐 首先还是要在github上申请一个application和新建一个存放评论的仓库(上面的就可以用) 在 /layout/_third-party/comments/ 目录下新建 gitalk.swig 文件，内容如下： 12345678910111213141516&#123;% if page.comments &amp;&amp; theme.gitalk.enable %&#125; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/gitalk/dist/gitalk.css&quot;&gt; &lt;script src=&quot;https://unpkg.com/gitalk/dist/gitalk.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var gitalk = new Gitalk(&#123; clientID: &apos;&#123;&#123; theme.gitalk.ClientID &#125;&#125;&apos;, clientSecret: &apos;&#123;&#123; theme.gitalk.ClientSecret &#125;&#125;&apos;, repo: &apos;&#123;&#123; theme.gitalk.repo &#125;&#125;&apos;, owner: &apos;&#123;&#123; theme.gitalk.owner &#125;&#125;&apos;, admin: [&apos;&#123;&#123; theme.gitalk.adminUser &#125;&#125;&apos;], id: location.pathname, distractionFreeMode: &apos;&#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;&apos; &#125;) gitalk.render(&apos;gitalk-container&apos;) &lt;/script&gt;&#123;% endif %&#125; 修改 /layout/_partials/comments.swig，在最后一个 elseif 后添加字段，修改后如下： 1234567891011121314151617181920 &#123;% elseif theme.gitment.enable %&#125; &lt;div class=&quot;comments&quot; id=&quot;comments&quot;&gt; &#123;% if theme.gitment.lazy %&#125; &lt;div onclick=&quot;showGitment()&quot; id=&quot;gitment-display-button&quot;&gt;&#123;&#123; __(&apos;gitmentbutton&apos;) &#125;&#125;&lt;/div&gt; &lt;div id=&quot;gitment-container&quot; style=&quot;display:none&quot;&gt;&lt;/div&gt; &#123;% else %&#125; &lt;div id=&quot;gitment-container&quot;&gt;&lt;/div&gt; &#123;% endif %&#125; &lt;/div&gt; &#123;% elseif theme.valine.appid and theme.valine.appkey %&#125; &lt;div class=&quot;comments&quot; id=&quot;comments&quot;&gt; &lt;/div&gt; &#123;% elseif theme.gitalk.enable %&#125; &lt;div id=&quot;gitalk-container&quot;&gt;&lt;/div&gt; &#123;% endif %&#125;&#123;% endif %&#125; 修改 /layout/_third-party/comments/index.swig，在其末尾添加如下字段： 1&#123;% include &apos;gitalk.swig&apos; %&#125; 设置 gitalk 的样式，参考1： 在 /source/css/_common/components/third-party/ 目录下新建 gitalk.styl 文件，内容如下： 1234.gt-header a, .gt-comments a, .gt-popup a border-bottom: none;.gt-container .gt-popup .gt-action.is--active:before top: 0.7em; 修改 /source/css/_common/components/third-party/third-party.styl 文件，在末尾添加如下字段： 1@import &quot;gitalk&quot;; 最后在主题配置文件 _config.yml 中添加如下项： 12345678gitalk: enable: true owner: 你的github帐号 # lzcwr repo: 存放评论的仓库名称 # Gitalk-comments ClientID: 在申请好application的页面中有 ClientSecret: 在申请好application的页面中有 adminUser: 你的github帐号 # 可初始化评论的账户 distractionFreeMode: true 完整无误地完成上述步骤后，在本地可以看到gitalk的按钮，然后通过hexo d部署到线上后，登陆你的github进行初始化就大功告成了啦！ 如果你给一篇博文的文件命名有中文的话，你可能会碰到这个报错Error: Validation Failed。哎，真是一波三折啊 Error: Validation Failed 解决方案 修改前文提到的gitalk.swig，先下载一个md5.js,更改完毕后的gitalk.swig如下： 1234567891011121314151617&#123;% if page.comments &amp;&amp; theme.gitalk.enable %&#125; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/gitalk/dist/gitalk.css&quot;&gt; &lt;script src=&quot;/js/md5.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/gitalk/dist/gitalk.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var gitalk = new Gitalk(&#123; clientID: &apos;&#123;&#123; theme.gitalk.ClientID &#125;&#125;&apos;, clientSecret: &apos;&#123;&#123; theme.gitalk.ClientSecret &#125;&#125;&apos;, repo: &apos;&#123;&#123; theme.gitalk.repo &#125;&#125;&apos;, owner: &apos;&#123;&#123; theme.gitalk.owner &#125;&#125;&apos;, admin: [&apos;&#123;&#123; theme.gitalk.adminUser &#125;&#125;&apos;], id: md5(location.pathname), distractionFreeMode: &apos;&#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;&apos; &#125;) gitalk.render(&apos;gitalk-container&apos;) &lt;/script&gt;&#123;% endif %&#125; 批量修改博客文件名，例如以时间戳的方式命名md文件，具体可以参考这位大哥的博文 避免使用中文命名，英文不好咱们就用拼音吧！ 忙活了一晚上我的评论系统终于搞定了… 感谢万能的Google和戳兔专家这位大哥。看完的小伙伴记得评论、关注、收藏三连哦～呸、什么坏毛病能给评论就感激不尽啦～]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[记录一下搭建第一个博客的经历]]></title>
    <url>%2F2019%2F04%2F10%2Ffirst-blog%2F</url>
    <content type="text"><![CDATA[起因，在论坛闲逛的时候发现一个老哥把很多知识点，问题都记录在自己的个人博客里，知识罗列的很清楚。虽然我平时也会把一些问题和有趣的东西记录在MacDown里，可时如果要看的话还需要打开mac，很不方便。so～在网上找了一篇搭建博客的教程，干了一晚上终于成了，中间碰到很多曲折的问题，所以在这里记录一下。 一、搭建条件及环境 Github Pages + Hexo + Node.js Mac电脑的OSX系统/windows二、搭建步骤 首先你得有个github账号(作为新时代的码农，这是必备的)，创建一个新的repository，项目名称格式为yourname.github.io，如图 全局安装Hexo，npm install -g hexo-cli 创建一个空文件夹，进入该文件夹，依次执行以下命令 123hexo initnpm installnpm install hexo-deployer-git --save 在所有依赖都安装完成后，就可以在本地环境看一下hexo的博客内容啦，执行以下命令 12hexo generate hexo server 这两条命令可以缩写成hexo g hexo s作用分别是：将md文件生成html，css文件；启动本地hexo。打开http://localhost:4000就能看到本地效果啦。 修改 _config.yml 文件，这是博客网站 的配置文件，在这里你可以更改你的网页title，description等，最主要的是修改你在github上的仓库地址。 在最下面一行 1234deploy: type: git repository: git@github.com:BiYangJun/zijun.github.io.git branch: master 写上自己的仓库地址。至于是SSH公钥方式提交还是https方式提交，看个人喜好啦。 在写完自己的博客后，执行以下命令 12hexo generatehexo deploy hexo deploy 可以缩写成 hexo d意思为部署 接着你会上传文件到github上。接着就可以在线访问啦。 那么如何在线访问呢？ 打开你的github。点击environment， 然后在点击 View deployment,打开后的网址就是你的线上博客地址辣，easy～ 三、遇到的坑 如果发现线上博客一直是404，看一下repository中的setting，在GitHub Pages 这一栏中Source有没有选中master分支 能打开线上博客后，如果发现样式没有加载出来，在_config.yml修改root为自己的项目名称 其他hexo命令。hexo clean#缓存，在网页不正常的时候可以使用。hexo new ‘我的博客’#新建我的博客，hexo server -p 5000#更改端口 如何插入图片。 在主题的source下面新建一个文件夹images专门放置图片资源，使用markdown的语法 ![](/images/test.jpg) Hexo方式，设置_config.yml文件中post_asset_folder为true，之后新建一个文章后，会同时创建一个同名的空文件夹用来放图片资源，执行命令npm install hexo-asset-image --save，下载安装一个可以上传本地图片的插件，之后使用的时候，只需要图片名![](test.jpg) 网络图片插入‘#’ Hexo 支持使用特定的语法，插入指定大小的图片，如下： 123456// 语法&#123;% img [class names] /path/to/image [width] [height] [title text [alt text]] %&#125;// 实例&#123;% img full-image /hexo-experiences/PL01.jpg 180 180 hello %&#125;// 生成的代码&lt;img src=&quot;/blog/hexo-experiences/PL01.jpg&quot; class=&quot;full-image&quot; width=&quot;180&quot; height=&quot;180&quot; title=&quot;hello&quot;&gt; 如果发现怎么都不行，看下你这个博客是不是在二级域名下的，如果是，要设置_config.yml文件中的url与root。]]></content>
      <categories>
        <category>博客</category>
      </categories>
  </entry>
</search>
