<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>子君的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.zijunfe.cn/"/>
  <updated>2019-04-28T06:28:38.504Z</updated>
  <id>http://blog.zijunfe.cn/</id>
  
  <author>
    <name>Zi Jun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>加深了解vuex及使用typescript如何搭建store文件夹</title>
    <link href="http://blog.zijunfe.cn/vuex.html"/>
    <id>http://blog.zijunfe.cn/vuex.html</id>
    <published>2019-04-24T06:49:41.000Z</published>
    <updated>2019-04-28T06:28:38.504Z</updated>
    
    <content type="html"><![CDATA[<p>自从使用vue作为项目开发框架后，vue的全家桶每天都会与我见面，其中vuex更是常客。对于专门作为vue的状态管理模式，我认为这应该是每一位前端从业者都必须深入掌握的一项技能，可是在这段时间的面试中，我问了一些vuex相关的知识，却很少有人回答全面，即使他们的简历上写了3-4年的从业经验。比如以下这些vuex最基础的问题。<br><a id="more"></a></p><ul><li><p>如何调用store.js里的<code>Mutation</code>与<code>Actions</code>里定义的方法？</p><blockquote><p>大部分人回答的都是以通过<code>this.$store.commit</code>或者<code>this.$store.dispatch</code>这种通过调用vue实例中的<code>$store</code>的方式，而且只知道这一种调用方法。其实还有两种方式:1.通过<code>import store from &#39;store.js&#39;</code>的方式引入文件，通过<code>store.commit</code>和<code>store.dispatch</code>的方式调用。2.使用<code>mapActions</code>,<code>mapMutation</code>等辅助函数将组件的methods映射为store对应的方法名。</p></blockquote></li><li><p>使用过vuex的<code>module</code>概念吗？在<code>.vue</code>文件中如何使用<code>module</code>里的<code>Mutation</code>与<code>Actions</code>里定义的方法？</p><blockquote><p>这个基本上就全军覆没了，仅知道vuex有这么一个概念，但项目中没有用过，所以对于模块化的store不了解。<br>对于vuex的<code>module</code>概念，其实真的不难，个人觉得，即使项目中没有用过，但vuex作为我们日常开发中的老朋友，认真了解一下他5个孩子<code>State,Getter,Mutation,Action,Module</code>，从时间成本上来说，也许一个晚上就可以搞定，即使现在项目中使用不到，那未来的项目再碰到至少不会措手不及吧。</p></blockquote></li></ul><p>从以上俩个基础问题可以看出，很多前端对vuex的学习并不深入，觉得能在项目中使用就可以了，毕竟代码不是浮现在页面上的东西，只要功能能正确实现，很少有人对你的代码会有兴趣。这怎么说呢，多少是有点道理的，但是对知识的追求不该止步于实现功能这一步，既然尤雨溪开源了vue这么好的前端框架，如果我们不更加深入了解vuex，是不是对别人的知识成果不尊重呢？</p><h4 id="Vuex到底是什么东西？"><a href="#Vuex到底是什么东西？" class="headerlink" title="Vuex到底是什么东西？"></a>Vuex到底是什么东西？</h4><p>在说vuex之前，可以先了解一下Flux与Redux。每一位前端对<a href>MVC框架</a>与<a href>MVVM框架</a>都不陌生，如果略显遗忘，可以参考阮一峰老师的对这几个框架的<a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html" target="_blank" rel="noopener">解释</a>,简单来说Flux是一种架构思想，专门解决软件的结构问题，而Redux则是将Flux与函数式编程结合在一起,使收Flux启发的简介版Flux。<del>其实这些概念都不重要，随便百度一下就好啦︿(￣︶￣)︿</del><br>按照官方的说法Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。<br>按照惯例放一张官方的图<br><img src="/vuex1.jpg" alt="vuex结构图"><br>vuex的五个核心概念<code>State,Getter,Mutation,Action,Module</code>,基本用法我就不再一一列举了，参考<a href="https://vuex.vuejs.org/zh/guide/state.html" target="_blank" rel="noopener">vue官网</a>一定比我介绍的详细。</p><hr><p>以下只介绍一些我个人对这几个概念中比较少用的知识点的罗列。</p><h5 id="State"><a href="#State" class="headerlink" title="State"></a>State</h5><ul><li>如何获取模块内的state<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;mapState&#125; <span class="keyword">from</span> <span class="string">'vuex'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    computed:&#123;</span><br><span class="line">        ...mapState([&#123;</span><br><span class="line">            count:<span class="function"><span class="params">state</span>=&gt;</span>state.moduleName.count</span><br><span class="line">        &#125;])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">or</span><br><span class="line"><span class="keyword">this</span>.$store.state.moduleName.count</span><br></pre></td></tr></table></figure></div></li></ul><h5 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h5><ul><li>如何使用mapState, mapGetters, mapActions 和 mapMutations 这些函数来绑定带命名空间的模块。</li></ul><blockquote><p>在辅助函数第一个参数可以填模块名</p></blockquote><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...mapGetters(<span class="string">'moduleName'</span>,[<span class="string">'foo'</span>,<span class="string">'bar'</span>])</span><br><span class="line">...mapActions(<span class="string">'moduleName'</span>,[<span class="string">'fn1'</span>,<span class="string">'fn2'</span>])</span><br></pre></td></tr></table></figure></div><blockquote><p>使用 createNamespacedHelpers 创建基于某个命名空间辅助函数</p></blockquote><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; mapState, mapActions &#125; = createNamespacedHelpers(<span class="string">'moduleName'</span>)</span><br><span class="line">...mapGetters(<span class="string">'moduleName'</span>,[<span class="string">'foo'</span>,<span class="string">'bar'</span>])</span><br><span class="line">...mapActions(<span class="string">'moduleName'</span>,[<span class="string">'fn1'</span>,<span class="string">'fn2'</span>])</span><br></pre></td></tr></table></figure></div><blockquote><p>通过<code>this.$store</code>调用,比如现在模块名叫child</p></blockquote><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$store.getters[<span class="string">'child/foo'</span>]</span><br><span class="line"><span class="keyword">this</span>.$store.commit(<span class="string">'child/addCount'</span>,<span class="number">1</span>)</span><br><span class="line"><span class="keyword">this</span>.$store.dispatch(<span class="string">'child/fn'</span>,data)</span><br></pre></td></tr></table></figure></div><ul><li><p>在带命名空间的模块内访问全局内容</p><p>getters有四个参数<code>state,getters,rootState,rootGetters</code>,后面两个是全局内容。<br>actions第一个参数是个object，他里面包含<code>{ dispatch, commit, getters, rootGetters }</code>，最后一个是全局内容。<br>在actions里如果要分发 action 或提交 mutation，将 <code>{ root: true }</code> 作为第三参数传给 dispatch 或 commit 即可。</p></li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dispatch(<span class="string">'someOtherAction'</span>, <span class="literal">null</span>, &#123; <span class="attr">root</span>: <span class="literal">true</span> &#125;) <span class="comment">// -&gt; 'someOtherAction'</span></span><br><span class="line">commit(<span class="string">'someMutation'</span>, <span class="literal">null</span>, &#123; <span class="attr">root</span>: <span class="literal">true</span> &#125;) <span class="comment">// -&gt; 'someMutation'</span></span><br></pre></td></tr></table></figure></div><ul><li>在带命名空间的模块注册全局 action<br>若需要在带命名空间的模块注册全局 action，你可添加 root: true，并将这个 action 的定义放在函数 handler 中。</li></ul><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module/child.js</span></span><br><span class="line">    actions: &#123;</span><br><span class="line">        someAction: &#123;</span><br><span class="line">          root: <span class="literal">true</span>,</span><br><span class="line">          handler (&#123; dispatch, commit, getters, rootGetters &#125;, payload) &#123; ... &#125; <span class="comment">// -&gt; 'someAction'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></div><hr><h4 id="使用Typescript开发的项目如何写vuex的store文件夹"><a href="#使用Typescript开发的项目如何写vuex的store文件夹" class="headerlink" title="使用Typescript开发的项目如何写vuex的store文件夹"></a>使用Typescript开发的项目如何写vuex的store文件夹</h4><p>这个就有意思啦，既然选择了ts代替了js，那么ts的一些特性就要使用起来，于是我写了一个demo。<br>下图是我demo的文件结构，有木有觉得分的很清晰，很详细，哈哈。其中list是一个模块。<br><img src="/ts1.jpg" alt="文件目录"><br>接下来就一个一个文件看过去吧。</p><ul><li><code>index.ts</code> store的对外暴露文件<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="TS"><figure class="iseeu highlight /ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line">    <span class="keyword">import</span> Vuex ,&#123;StoreOptions&#125;<span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line">    <span class="keyword">import</span> &#123;RootState&#125; <span class="keyword">from</span> <span class="string">'./type'</span>;</span><br><span class="line">    <span class="keyword">import</span> &#123;todolist&#125; <span class="keyword">from</span> <span class="string">'./module/list/index'</span>;</span><br><span class="line">    Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> store: StoreOptions&lt;RootState&gt; = &#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        version:<span class="string">'1.0.0'</span></span><br><span class="line">    &#125;, <span class="comment">//注册全局state</span></span><br><span class="line">    getters:&#123;&#125;, <span class="comment">//注册全局getters</span></span><br><span class="line">    mutations: &#123;&#125;, <span class="comment">//注册全局mutations</span></span><br><span class="line">    actions: &#123;&#125;, <span class="comment">//注册全局actions</span></span><br><span class="line">    modules:&#123;</span><br><span class="line">        todolist</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store&lt;RootState&gt;(store);</span><br></pre></td></tr></table></figure></div></li></ul><blockquote><p>如果你对<code>StoreOptions&lt;RootState&gt;</code>这种写法有疑问，你可以参考vuex的源代码，在<code>vuex/types/index.d.ts</code>文件中有相关介绍。并且你需要了解ts的泛型与类型变量。</p></blockquote><ul><li><p><code>type.ts</code> 暴露全局state的接口，如果要新添state，要提前在这里定义类型，因为类型检查器会检查接口里的属性</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="TS"><figure class="iseeu highlight /ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> RootState &#123;</span><br><span class="line">    version: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li><li><p><code>module/list/index.ts</code> store模块list的对外暴露文件</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="TS"><figure class="iseeu highlight /ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Module&#125; <span class="keyword">from</span> <span class="string">'vuex'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;ListState&#125; <span class="keyword">from</span> <span class="string">'./type'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;getters&#125; <span class="keyword">from</span> <span class="string">'./getters'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;mutations&#125; <span class="keyword">from</span> <span class="string">'./mutations'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;actions&#125; <span class="keyword">from</span> <span class="string">'./actions'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;RootState&#125; <span class="keyword">from</span> <span class="string">'../../type'</span></span><br><span class="line"><span class="keyword">const</span> namespaced:<span class="built_in">boolean</span> = <span class="literal">true</span>; <span class="comment">//开启命名空间</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> state:ListState = &#123;</span><br><span class="line">    listArr:[],</span><br><span class="line">    foo:<span class="string">'hello'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> todolist:Module&lt;ListState,RootState&gt; = &#123;</span><br><span class="line">    namespaced,</span><br><span class="line">    state,</span><br><span class="line">    getters,</span><br><span class="line">    mutations,</span><br><span class="line">    actions</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ul><blockquote><p>如果你对<code>namespaced</code>有疑问，可以参看vue的官网对命名空间的解释，<a href="https://vuex.vuejs.org/zh/guide/modules.html" target="_blank" rel="noopener">点我</a></p></blockquote><ul><li><p><code>module/list/type.ts</code> 暴露模块list的state的接口。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="TS"><figure class="iseeu highlight /ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ListState &#123;</span><br><span class="line">    listArr ?: <span class="built_in">any</span>[],</span><br><span class="line">    foo ?: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li><li><p><code>module/list/getters.ts</code> 暴露模块list的getters参数。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="TS"><figure class="iseeu highlight /ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;GetterTree&#125; <span class="keyword">from</span> <span class="string">'vuex'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;ListState&#125; <span class="keyword">from</span> <span class="string">'./type'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;RootState&#125; <span class="keyword">from</span> <span class="string">'../../type'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getters:GetterTree&lt;ListState,RootState&gt; = &#123;</span><br><span class="line">    bar(state,getters,rootState,rootGetters): <span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state.foo+<span class="string">' world'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li><li><p><code>module/list/mutations.ts</code> 暴露模块list的mutation参数。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="TS"><figure class="iseeu highlight /ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;MutationTree&#125; <span class="keyword">from</span> <span class="string">'vuex'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;ListState&#125; <span class="keyword">from</span> <span class="string">'./type'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mutations:MutationTree&lt;ListState&gt;=&#123;</span><br><span class="line">    addFuHao(state,payload:<span class="built_in">string</span>)&#123;</span><br><span class="line">        state.foo += payload</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li><li><p><code>module/list/actions.ts</code> 暴露模块list的actions参数。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="TS"><figure class="iseeu highlight /ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;ActionTree&#125; <span class="keyword">from</span> <span class="string">'vuex'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;ListState&#125; <span class="keyword">from</span> <span class="string">'./type'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;RootState&#125; <span class="keyword">from</span> <span class="string">'../../type'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> actions:ActionTree&lt;ListState,RootState&gt;=&#123;</span><br><span class="line">    fetchData(&#123;commit,dispatch,getters,rootGetters&#125;,payload):<span class="built_in">any</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            commit(<span class="string">'addFuHao'</span>,<span class="string">'!!!!'</span>)</span><br><span class="line">        &#125;,<span class="number">3000</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    rootActionTestFn:&#123; <span class="comment">//注册全局action</span></span><br><span class="line">        root:<span class="literal">true</span>,</span><br><span class="line">        handler(...a):<span class="built_in">any</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'触发了rootActionTestFn'</span>)</span><br><span class="line">            <span class="built_in">console</span>.log(a)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ul><blockquote><p>一般来说模块内是很少嵌套子模块的，除非项目特别要求。如果需要，照葫芦画瓢就好啦。</p></blockquote><ul><li>那么定义好了store,如何使用呢？主要使用的是<code>vuex-class</code>。参考以下代码<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="TS"><figure class="iseeu highlight /ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, Vue &#125; <span class="keyword">from</span> <span class="string">'vue-property-decorator'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;State, Getter ,Mutation,Action&#125; <span class="keyword">from</span> <span class="string">'vuex-class'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;ListState&#125; <span class="keyword">from</span> <span class="string">'../store/module/list/type'</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">namespace</span>:<span class="built_in">string</span> = <span class="string">'todolist'</span>; <span class="comment">//这里要注意，名称需要和模块暴露出来的参数名保持一致</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">    name:<span class="string">'todolist'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> ToDoList <span class="keyword">extends</span> Vue&#123;</span><br><span class="line">    <span class="meta">@State</span>(<span class="string">'list'</span>) list:<span class="built_in">any</span>;</span><br><span class="line">    <span class="meta">@Getter</span>(<span class="string">'bar'</span>,&#123;<span class="keyword">namespace</span>&#125;) bar:<span class="built_in">any</span>;</span><br><span class="line">    <span class="meta">@Mutation</span>(<span class="string">'addFuHao'</span>,&#123;<span class="keyword">namespace</span>&#125;) addFuHao:<span class="built_in">any</span>;</span><br><span class="line">    <span class="meta">@Action</span>(<span class="string">'fetchData'</span>,&#123;<span class="keyword">namespace</span>&#125;) fetchData:<span class="built_in">any</span>; <span class="comment">//引入模块list的action</span></span><br><span class="line">    <span class="meta">@Action</span>(<span class="string">'rootActionTestFn'</span>) rootActionTestFn:<span class="built_in">any</span>; <span class="comment">//引入全局action</span></span><br><span class="line"></span><br><span class="line">    mounted() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.bar)</span><br><span class="line">        <span class="keyword">this</span>.fetchData();</span><br><span class="line">        <span class="keyword">this</span>.addFuHao();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ul>]]></content>
    
    <summary type="html">
    
      vuex到底是个啥？
    
    </summary>
    
      <category term="Vue" scheme="http://blog.zijunfe.cn/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>Nginx初体验</title>
    <link href="http://blog.zijunfe.cn/nginx.html"/>
    <id>http://blog.zijunfe.cn/nginx.html</id>
    <published>2019-04-20T09:48:24.000Z</published>
    <updated>2019-04-28T06:28:38.504Z</updated>
    
    <content type="html"><![CDATA[<p>  在有了自己的服务器后，不好好玩玩Nginx怎么行呢！<del>毕竟花了钱的</del><br>正好之前在学习<code>TypeScript</code>的时候，自己在github上有一个项目，所以想把这个项目丢到线上去玩玩～<br>目标: 将github上的项目丢进服务器，并且能够正确访问 <a href="http://www.zijunfe.cn" target="_blank" rel="noopener">www.zijunfe.cn</a>;<br>前端要学习的东西真的很多，不过我们的征途是星辰大海！<br><del>学习使我秃头</del></p><a id="more"></a><h4 id="如何在CentOS服务器里下载Nginx"><a href="#如何在CentOS服务器里下载Nginx" class="headerlink" title="如何在CentOS服务器里下载Nginx"></a>如何在CentOS服务器里下载Nginx</h4><ol><li><p>下载<code>epel-release</code></p><blockquote><p>EPEL (Extra Packages for Enterprise Linux)是基于Fedora的一个项目，为“红帽系”的操作系统提供额外的软件包，适用于RHEL、CentOS和Scientific Linux.</p></blockquote> <div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install epel-release</span><br></pre></td></tr></table></figure></div></li><li><p>下载nginx</p> <div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install nginx</span><br></pre></td></tr></table></figure></div></li><li><p>Nginx 开机启动</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable nginx</span><br></pre></td></tr></table></figure></div><blockquote><p>Systemctl是一个systemd工具，主要负责控制systemd系统和服务管理器。<br>Nginx 关闭开机启动</p></blockquote><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">关闭开机启动 Nginx</span><br></pre></td></tr></table></figure></div></li><li><p>启动 Nginx</p> <div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start nginx</span><br></pre></td></tr></table></figure></div></li></ol><ol start="5"><li><p>检查 Nginx 的运行状态</p> <div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status nginx</span><br></pre></td></tr></table></figure></div></li><li><p>如果你的服务器开启了防火墙，则需要同时打开 80（HTTP）和 443（HTTPS）端口,通过下面的命令来打开这两个端口：</p> <div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --permanent --zone=public --add-service=http</span><br><span class="line">sudo firewall-cmd --permanent --zone=public --add-service=https</span><br><span class="line">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure></div></li><li><p>验证 Nginx 是否成功启动，可以在浏览器中打开 <a href="http://YOUR_IP，您将看到默认的" target="_blank" rel="noopener">http://YOUR_IP，您将看到默认的</a> Nginx 欢迎页面</p></li><li><p>停止Nginx</p> <div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop nginx</span><br></pre></td></tr></table></figure></div></li></ol><ol start="9"><li><p>重启Nginx</p> <div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart nginx</span><br></pre></td></tr></table></figure></div></li><li><p>修改 Nginx 配置后，重新加载</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl reload nginx</span><br></pre></td></tr></table></figure></div></li></ol><h5 id="如何免密登陆服务器"><a href="#如何免密登陆服务器" class="headerlink" title="如何免密登陆服务器"></a>如何免密登陆服务器</h5><ol><li>把自己电脑的私钥复制出来，例如在mac里私钥在<code>～/.ssh/*.pub</code>文件里，如果没有私钥和公钥，可以先生成，如何生成，执行<code>ssh-keygen</code>,一路回车。</li><li>登陆服务器，把刚刚复制的私钥放入 服务器<code>~/.ssh/authorized_keys</code>文件中</li><li>执行命令<code>ssh-add k id_rsa</code>,<code>id_rsa</code>就是那个以<code>.pub</code>结尾的文件名，如果执行报错，则先执行命令<code>ssh-agent bashen</code>,再执行添加命令</li><li>进入服务器只需要执行<code>ssh root@ip地址</code>就能免密登陆啦！</li></ol><h5 id="如何添加nginx代理文件"><a href="#如何添加nginx代理文件" class="headerlink" title="如何添加nginx代理文件"></a>如何添加nginx代理文件</h5><ol><li>在<code>etc/nginx/conf.d</code>中新增以<code>.conf</code>结尾的配置文件，比如你的域名叫做<code>zijunfe.cn</code>，那最好新增的文件名就叫<code>zijunfe-cn.conf</code>作为文件名。</li><li><p><code>vim *.conf</code>进入文件，添加配置，如下：</p> <div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line"> listen 80;</span><br><span class="line"> server_name www.zijunfe.cn;</span><br><span class="line"> root /www/typescript-project/dist;</span><br><span class="line"> index index.html;</span><br><span class="line"> location ~* ^.+\.(jpg|jpeg|gif|png|ico|css|js|pdf|txt)&#123;</span><br><span class="line">  root /www/typescript-project/dist;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p> 保存退出。</p></li><li>执行命令<code>nginx -t</code>看看配置有没有报错，执行<code>nginx -s reload</code>重启nginx服务。</li><li>如果执行完以上操作后发现访问网址没有变化，可以在访问<code>etc/nginx/nginx.conf</code>文件，找到<code>include /usr/share/nginx/modules/*.conf;</code>,将它放到文件最后，然后重新启动nginx服务。</li></ol><h5 id="如何在服务器上下载nodejs"><a href="#如何在服务器上下载nodejs" class="headerlink" title="如何在服务器上下载nodejs"></a>如何在服务器上下载nodejs</h5><ol><li><p>在服务器上找一个文件夹，比如在<code>/</code>新建<code>app</code>文件夹</p> <div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir app &amp;&amp; cd app</span><br></pre></td></tr></table></figure></div></li><li><p>下载对应版本的nodejs版本，我的服务器系统centos，也就是Linux 64位的，nodejs建议下载稳定版本，在<code>app</code>文件夹里执行命令。</p> <div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -c https://nodejs.org/dist/v10.14.2/node-v10.14.2-linux-x64.tar.xz</span><br></pre></td></tr></table></figure></div></li><li><p>解压文件夹</p> <div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf node-v10.14.2-linux-x64.tar.xz</span><br></pre></td></tr></table></figure></div></li><li><p>为了美观，对解压后的文件夹进行改名</p> <div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv node-v10.14.2-linux-x64 nodejs</span><br></pre></td></tr></table></figure></div></li><li><p>建立node,npm软连接</p> <div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /app/nodejs/bin/node /usr/local/bin/node</span><br><span class="line">sudo ln -s /app/nodejs/bin/npm /usr/local/bin/npm</span><br></pre></td></tr></table></figure></div></li><li><p>检查是否安装成功，执行<code>node -v</code>，如果有版本号，则安装成功，如果报错，看一下是不是建立软连接的时候，对应的路径有没有写正确。</p></li></ol><p>未完待续</p>]]></content>
    
    <summary type="html">
    
      玩玩Nginx
    
    </summary>
    
      <category term="Nginx" scheme="http://blog.zijunfe.cn/categories/Nginx/"/>
    
    
  </entry>
  
  <entry>
    <title>面试</title>
    <link href="http://blog.zijunfe.cn/interview.html"/>
    <id>http://blog.zijunfe.cn/interview.html</id>
    <published>2019-04-12T01:57:39.000Z</published>
    <updated>2019-04-28T06:20:04.026Z</updated>
    
    <content type="html"><![CDATA[<p> 这两天面试了一些前端同行，面试别人同样是宝贵的经验，因为在问别人的同时，自己也会思考，这题的答案是什么，除了这种解法还有没有其他解法呢？所以这篇博文，我把自己问的问题作一个归纳与总结，并分为三个层次，<strong>基础</strong>，<strong>提升</strong>，<strong>高级</strong>，并且写一些比较冷门的前端知识。</p><a id="more"></a><h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><h4 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h4><h5 id="vue-rouer有几种模式，区别是什么？"><a href="#vue-rouer有几种模式，区别是什么？" class="headerlink" title="vue-rouer有几种模式，区别是什么？"></a><code>vue-rouer</code>有几种模式，区别是什么？</h5><blockquote><p>两种模式，hash模式与history模式 ，<code>vue-router</code>默认使用hash模式，hash模式的url格式一般为<code>http://.../#/...</code>,history模式则没有<code>/#/</code>，并且history模式需要后端配合，因为vue一般写的是单页面应用，如果后端没有正确的配置，用户直接访问<code>http://oursite.com/user/id</code>则回提示404错误。</p></blockquote><h5 id="vue-router路由传参有几种方法？"><a href="#vue-router路由传参有几种方法？" class="headerlink" title="vue-router路由传参有几种方法？"></a><code>vue-router</code>路由传参有几种方法？</h5><blockquote><p>通过<code>params</code>或<code>query</code>传参，前者参数不在url上显示，刷新页面会丢失参数，后者会在url上显示，刷新页面不会丢失参数。<br>路由的动态传参，这种方式首先要在<code>router.js</code>中配置路由对应的path为<code>{ path: &#39;/user/:id&#39;, component: User }</code>这种格式，在对应得页面可以通过<code>this.$route.params</code>来获取对应的参数。</p></blockquote><h5 id="vue-router的导航守卫有哪些？"><a href="#vue-router的导航守卫有哪些？" class="headerlink" title="vue-router的导航守卫有哪些？"></a><code>vue-router</code>的导航守卫有哪些？</h5><blockquote><p>前置守卫:<code>router.beforeEach</code>(常用)当一个导航触发时，全局前置守卫按照创建顺序调用<br>解析守卫:<code>router.beforeResolve</code>(不常用)与前置守卫相识，区别在于导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。<br>后置守卫:<code>router.afterEach</code>(不常用)不会接受 next 函数也不会改变导航本身：<br>独享守卫:<code>beforeEnter</code>(不常用)在路由配置里定义，用来对单独的路由作处理<br>守卫一般有三个参数</p><ol><li><code>to:Route</code>:即将要进入的目标 路由对象</li><li><code>from: Route</code>:当前导航正要离开的路由</li><li><code>next: Function</code>:必须调用的跳转方法，否则不会进行路由跳转</li></ol></blockquote><h5 id="简单介绍一下vue-的生命周期函数？"><a href="#简单介绍一下vue-的生命周期函数？" class="headerlink" title="简单介绍一下vue 的生命周期函数？"></a>简单介绍一下vue 的生命周期函数？</h5><blockquote><p><strong>beforeCreate</strong>: 初始化之前的函数，vue实例不可访问，data未定义，一个基本不怎么用的函数<br><strong>created</strong>: 初始化函数，data已被定义，可以访问data里的数据，可以进行绑定，判断是否有<code>el</code>选项，有则继续进行，没有则停止编译(生命周期停止)，直到在该vue实例上调用vm.$mount(el)。接着判断是否有<code>template</code>选项，如果有，则会将<code>template</code>作为模板编译成render函数，如果没有，则将外部HTML作为模板编译。如果同时存在，<code>template</code>模版优先级是高于外部HTML的。同时vue对象中还有一个<code>render</code>函数，以createElement作为参数，然后做渲染操作，而且我们可以直接嵌入JSX，这个优先级是最高的。综上所述，模版优先级：<code>render</code>函数&gt;<code>template</code>模版&gt;外部HTML。<br><strong>beforeMount</strong>: 给vue添加$el成员，并且替换挂载的DOM元素。建立虚拟dom，data还是以参数名的方式挂载在节点中，没有注入数据。<br><strong>mounted</strong>: 第一次对组件进行渲染，将data里的数据注入节点中,这时已经形成了真实dom。这个函数vue的整个生命周期中只会执行一次，如果还有数据的变化，只会触发updated相关函数。<br><strong>beforeUpdate</strong>: 检测到data发生变化，准备对相应的组件再次渲染。首先重新渲染虚拟dom，再对真实的dom打补丁。<br><strong>updated</strong>: 完成对data发生变化的对应组件渲染<br><strong>beforeDestory</strong>: 实例销毁之前调用。在这一步，实例仍然完全可用。<br><strong>destoryed</strong>: 在Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。<br><strong>帖一张官方的生命周期图</strong><br><img src="/vue.png" alt="生命周期"></p></blockquote><h5 id="vuex的核心概念包括哪些内容。内容比较多，详情看vuex官网"><a href="#vuex的核心概念包括哪些内容。内容比较多，详情看vuex官网" class="headerlink" title="vuex的核心概念包括哪些内容。内容比较多，详情看vuex官网"></a><code>vuex</code>的核心概念包括哪些内容。内容比较多，详情看<a href="https://vuex.vuejs.org/zh/guide/modules.html" target="_blank" rel="noopener">vuex官网</a></h5><blockquote><p><code>state</code>:存放状态数据的字段，辅助函数<code>mapState</code><br><code>getter</code>:可以认为是 store 的计算属性,辅助函数<code>mapGetter</code><br><code>mutation</code>:更改store状态的唯一方法，必须是同步操作，辅助函数<code>mapMutation</code><br><code>action</code>:action类似于mutation,不过无法直接变更状态，需要通过提交mutation来更改，可以包含任意的异步操作，辅助函数<code>mapAction</code><br><code>module</code>:store的模块，每个模块拥有自己的state、mutation、action、getter、甚至是嵌套子模块。通过设置<code>namespaced: true</code>的方式使其成为带命名空间的模块，如果需要在带命名空间的模块访问全局内容，<code>rootState</code> 和 <code>rootGetter</code> 会作为第三和第四参数传入 getter，若需要在全局命名空间内分发 <code>action</code> 或提交 <code>mutation</code>，将 <code>{ root: true }</code> 作为第三参数传给 <code>dispatch</code> 或 <code>commit</code> 即可。</p></blockquote><h3 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h3><h4 id="基础篇-1"><a href="#基础篇-1" class="headerlink" title="基础篇"></a>基础篇</h4><h5 id="说一些与Array相关的api，并且挑几个详细说明它们的作用？"><a href="#说一些与Array相关的api，并且挑几个详细说明它们的作用？" class="headerlink" title="说一些与Array相关的api，并且挑几个详细说明它们的作用？"></a>说一些与<code>Array</code>相关的api，并且挑几个详细说明它们的作用？</h5><blockquote><p><code>concat</code>: 合并两个或多个数组，不会改变原数组，返回一个新数组<br><code>every</code>: 测试数组所有元素是否通过制定函数的测试<br><code>some</code>: 测试数组是否存在元素是否通过制定函数的测试<br><code>forEach</code>: 对数组的每个元素执行一次提供的函数。<br><code>reduce</code>:对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。第一个参数为执行函数，第二个参数为执行函数第一次调用时它第一个参数的值<br><code>map</code>: 创建一个新数组，结果为该数组每个元素调用函数的结果<br><code>filter</code>: 过滤，创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。<br><code>entries</code>: 返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对。<br><code>find</code>: 返回数组中满足提供的测试函数第一个元素的值<br><code>findIndex</code>: 返回数组中满足提供的测试函数第一个元素的索引，没有返回-1<br><code>flat</code>: 按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。（IE不支持该方法）<br><code>includes</code>: 判断一个数组是否包含一个指定的值<br><code>concat</code>: 合并两个或多个数组，不会改变原数组，返回一个新数组<br><code>join</code>: 将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。如果数组只有一个项目，那么将返回该项目而不使用分隔符。<br><code>splice</code>: 通过删除或替换现有元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。三个参数，start(指定下标)，deleteCount(移除的个数),[item1,item2,…]从start位置开始插入的元素。<br><code>slice</code>: 返回一个新的数组对象，这一对象是一个由 begin和 end（不包括end）决定的原数组的浅拷贝。原始数组不会被改变。<br><code>reverse</code>: 倒序<br><code>sort</code>: 排序<br><code>push</code>,<code>pop</code>,<code>shift</code>,<code>unshift</code> 数组堆栈操作</p></blockquote><h5 id="js的基础类型有哪些？"><a href="#js的基础类型有哪些？" class="headerlink" title="js的基础类型有哪些？"></a>js的基础类型有哪些？</h5><blockquote><p>String,Boolean,Number,Object,Undefined,Null,Symbol</p></blockquote><h5 id="var-let-const三种声明变量的方式有什么区别？"><a href="#var-let-const三种声明变量的方式有什么区别？" class="headerlink" title="var,let,const三种声明变量的方式有什么区别？"></a><code>var</code>,<code>let</code>,<code>const</code>三种声明变量的方式有什么区别？</h5><blockquote><p><code>var</code> 声明变量有变量提升的功能 能重复声明<br><code>let</code> 声明一个具有块级作用域的变量，不具备变量提升功能，重复声明会报错<br><code>const</code> 声明一个具有块级作用域的常量，并且常用大写字母作为变量名，不具备变量提升功能，重复声明会报错，重新赋值也会报错</p></blockquote><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><h4 id="基础篇-2"><a href="#基础篇-2" class="headerlink" title="基础篇"></a>基础篇</h4><h5 id="display-none与visibility-hidden与opacity-0-兼容写法filter：alpha-opacity-0-的区别"><a href="#display-none与visibility-hidden与opacity-0-兼容写法filter：alpha-opacity-0-的区别" class="headerlink" title="display:none与visibility:hidden与opacity:0(兼容写法filter：alpha(opacity=0))的区别?"></a><code>display:none</code>与<code>visibility:hidden</code>与<code>opacity:0</code>(兼容写法<code>filter：alpha(opacity=0)</code>)的区别?</h5><blockquote><p>他们都能让元素消失不见。<code>display:none</code>会让元素从渲染树中消失，渲染时不占任何空间，从而达到消失的目的。<code>visibility:hidden</code>与<code>opacity:0</code>只是让元素不可见，元素不会从渲染树消失不见，继续占据空间。<br><code>display:none</code>是非继承属性，元素直接消失了，修改子孙节点属性无法显示。<code>visibility:hidden</code>是继承属性，通过修改子孙属性<code>visibility:visible</code>可以让子孙节点<strong>显示</strong>。<br><code>opacity:0</code>，消失的原理是将元素的透明度设置为0，是继承属性，子孙节点通过设置<code>opacity:1</code><strong>无法显示</strong>，可以继续触发元素上绑定的事件。<br>修改元素的display通常会造成文档的回流，修改visibility与opacity属性只会造成本元素的重绘。</p></blockquote><h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><h4 id="基础篇-3"><a href="#基础篇-3" class="headerlink" title="基础篇"></a>基础篇</h4><h5 id="对手机号做加密处理，将中间四位数字用-代替"><a href="#对手机号做加密处理，将中间四位数字用-代替" class="headerlink" title="对手机号做加密处理，将中间四位数字用*代替"></a>对手机号做加密处理，将中间四位数字用<code>*</code>代替</h5><ol><li><p><code>replace</code>方法</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">phone.replace(<span class="regexp">/(?&lt;=.&#123;3&#125;).(?=.&#123;4&#125;)/g</span>,<span class="string">'*'</span>)</span><br></pre></td></tr></table></figure></div></li><li><p><code>substring</code>方法,或<code>substr</code>方法</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">phone.substring(<span class="number">0</span>,<span class="number">3</span>)+<span class="string">'****'</span>+phone.substring(<span class="number">6</span>,<span class="number">4</span>)</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line">phone.substr(<span class="number">0</span>,<span class="number">3</span>)+<span class="string">'****'</span>+phone.substr(<span class="number">-4</span>)</span><br></pre></td></tr></table></figure></div></li><li><p>数组<code>splice</code>方法</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr=phone.split();arr.splice(<span class="number">3</span>,<span class="number">4</span>,<span class="string">'****'</span>);arr.join(<span class="string">''</span>)</span><br></pre></td></tr></table></figure></div></li></ol><h5 id="介绍一下ES模块语法"><a href="#介绍一下ES模块语法" class="headerlink" title="介绍一下ES模块语法"></a>介绍一下ES模块语法</h5><ul><li><p>使用<code>export</code>关键字导出一个变量或者类型</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> someVar = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> type someType = &#123;</span><br><span class="line">    foo:string</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> interface someInterface = &#123;</span><br><span class="line">    foo ?:string</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在提前定义好变量或者类型后，可以这样导出</span></span><br><span class="line"><span class="keyword">export</span> &#123;someVar,someType&#125;</span><br><span class="line"><span class="comment">// 重命名变量导出</span></span><br><span class="line"><span class="keyword">export</span> &#123;someVar <span class="keyword">as</span> aDifferentName&#125;</span><br></pre></td></tr></table></figure></div></li><li><p>使用<code>import</code>关键字导入一个变量或者一个类型</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;someVar,someType&#125; <span class="keyword">from</span> <span class="string">'./foo'</span></span><br><span class="line"><span class="comment">// 重命名导入变量或者类型</span></span><br><span class="line"><span class="keyword">import</span> &#123; someVar <span class="keyword">as</span> aDifferentName &#125; <span class="keyword">from</span> <span class="string">'./foo'</span>;</span><br><span class="line"><span class="comment">// 使用整体加载</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> foo <span class="keyword">from</span> <span class="string">'./foo'</span>; <span class="comment">// 你可以这样使用foo.someVar了</span></span><br><span class="line"><span class="comment">// 仅导入模块</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'core-js'</span>; <span class="comment">//工具库</span></span><br><span class="line"><span class="comment">// 从其他模块导入后整体导出：</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./foo'</span>;</span><br><span class="line"><span class="comment">// 从其他模块导入后，部分导出</span></span><br><span class="line"><span class="keyword">export</span> &#123; someVar &#125; <span class="keyword">from</span> <span class="string">'./foo'</span>;</span><br></pre></td></tr></table></figure></div></li><li><p>使用默认导入/导出 <code>export default</code></p><blockquote><p>使用<code>export defalut</code>与<code>export</code>的区别:</p><ol><li>导入使用时可以根据需要自定义导入命名,比如这样的语法<code>import someName from &#39;someModule&#39;</code></li><li>导出变量，函数，类不需要提前定义，比如<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (someVar = <span class="number">123</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">someFunction</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">someClass</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></div></li></ol></blockquote></li><li><p>重写类型的动态查找</p><blockquote><p>在项目里可以通过<code>declare module &#39;somePath&#39;</code>来声明一个全局模块的方式，用来解决查找模块路径的问题<br>全局类型声明写法</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局类型声明写法</span></span><br><span class="line"><span class="comment">// **暴露**</span></span><br><span class="line">declare <span class="built_in">module</span> <span class="string">'foo'</span> &#123;</span><br><span class="line"><span class="comment">// some variable declarations</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> bar: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// **引入**</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> foo <span class="keyword">from</span> <span class="string">'foo'</span>;</span><br></pre></td></tr></table></figure></div></blockquote><blockquote><p>模块导出声明写法</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模块导出声明写法</span></span><br><span class="line">declare interface funcAbcSign &#123;</span><br><span class="line">    (s: string): string</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> declare <span class="keyword">let</span> abc: funcAbcSign;</span><br><span class="line"><span class="keyword">export</span> declare <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 引入</span></span><br><span class="line"><span class="function"><span class="title">import</span> </span>&#123;funcAbcSign,abc&#125; <span class="keyword">from</span> <span class="string">'foo'</span>;</span><br></pre></td></tr></table></figure></div></blockquote><blockquote><p>全局类型声明里的名称将被引入整个 TypeScript 全局命名空间中，从引用这个 声明文件起就可以自由使用。<br>模块导出声明里的名称必须通过 import/require 才能使用。</p></blockquote></li></ul><h4 id="提升篇"><a href="#提升篇" class="headerlink" title="提升篇"></a>提升篇</h4><h5 id="介绍一下你了解的排序方式"><a href="#介绍一下你了解的排序方式" class="headerlink" title="介绍一下你了解的排序方式"></a>介绍一下你了解的排序方式</h5><h6 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h6><blockquote><p>冒泡排序是一种非常简单的排序方式，这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。<br>排序基本思想为循环序列内每一个元素，循环到的元素与相邻的元素作对比，每次循环会将最小或者最大值冒泡至最底部，直到整个循环结束。</p></blockquote><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>,l=arr.length;i&lt;l;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;l<span class="number">-1</span>-i;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">let</span> tmp = arr[j+<span class="number">1</span>];</span><br><span class="line">            arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">            arr[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><blockquote><p>改进冒泡排序: 设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。<br>改进后如下</p></blockquote><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = arr.length<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">            pos = j;</span><br><span class="line">            <span class="keyword">var</span> tmp = arr[j];</span><br><span class="line">            arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">            arr[j+<span class="number">1</span>] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    i = pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h6 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h6><blockquote><p>选择排序是一种简单直观的排序算法，它的原理是:首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p></blockquote><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tmp,minIndex;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>,l=arr.length;i&lt;l<span class="number">-1</span>;i++)&#123;</span><br><span class="line">     minIndex = i;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">let</span> j=i+<span class="number">1</span>;j&lt;l;j++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(arr[j]&lt;arr[minIndex])&#123;</span><br><span class="line">             minIndex = j;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     tmp = arr[i];</span><br><span class="line">     arr[i] = arr[minIndex];</span><br><span class="line">     arr[minIndex] = tmp;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div><h6 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h6><blockquote><p>插入排序的远离应该是最容易理解的了，就像打扑克牌，摸到牌以后，你需要对牌进行从小到大的排序，如果你打扑克从不排序，那当我没说…<br>它的工作原理是，构造一个有序序列，然后拿未排序的数据在已排序序列中从后向前扫描，找到相应位置插入。</p></blockquote><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="JS"><figure class="iseeu highlight /js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>,l=arr.length;i&lt;l;i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> key = arr[i];</span><br><span class="line">    <span class="keyword">var</span> j = i<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; arr[j]&gt;key)&#123;</span><br><span class="line">        arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[j+<span class="number">1</span>]=key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>未完待续…</p>]]></content>
    
    <summary type="html">
    
      前端面试总结
    
    </summary>
    
      <category term="面试" scheme="http://blog.zijunfe.cn/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>如何给自己的博客添加评论系统</title>
    <link href="http://blog.zijunfe.cn/blog-comments.html"/>
    <id>http://blog.zijunfe.cn/blog-comments.html</id>
    <published>2019-04-11T07:48:32.310Z</published>
    <updated>2019-04-28T06:20:04.044Z</updated>
    
    <content type="html"><![CDATA[<p>想要做一个骚气的博主，没有一个评论系统怎么行呢</p><p><div style="width:170px;margin:0 auto;"><img src="/sao.gif" alt="你好骚啊"></div><br>打开我的Google复制一下别人的，<br>呸，<br>打开我的Google搜索一下前辈们的经验。<br><a id="more"></a><br>首先，我了解到的是next官网推荐的几种评论插件，分别是以下这几个哥们<br><code>DISQUS</code> <code>Facebook Comments</code> <code>HyperComments</code> <code>网易云跟帖</code> <code>来必力</code></p><p><div style="width:170px;margin:0 auto;"><img src="/emm.jpg" alt="emm"></div><br>从名字上来说，我选择最后一个试一下(绝对不是我看不懂别人官网，绝对不是!)</p><h4 id="来必力"><a href="#来必力" class="headerlink" title="来必力"></a>来必力</h4><p>来必力(这特喵的居然是个韩文网站) 这款评论系统比较简单，首先要去人家官网注册一个账号，登陆以后根据提示申请一个免费的city版什么鬼的，然后在代码里能得到一串LiveRe UID，在next 的<code>_config.yml</code>文件里编辑<code>livere_uid</code>字段，就完成啦，系不系很简单？效果如下<br><img src="/laibili.jpg" alt="来必力"><br>然后我觉得太丑了，不符合next的黑白简约主题，而且很大概率进入页面后需要重新刷新才能显示出来，所以我就放弃了。</p><p><div style="width:170px;margin:0 auto;"><img src="/xianqi.jpg" alt="嫌弃"></div></p><h4 id="Gitment"><a href="#Gitment" class="headerlink" title="Gitment"></a>Gitment</h4><p>接下来我又在茫茫Google中搜索，然后找到了它，看介绍说是通过github提issue的方式来创建一个评论系统，看到github我嘴角疯狂上扬，符合我的气质，这个我看行，开搞！</p><ul><li><p>首先在<a href="https://github.com/settings/developers" target="_blank" rel="noopener">https://github.com/settings/developers</a>申请一个免费的application，根据提示填写如下内容，</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Application name：blog-comments  // 随便写啥，你能记住就好 </span><br><span class="line">Homepage URL：https://网站地址/  // 你的博客地址</span><br><span class="line">Application description：Blog comment system  // 随便写</span><br><span class="line">Authorization callback URL：https://网站地址/  // 你的博客地址</span><br></pre></td></tr></table></figure></div><p> 创建完成后先不要关闭，<code>client_id</code>与<code>client_secret</code>下面要用</p></li><li>接着在你的github新建一个空的仓库来存放评论，比如叫做<code>blog-comments</code></li><li>然后在主题配置文件<code>_config.yml</code>里填写gitment的相关配置<div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">gitment:</span><br><span class="line">  enable: true  // 这个改成true</span><br><span class="line">  mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway</span><br><span class="line">  count: true # Show comments count in post meta area</span><br><span class="line">  lazy: false # Comments lazy loading with a button</span><br><span class="line">  cleanly: false # Hide &apos;Powered by ...&apos; on footer, and more</span><br><span class="line">  language: zh-Hans # Force language, or auto switch by theme</span><br><span class="line">  github_user: BiYangJun # MUST HAVE, Your Github ID</span><br><span class="line">  github_repo: blog-comments # MUST HAVE, The repo you use to store Gitment comments 这是你新建的存放评论的库</span><br><span class="line">  client_id: # MUST HAVE, Github client id for the Gitment 刚刚创建application里有的</span><br><span class="line">  client_secret: # EITHER this or proxy_gateway, Github access secret token for the Gitment 刚刚创建application里有的</span><br><span class="line">  proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect</span><br><span class="line">  redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled</span><br></pre></td></tr></table></figure></div></li></ul><p>全部配置完后，一切看起来很顺利，页面底部也出来了评论框，就差最后一步登陆自己的github来初始化了，一开始本地登陆不了，我以为是要部署后才能登陆，然后我部署了上去，心里想着这下成了!</p><p><div style="width:170px;margin:0 auto;"><img src="/shangyang.jpg" alt="嘴角上扬"></div><br>部署后，我点击登陆后，一直给我报错<code>[object ProgressEvent]</code>，试了很多次，我还一度怀疑是不是我github密码输错了，纳闷的我去看了一下gitment的issue，最后发现原因大概是gitment的网站证书到期了，gitment需要这个为接口，所以一直报错。<br>辛辛苦苦1小时，我…</p><p><div style="width:170px;margin:0 auto;" center><img src="/wufuckshuo.jpg" alt="无话可说"></div><br>哎，接着在茫茫Google找吧…</p><h4 id="Gitalk"><a href="#Gitalk" class="headerlink" title="Gitalk"></a>Gitalk</h4><p>接着，在茫茫博客中，我发现了<a href="https://www.lizhechen.com/" target="_blank" rel="noopener">戳兔专家</a>这位大哥的博文，跟着他的教程开始了安装<code>Gitalk</code>,帖个<a href="https://github.com/gitalk/gitalk" target="_blank" rel="noopener">官网</a>。</p><h5 id="首先"><a href="#首先" class="headerlink" title="首先"></a>首先</h5><p>刚刚申请的application和新建存放评论的仓库不要丢，裹上鸡蛋液，放在油锅里炸一炸，隔壁小孩…<br>住嘴！<br>由于next还没有集成gitalk，所以配置起来相当繁琐</p><ul><li>首先还是要在github上申请一个application和新建一个存放评论的仓库(上面的就可以用)</li><li><p>在 /layout/_third-party/comments/ 目录下新建 gitalk.swig 文件，内容如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if page.comments &amp;&amp; theme.gitalk.enable %&#125;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/gitalk/dist/gitalk.css&quot;&gt;</span><br><span class="line">    &lt;script src=&quot;https://unpkg.com/gitalk/dist/gitalk.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        var gitalk = new Gitalk(&#123;</span><br><span class="line">          clientID: &apos;&#123;&#123; theme.gitalk.ClientID &#125;&#125;&apos;,</span><br><span class="line">          clientSecret: &apos;&#123;&#123; theme.gitalk.ClientSecret &#125;&#125;&apos;,</span><br><span class="line">          repo: &apos;&#123;&#123; theme.gitalk.repo &#125;&#125;&apos;,</span><br><span class="line">          owner: &apos;&#123;&#123; theme.gitalk.owner &#125;&#125;&apos;,</span><br><span class="line">          admin: [&apos;&#123;&#123; theme.gitalk.adminUser &#125;&#125;&apos;],</span><br><span class="line">          id: location.pathname,</span><br><span class="line">          distractionFreeMode: &apos;&#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;&apos;</span><br><span class="line">        &#125;)</span><br><span class="line">        gitalk.render(&apos;gitalk-container&apos;)           </span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></div></li><li><p>修改 /layout/_partials/comments.swig，在最后一个 elseif 后添加字段，修改后如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> &#123;% elseif theme.gitment.enable %&#125;</span><br><span class="line">    &lt;div class=&quot;comments&quot; id=&quot;comments&quot;&gt;</span><br><span class="line">      &#123;% if theme.gitment.lazy %&#125;</span><br><span class="line">        &lt;div onclick=&quot;showGitment()&quot; id=&quot;gitment-display-button&quot;&gt;&#123;&#123; __(&apos;gitmentbutton&apos;) &#125;&#125;&lt;/div&gt;</span><br><span class="line">        &lt;div id=&quot;gitment-container&quot; style=&quot;display:none&quot;&gt;&lt;/div&gt;</span><br><span class="line">      &#123;% else %&#125;</span><br><span class="line">        &lt;div id=&quot;gitment-container&quot;&gt;&lt;/div&gt;</span><br><span class="line">      &#123;% endif %&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &#123;% elseif theme.valine.appid and theme.valine.appkey %&#125;</span><br><span class="line">    &lt;div class=&quot;comments&quot; id=&quot;comments&quot;&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  </span><br><span class="line">  &#123;% elseif theme.gitalk.enable %&#125;</span><br><span class="line">    &lt;div id=&quot;gitalk-container&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></div></li><li><p>修改 /layout/_third-party/comments/index.swig，在其末尾添加如下字段：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% include &apos;gitalk.swig&apos; %&#125;</span><br></pre></td></tr></table></figure></div></li><li><p>设置 gitalk 的样式，参考1： 在 /source/css/_common/components/third-party/ 目录下新建 gitalk.styl 文件，内容如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.gt-header a, .gt-comments a, .gt-popup a</span><br><span class="line">  border-bottom: none;</span><br><span class="line">.gt-container .gt-popup .gt-action.is--active:before</span><br><span class="line">  top: 0.7em;</span><br></pre></td></tr></table></figure></div></li><li><p>修改 /source/css/_common/components/third-party/third-party.styl 文件，在末尾添加如下字段：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;gitalk&quot;;</span><br></pre></td></tr></table></figure></div></li><li><p>最后在主题配置文件 _config.yml 中添加如下项：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gitalk:</span><br><span class="line">  enable: true</span><br><span class="line">  owner: 你的github帐号  # lzcwr  </span><br><span class="line">  repo: 存放评论的仓库名称   # Gitalk-comments</span><br><span class="line">  ClientID: 在申请好application的页面中有</span><br><span class="line">  ClientSecret: 在申请好application的页面中有</span><br><span class="line">  adminUser: 你的github帐号 # 可初始化评论的账户</span><br><span class="line">  distractionFreeMode: true</span><br></pre></td></tr></table></figure></div></li></ul><p>完整无误地完成上述步骤后，在本地可以看到gitalk的按钮，然后通过<code>hexo d</code>部署到线上后，登陆你的github进行初始化就大功告成了啦！</p><blockquote><p>如果你给一篇博文的文件命名有中文的话，你可能会碰到这个报错Error: Validation Failed。哎，真是一波三折啊</p></blockquote><h5 id="Error-Validation-Failed-解决方案"><a href="#Error-Validation-Failed-解决方案" class="headerlink" title="Error: Validation Failed 解决方案"></a>Error: Validation Failed 解决方案</h5><ol><li><p>修改前文提到的<code>gitalk.swig</code>，先下载一个<a href="https://github.com/blueimp/JavaScript-MD5/blob/master/js/md5.min.js" target="_blank" rel="noopener">md5.js</a>,更改完毕后的<code>gitalk.swig</code>如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if page.comments &amp;&amp; theme.gitalk.enable %&#125;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/gitalk/dist/gitalk.css&quot;&gt;</span><br><span class="line">    &lt;script src=&quot;/js/md5.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;https://unpkg.com/gitalk/dist/gitalk.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        var gitalk = new Gitalk(&#123;</span><br><span class="line">          clientID: &apos;&#123;&#123; theme.gitalk.ClientID &#125;&#125;&apos;,</span><br><span class="line">          clientSecret: &apos;&#123;&#123; theme.gitalk.ClientSecret &#125;&#125;&apos;,</span><br><span class="line">          repo: &apos;&#123;&#123; theme.gitalk.repo &#125;&#125;&apos;,</span><br><span class="line">          owner: &apos;&#123;&#123; theme.gitalk.owner &#125;&#125;&apos;,</span><br><span class="line">          admin: [&apos;&#123;&#123; theme.gitalk.adminUser &#125;&#125;&apos;],</span><br><span class="line">          id: md5(location.pathname),</span><br><span class="line">          distractionFreeMode: &apos;&#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;&apos;</span><br><span class="line">        &#125;)</span><br><span class="line">        gitalk.render(&apos;gitalk-container&apos;)           </span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></div></li><li><p>批量修改博客文件名，例如以时间戳的方式命名md文件，具体可以参考这位<a href="https://blog.lanthora.org/20181229230044/" target="_blank" rel="noopener">大哥的博文</a></p></li><li>避免使用中文命名，英文不好咱们就用拼音吧！</li></ol><p>忙活了一晚上我的评论系统终于搞定了…</p><p><div style="width:170px;margin:0 auto;"><img src="/geyou.gif" alt="葛优"></div><br>感谢万能的Google和<a href="https://www.lizhechen.com/" target="_blank" rel="noopener">戳兔专家</a>这位大哥。<br>看完的小伙伴记得评论、关注、收藏三连哦～<br>呸、<br>什么坏毛病<br>能给评论就感激不尽啦～</p>]]></content>
    
    <summary type="html">
    
      使用hexo搭建的博客添加评论系统
    
    </summary>
    
      <category term="博客" scheme="http://blog.zijunfe.cn/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
  </entry>
  
  <entry>
    <title>记录一下搭建第一个博客的经历</title>
    <link href="http://blog.zijunfe.cn/first-blog.html"/>
    <id>http://blog.zijunfe.cn/first-blog.html</id>
    <published>2019-04-10T03:42:33.791Z</published>
    <updated>2019-04-28T06:20:04.033Z</updated>
    
    <content type="html"><![CDATA[<p>  起因，在论坛闲逛的时候发现一个老哥把很多知识点，问题都记录在自己的个人博客里，知识罗列的很清楚。<br>虽然我平时也会把一些问题和有趣的东西记录在MacDown里，可时如果要看的话还需要打开mac，很不方便。so～在网上找了一篇搭建博客的教程，干了一晚上终于成了，中间碰到很多曲折的问题，所以在这里记录一下。</p><p><strong>一、搭建条件及环境</strong><br>    Github Pages + Hexo + Node.js Mac电脑的OSX系统/windows<br><strong>二、搭建步骤</strong><br><a id="more"></a></p><ol><li><p>首先你得有个github账号(作为新时代的码农，这是必备的)，创建一个新的repository，项目名称格式为<code>yourname.github.io</code>，如图<br> <img src="/img1.jpg" alt></p></li><li><p>全局安装Hexo，<code>npm install -g hexo-cli</code></p></li><li><p>创建一个空文件夹，进入该文件夹，依次执行以下命令</p> <div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></div><p> 在所有依赖都安装完成后，就可以在本地环境看一下hexo的博客内容啦，执行以下命令</p> <div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate  </span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure></div><p> 这两条命令可以缩写成<code>hexo g</code> <code>hexo s</code>作用分别是：将md文件生成html，css文件；启动本地hexo。打开<a href="http://localhost:4000就能看到本地效果啦。" target="_blank" rel="noopener">http://localhost:4000就能看到本地效果啦。</a></p></li><li><p>修改 _config.yml 文件，这是博客网站 的配置文件，在这里你可以更改你的网页title，description等，最主要的是修改你在github上的仓库地址。<br> 在最下面一行</p> <div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repository: git@github.com:BiYangJun/zijun.github.io.git</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure></div><p> 写上自己的仓库地址。至于是SSH公钥方式提交还是https方式提交，看个人喜好啦。</p></li><li><p>在写完自己的博客后，执行以下命令</p> <div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></div><p> <code>hexo deploy</code> 可以缩写成 <code>hexo d</code>意思为部署<br> 接着你会上传文件到github上。接着就可以在线访问啦。</p></li><li><p>那么如何在线访问呢？<br> 打开你的github。点击<code>environment</code>，<br> <img src="/img5.jpg" alt><br> 然后在点击 <code>View deployment</code>,打开后的网址就是你的线上博客地址辣，easy～</p></li></ol><p><strong>三、遇到的坑</strong></p><ol><li><p>如果发现线上博客一直是404，看一下repository中的setting，在GitHub Pages 这一栏中Source有没有选中master分支</p><p> <img src="/img2.jpg" alt></p></li><li><p>能打开线上博客后，如果发现样式没有加载出来，在_config.yml修改root为自己的项目名称</p><p> <img src="/img3.jpg" alt></p></li><li><p>其他hexo命令。<code>hexo clean</code>#缓存，在网页不正常的时候可以使用。<code>hexo new ‘我的博客’</code>#新建我的博客，<code>hexo server -p 5000</code>#更改端口</p></li><li><p>如何插入图片。</p><ul><li>在主题的source下面新建一个文件夹images专门放置图片资源，使用markdown的语法 <code>![](/images/test.jpg)</code></li><li>Hexo方式，设置_config.yml文件中<code>post_asset_folder</code>为true，之后新建一个文章后，会同时创建一个同名的空文件夹用来放图片资源，执行命令<code>npm install hexo-asset-image --save</code>，下载安装一个可以上传本地图片的插件，之后使用的时候，只需要图片名<code>![](test.jpg)</code></li><li>网络图片插入‘#’</li><li><p>Hexo 支持使用特定的语法，插入指定大小的图片，如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 语法</span><br><span class="line">&#123;% img [class names] /path/to/image [width] [height] [title text [alt text]] %&#125;</span><br><span class="line">// 实例</span><br><span class="line">&#123;% img full-image /hexo-experiences/PL01.jpg 180 180 hello %&#125;</span><br><span class="line">// 生成的代码</span><br><span class="line">&lt;img src=&quot;/blog/hexo-experiences/PL01.jpg&quot; class=&quot;full-image&quot; width=&quot;180&quot; height=&quot;180&quot; title=&quot;hello&quot;&gt;</span><br></pre></td></tr></table></figure></div></li><li><p>如果发现怎么都不行，看下你这个博客是不是在二级域名下的，如果是，要设置_config.yml文件中的url与root。<br><img src="/img4.jpg" alt></p></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      使用hexo搭建博客
    
    </summary>
    
      <category term="博客" scheme="http://blog.zijunfe.cn/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
  </entry>
  
</feed>
