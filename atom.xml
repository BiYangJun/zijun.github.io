<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>子君的个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.zijunfe.cn/"/>
  <updated>2019-04-20T10:03:43.771Z</updated>
  <id>http://blog.zijunfe.cn/</id>
  
  <author>
    <name>Zi Jun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Nginx初体验</title>
    <link href="http://blog.zijunfe.cn/2019/04/20/nginx/"/>
    <id>http://blog.zijunfe.cn/2019/04/20/nginx/</id>
    <published>2019-04-20T09:48:24.000Z</published>
    <updated>2019-04-20T10:03:43.771Z</updated>
    
    <content type="html"><![CDATA[<p>  在有了自己的服务器后，不好好玩玩Nginx怎么行呢！<del>毕竟花了钱的</del><br>正好之前在学习<code>TypeScript</code>的时候，自己在github上有一个项目，所以想把这个项目丢到线上去玩玩～<br>目标: 将github上的项目丢进服务器，并且能够正确访问 <a href="http://www.zijunfe.cn" target="_blank" rel="noopener">www.zijunfe.cn</a>;<br>前端要学习的东西真的很多，不过我们的征途是星辰大海！<br><del>学习使我秃头</del></p><a id="more"></a><h4 id="如何在CentOS服务器里下载Nginx"><a href="#如何在CentOS服务器里下载Nginx" class="headerlink" title="如何在CentOS服务器里下载Nginx"></a>如何在CentOS服务器里下载Nginx</h4><ol><li><p>下载<code>epel-release</code></p><blockquote><p>EPEL (Extra Packages for Enterprise Linux)是基于Fedora的一个项目，为“红帽系”的操作系统提供额外的软件包，适用于RHEL、CentOS和Scientific Linux.</p></blockquote> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install epel-release</span><br></pre></td></tr></table></figure></li><li><p>下载nginx</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install nginx</span><br></pre></td></tr></table></figure></li><li><p>Nginx 开机启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable nginx</span><br></pre></td></tr></table></figure><blockquote><p>Systemctl是一个systemd工具，主要负责控制systemd系统和服务管理器。<br>Nginx 关闭开机启动</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">关闭开机启动 Nginx</span><br></pre></td></tr></table></figure></li><li><p>启动 Nginx</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start nginx</span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><p>检查 Nginx 的运行状态</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status nginx</span><br></pre></td></tr></table></figure></li><li><p>如果你的服务器开启了防火墙，则需要同时打开 80（HTTP）和 443（HTTPS）端口,通过下面的命令来打开这两个端口：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --permanent --zone=public --add-service=http</span><br><span class="line">sudo firewall-cmd --permanent --zone=public --add-service=https</span><br><span class="line">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure></li><li><p>验证 Nginx 是否成功启动，可以在浏览器中打开 <a href="http://YOUR_IP，您将看到默认的" target="_blank" rel="noopener">http://YOUR_IP，您将看到默认的</a> Nginx 欢迎页面</p></li><li><p>停止Nginx</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop nginx</span><br></pre></td></tr></table></figure></li></ol><ol start="9"><li><p>重启Nginx</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart nginx</span><br></pre></td></tr></table></figure></li><li><p>修改 Nginx 配置后，重新加载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl reload nginx</span><br></pre></td></tr></table></figure></li></ol><h5 id="如何免密登陆服务器"><a href="#如何免密登陆服务器" class="headerlink" title="如何免密登陆服务器"></a>如何免密登陆服务器</h5><ol><li>把自己电脑的私钥复制出来，例如在mac里私钥在<code>～/.ssh/*.pub</code>文件里，如果没有私钥和公钥，可以先生成，如何生成，执行<code>ssh-keygen</code>,一路回车。</li><li>登陆服务器，把刚刚复制的私钥放入 服务器<code>~/.ssh/authorized_keys</code>文件中</li><li>执行命令<code>ssh-add k id_rsa</code>,<code>id_rsa</code>就是那个以<code>.pub</code>结尾的文件名，如果执行报错，则先执行命令<code>ssh-agent bashen</code>,再执行添加命令</li><li>进入服务器只需要执行<code>ssh root@ip地址</code>就能免密登陆啦！</li></ol><h5 id="如何添加nginx代理文件"><a href="#如何添加nginx代理文件" class="headerlink" title="如何添加nginx代理文件"></a>如何添加nginx代理文件</h5><ol><li>在<code>etc/nginx/conf.d</code>中新增以<code>.conf</code>结尾的配置文件，比如你的域名叫做<code>zijunfe.cn</code>，那最好新增的文件名就叫<code>zijunfe-cn.conf</code>作为文件名。</li><li><p><code>vim *.conf</code>进入文件，添加配置，如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line"> listen 80;</span><br><span class="line"> server_name www.zijunfe.cn;</span><br><span class="line"> root /www/typescript-project/dist;</span><br><span class="line"> index index.html;</span><br><span class="line"> location ~* ^.+\.(jpg|jpeg|gif|png|ico|css|js|pdf|txt)&#123;</span><br><span class="line">  root /www/typescript-project/dist;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 保存退出。</p></li><li>执行命令<code>nginx -t</code>看看配置有没有报错，执行<code>nginx -s reload</code>重启nginx服务。</li><li>如果执行完以上操作后发现访问网址没有变化，可以在访问<code>etc/nginx/nginx.conf</code>文件，找到<code>include /usr/share/nginx/modules/*.conf;</code>,将它放到文件最后，然后重新启动nginx服务。</li></ol><h5 id="如何在服务器上下载nodejs"><a href="#如何在服务器上下载nodejs" class="headerlink" title="如何在服务器上下载nodejs"></a>如何在服务器上下载nodejs</h5><ol><li><p>在服务器上找一个文件夹，比如在<code>/</code>新建<code>app</code>文件夹</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir app &amp;&amp; cd app</span><br></pre></td></tr></table></figure></li><li><p>下载对应版本的nodejs版本，我的服务器系统centos，也就是Linux 64位的，nodejs建议下载稳定版本，在<code>app</code>文件夹里执行命令。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -c https://nodejs.org/dist/v10.14.2/node-v10.14.2-linux-x64.tar.xz</span><br></pre></td></tr></table></figure></li><li><p>解压文件夹</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf node-v10.14.2-linux-x64.tar.xz</span><br></pre></td></tr></table></figure></li><li><p>为了美观，对解压后的文件夹进行改名</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv node-v10.14.2-linux-x64 nodejs</span><br></pre></td></tr></table></figure></li><li><p>建立node,npm软连接</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /app/nodejs/bin/node /usr/local/bin/node</span><br><span class="line">sudo ln -s /app/nodejs/bin/npm /usr/local/bin/npm</span><br></pre></td></tr></table></figure></li><li><p>检查是否安装成功，执行<code>node -v</code>，如果有版本号，则安装成功，如果报错，看一下是不是建立软连接的时候，对应的路径有没有写正确。</p></li></ol><p>未完待续</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  在有了自己的服务器后，不好好玩玩Nginx怎么行呢！&lt;del&gt;毕竟花了钱的&lt;/del&gt;&lt;br&gt;正好之前在学习&lt;code&gt;TypeScript&lt;/code&gt;的时候，自己在github上有一个项目，所以想把这个项目丢到线上去玩玩～&lt;br&gt;目标: 将github上的项目丢进服务器，并且能够正确访问 &lt;a href=&quot;http://www.zijunfe.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;www.zijunfe.cn&lt;/a&gt;;&lt;br&gt;前端要学习的东西真的很多，不过我们的征途是星辰大海！&lt;br&gt;&lt;del&gt;学习使我秃头&lt;/del&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Nginx" scheme="http://blog.zijunfe.cn/categories/Nginx/"/>
    
    
  </entry>
  
  <entry>
    <title>面试</title>
    <link href="http://blog.zijunfe.cn/2019/04/12/interview/"/>
    <id>http://blog.zijunfe.cn/2019/04/12/interview/</id>
    <published>2019-04-12T01:57:39.000Z</published>
    <updated>2019-04-20T10:06:51.592Z</updated>
    
    <content type="html"><![CDATA[<p> 这两天面试了一些前端同行，面试别人同样是宝贵的经验，因为在问别人的同时，自己也会思考，这题的答案是什么，除了这种解法还有没有其他解法呢？所以这篇博文，我把自己问的问题作一个归纳与总结，并分为三个层次，<strong>基础</strong>，<strong>提升</strong>，<strong>高级</strong>，并且写一些比较冷门的前端知识。</p><a id="more"></a><h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><h4 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h4><h5 id="vue-rouer有几种模式，区别是什么？"><a href="#vue-rouer有几种模式，区别是什么？" class="headerlink" title="vue-rouer有几种模式，区别是什么？"></a><code>vue-rouer</code>有几种模式，区别是什么？</h5><blockquote><p>两种模式，hash模式与history模式 ，<code>vue-router</code>默认使用hash模式，hash模式的url格式一般为<code>http://.../#/...</code>,history模式则没有<code>/#/</code>，并且history模式需要后端配合，因为vue一般写的是单页面应用，如果后端没有正确的配置，用户直接访问<code>http://oursite.com/user/id</code>则回提示404错误。</p></blockquote><h5 id="vue-router路由传参有几种方法？"><a href="#vue-router路由传参有几种方法？" class="headerlink" title="vue-router路由传参有几种方法？"></a><code>vue-router</code>路由传参有几种方法？</h5><blockquote><p>通过<code>params</code>或<code>query</code>传参，前者参数不在url上显示，刷新页面会丢失参数，后者会在url上显示，刷新页面不会丢失参数。<br>路由的动态传参，这种方式首先要在<code>router.js</code>中配置路由对应的path为<code>{ path: &#39;/user/:id&#39;, component: User }</code>这种格式，在对应得页面可以通过<code>this.$route.params</code>来获取对应的参数。</p></blockquote><h5 id="vue-router的导航守卫有哪些？"><a href="#vue-router的导航守卫有哪些？" class="headerlink" title="vue-router的导航守卫有哪些？"></a><code>vue-router</code>的导航守卫有哪些？</h5><blockquote><p>前置守卫:<code>router.beforeEach</code>(常用)当一个导航触发时，全局前置守卫按照创建顺序调用<br>解析守卫:<code>router.beforeResolve</code>(不常用)与前置守卫相识，区别在于导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。<br>后置守卫:<code>router.afterEach</code>(不常用)不会接受 next 函数也不会改变导航本身：<br>独享守卫:<code>beforeEnter</code>(不常用)在路由配置里定义，用来对单独的路由作处理<br>守卫一般有三个参数</p><ol><li><code>to:Route</code>:即将要进入的目标 路由对象</li><li><code>from: Route</code>:当前导航正要离开的路由</li><li><code>next: Function</code>:必须调用的跳转方法，否则不会进行路由跳转</li></ol></blockquote><h5 id="简单介绍一下vue-的生命周期函数？"><a href="#简单介绍一下vue-的生命周期函数？" class="headerlink" title="简单介绍一下vue 的生命周期函数？"></a>简单介绍一下vue 的生命周期函数？</h5><blockquote><p><strong>beforeCreate</strong>: 初始化之前的函数，vue实例不可访问，data未定义，一个基本不怎么用的函数<br><strong>created</strong>: 初始化函数，data已被定义，可以访问data里的数据，可以进行绑定，判断是否有<code>el</code>选项，有则继续进行，没有则停止编译(生命周期停止)，直到在该vue实例上调用vm.$mount(el)。接着判断是否有<code>template</code>选项，如果有，则会将<code>template</code>作为模板编译成render函数，如果没有，则将外部HTML作为模板编译。如果同时存在，<code>template</code>模版优先级是高于外部HTML的。同时vue对象中还有一个<code>render</code>函数，以createElement作为参数，然后做渲染操作，而且我们可以直接嵌入JSX，这个优先级是最高的。综上所述，模版优先级：<code>render</code>函数&gt;<code>template</code>模版&gt;外部HTML。<br><strong>beforeMount</strong>: 给vue添加$el成员，并且替换挂载的DOM元素。建立虚拟dom，data还是以参数名的方式挂载在节点中，没有注入数据。<br><strong>mounted</strong>: 第一次对组件进行渲染，将data里的数据注入节点中,这时已经形成了真实dom。这个函数vue的整个生命周期中只会执行一次，如果还有数据的变化，只会触发updated相关函数。<br><strong>beforeUpdate</strong>: 检测到data发生变化，准备对相应的组件再次渲染。首先重新渲染虚拟dom，再对真实的dom打补丁。<br><strong>updated</strong>: 完成对data发生变化的对应组件渲染<br><strong>beforeDestory</strong>: 实例销毁之前调用。在这一步，实例仍然完全可用。<br><strong>destoryed</strong>: 在Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。<br><strong>帖一张官方的生命周期图</strong><br><img src="/2019/04/12/interview/vue.png" alt="生命周期"></p></blockquote><h5 id="vuex的核心概念包括哪些内容。内容比较多，详情看vuex官网"><a href="#vuex的核心概念包括哪些内容。内容比较多，详情看vuex官网" class="headerlink" title="vuex的核心概念包括哪些内容。内容比较多，详情看vuex官网"></a><code>vuex</code>的核心概念包括哪些内容。内容比较多，详情看<a href="https://vuex.vuejs.org/zh/guide/modules.html" target="_blank" rel="noopener">vuex官网</a></h5><blockquote><p><code>state</code>:存放状态数据的字段，辅助函数<code>mapState</code><br><code>getter</code>:可以认为是 store 的计算属性,辅助函数<code>mapGetter</code><br><code>mutation</code>:更改store状态的唯一方法，必须是同步操作，辅助函数<code>mapMutation</code><br><code>action</code>:action类似于mutation,不过无法直接变更状态，需要通过提交mutation来更改，可以包含任意的异步操作，辅助函数<code>mapAction</code><br><code>module</code>:store的模块，每个模块拥有自己的state、mutation、action、getter、甚至是嵌套子模块。通过设置<code>namespaced: true</code>的方式使其成为带命名空间的模块，如果需要在带命名空间的模块访问全局内容，<code>rootState</code> 和 <code>rootGetter</code> 会作为第三和第四参数传入 getter，若需要在全局命名空间内分发 <code>action</code> 或提交 <code>mutation</code>，将 <code>{ root: true }</code> 作为第三参数传给 <code>dispatch</code> 或 <code>commit</code> 即可。</p></blockquote><h3 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h3><h4 id="基础篇-1"><a href="#基础篇-1" class="headerlink" title="基础篇"></a>基础篇</h4><h5 id="说一些与Array相关的api，并且挑几个详细说明它们的作用？"><a href="#说一些与Array相关的api，并且挑几个详细说明它们的作用？" class="headerlink" title="说一些与Array相关的api，并且挑几个详细说明它们的作用？"></a>说一些与<code>Array</code>相关的api，并且挑几个详细说明它们的作用？</h5><blockquote><p><code>concat</code>: 合并两个或多个数组，不会改变原数组，返回一个新数组<br><code>every</code>: 测试数组所有元素是否通过制定函数的测试<br><code>some</code>: 测试数组是否存在元素是否通过制定函数的测试<br><code>forEach</code>: 对数组的每个元素执行一次提供的函数。<br><code>reduce</code>:对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。第一个参数为执行函数，第二个参数为执行函数第一次调用时它第一个参数的值<br><code>map</code>: 创建一个新数组，结果为该数组每个元素调用函数的结果<br><code>filter</code>: 过滤，创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。<br><code>entries</code>: 返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对。<br><code>find</code>: 返回数组中满足提供的测试函数第一个元素的值<br><code>findIndex</code>: 返回数组中满足提供的测试函数第一个元素的索引，没有返回-1<br><code>flat</code>: 按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。（IE不支持该方法）<br><code>includes</code>: 判断一个数组是否包含一个指定的值<br><code>concat</code>: 合并两个或多个数组，不会改变原数组，返回一个新数组<br><code>join</code>: 将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。如果数组只有一个项目，那么将返回该项目而不使用分隔符。<br><code>splice</code>: 通过删除或替换现有元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。三个参数，start(指定下标)，deleteCount(移除的个数),[item1,item2,…]从start位置开始插入的元素。<br><code>slice</code>: 返回一个新的数组对象，这一对象是一个由 begin和 end（不包括end）决定的原数组的浅拷贝。原始数组不会被改变。<br><code>reverse</code>: 倒序<br><code>sort</code>: 排序<br><code>push</code>,<code>pop</code>,<code>shift</code>,<code>unshift</code> 数组堆栈操作</p></blockquote><h5 id="js的基础类型有哪些？"><a href="#js的基础类型有哪些？" class="headerlink" title="js的基础类型有哪些？"></a>js的基础类型有哪些？</h5><blockquote><p>String,Boolean,Number,Object,Undefined,Null,Symbol</p></blockquote><h5 id="var-let-const三种声明变量的方式有什么区别？"><a href="#var-let-const三种声明变量的方式有什么区别？" class="headerlink" title="var,let,const三种声明变量的方式有什么区别？"></a><code>var</code>,<code>let</code>,<code>const</code>三种声明变量的方式有什么区别？</h5><blockquote><p><code>var</code> 声明变量有变量提升的功能 能重复声明<br><code>let</code> 声明一个具有块级作用域的变量，不具备变量提升功能，重复声明会报错<br><code>const</code> 声明一个具有块级作用域的常量，并且常用大写字母作为变量名，不具备变量提升功能，重复声明会报错，重新赋值也会报错</p></blockquote><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><h4 id="基础篇-2"><a href="#基础篇-2" class="headerlink" title="基础篇"></a>基础篇</h4><h5 id="display-none与visibility-hidden与opacity-0-兼容写法filter：alpha-opacity-0-的区别"><a href="#display-none与visibility-hidden与opacity-0-兼容写法filter：alpha-opacity-0-的区别" class="headerlink" title="display:none与visibility:hidden与opacity:0(兼容写法filter：alpha(opacity=0))的区别?"></a><code>display:none</code>与<code>visibility:hidden</code>与<code>opacity:0</code>(兼容写法<code>filter：alpha(opacity=0)</code>)的区别?</h5><blockquote><p>他们都能让元素消失不见。<code>display:none</code>会让元素从渲染树中消失，渲染时不占任何空间，从而达到消失的目的。<code>visibility:hidden</code>与<code>opacity:0</code>只是让元素不可见，元素不会从渲染树消失不见，继续占据空间。<br><code>display:none</code>是非继承属性，元素直接消失了，修改子孙节点属性无法显示。<code>visibility:hidden</code>是继承属性，通过修改子孙属性<code>visibility:visible</code>可以让子孙节点<strong>显示</strong>。<br><code>opacity:0</code>，消失的原理是将元素的透明度设置为0，是继承属性，子孙节点通过设置<code>opacity:1</code><strong>无法显示</strong>，可以继续触发元素上绑定的事件。<br>修改元素的display通常会造成文档的回流，修改visibility与opacity属性只会造成本元素的重绘。</p></blockquote><h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><h4 id="基础篇-3"><a href="#基础篇-3" class="headerlink" title="基础篇"></a>基础篇</h4><h5 id="对手机号做加密处理，将中间四位数字用-代替"><a href="#对手机号做加密处理，将中间四位数字用-代替" class="headerlink" title="对手机号做加密处理，将中间四位数字用*代替"></a>对手机号做加密处理，将中间四位数字用<code>*</code>代替</h5><ol><li><p><code>replace</code>方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">phone.replace(<span class="regexp">/(?&lt;=.&#123;3&#125;).(?=.&#123;4&#125;)/g</span>,<span class="string">'*'</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>substring</code>方法,或<code>substr</code>方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">phone.substring(<span class="number">0</span>,<span class="number">3</span>)+<span class="string">'****'</span>+phone.substring(<span class="number">6</span>,<span class="number">4</span>)</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line">phone.substr(<span class="number">0</span>,<span class="number">3</span>)+<span class="string">'****'</span>+phone.substr(<span class="number">-4</span>)</span><br></pre></td></tr></table></figure></li><li><p>数组<code>splice</code>方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr=phone.split();arr.splice(<span class="number">3</span>,<span class="number">4</span>,<span class="string">'****'</span>);arr.join(<span class="string">''</span>)</span><br></pre></td></tr></table></figure></li></ol><h4 id="提升篇"><a href="#提升篇" class="headerlink" title="提升篇"></a>提升篇</h4><h5 id="介绍一下你了解的排序方式"><a href="#介绍一下你了解的排序方式" class="headerlink" title="介绍一下你了解的排序方式"></a>介绍一下你了解的排序方式</h5><h6 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h6><blockquote><p>冒泡排序是一种非常简单的排序方式，这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。<br>排序基本思想为循环序列内每一个元素，循环到的元素与相邻的元素作对比，每次循环会将最小或者最大值冒泡至最底部，直到整个循环结束。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>,l=arr.length;i&lt;l;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;l<span class="number">-1</span>-i;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">let</span> tmp = arr[j+<span class="number">1</span>];</span><br><span class="line">            arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">            arr[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>改进冒泡排序: 设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。<br>改进后如下</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = arr.length<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">            pos = j;</span><br><span class="line">            <span class="keyword">var</span> tmp = arr[j];</span><br><span class="line">            arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">            arr[j+<span class="number">1</span>] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    i = pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h6><blockquote><p>选择排序是一种简单直观的排序算法，它的原理是:首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tmp,minIndex;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>,l=arr.length;i&lt;l<span class="number">-1</span>;i++)&#123;</span><br><span class="line">     minIndex = i;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">let</span> j=i+<span class="number">1</span>;j&lt;l;j++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(arr[j]&lt;arr[minIndex])&#123;</span><br><span class="line">             minIndex = j;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     tmp = arr[i];</span><br><span class="line">     arr[i] = arr[minIndex];</span><br><span class="line">     arr[minIndex] = tmp;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h6 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h6><blockquote><p>插入排序的远离应该是最容易理解的了，就像打扑克牌，摸到牌以后，你需要对牌进行从小到大的排序，如果你打扑克从不排序，那当我没说…<br>它的工作原理是，构造一个有序序列，然后拿未排序的数据在已排序序列中从后向前扫描，找到相应位置插入。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>,l=arr.length;i&lt;l;i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> key = arr[i];</span><br><span class="line">    <span class="keyword">var</span> j = i<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; arr[j]&gt;key)&#123;</span><br><span class="line">        arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[j+<span class="number">1</span>]=key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未完待续…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 这两天面试了一些前端同行，面试别人同样是宝贵的经验，因为在问别人的同时，自己也会思考，这题的答案是什么，除了这种解法还有没有其他解法呢？所以这篇博文，我把自己问的问题作一个归纳与总结，并分为三个层次，&lt;strong&gt;基础&lt;/strong&gt;，&lt;strong&gt;提升&lt;/strong&gt;，&lt;strong&gt;高级&lt;/strong&gt;，并且写一些比较冷门的前端知识。&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="http://blog.zijunfe.cn/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>如何给自己的博客添加评论系统</title>
    <link href="http://blog.zijunfe.cn/2019/04/11/blog-comments/"/>
    <id>http://blog.zijunfe.cn/2019/04/11/blog-comments/</id>
    <published>2019-04-11T07:48:32.310Z</published>
    <updated>2019-04-20T10:32:16.661Z</updated>
    
    <content type="html"><![CDATA[<p>想要做一个骚气的博主，没有一个评论系统怎么行呢</p><p><div style="width:170px;margin:0 auto;"><img src="/2019/04/11/blog-comments/sao.gif" alt="你好骚啊"></div><br>打开我的Google复制一下别人的，<br>呸，<br>打开我的Google搜索一下前辈们的经验。<br><a id="more"></a><br>首先，我了解到的是next官网推荐的几种评论插件，分别是以下这几个哥们<br><code>DISQUS</code> <code>Facebook Comments</code> <code>HyperComments</code> <code>网易云跟帖</code> <code>来必力</code></p><p><div style="width:170px;margin:0 auto;"><img src="/2019/04/11/blog-comments/emm.jpg" alt="emm"></div><br>从名字上来说，我选择最后一个试一下(绝对不是我看不懂别人官网，绝对不是!)</p><h4 id="来必力"><a href="#来必力" class="headerlink" title="来必力"></a>来必力</h4><p>来必力(这特喵的居然是个韩文网站) 这款评论系统比较简单，首先要去人家官网注册一个账号，登陆以后根据提示申请一个免费的city版什么鬼的，然后在代码里能得到一串LiveRe UID，在next 的<code>_config.yml</code>文件里编辑<code>livere_uid</code>字段，就完成啦，系不系很简单？效果如下<br><img src="/2019/04/11/blog-comments/laibili.jpg" alt="来必力"><br>然后我觉得太丑了，不符合next的黑白简约主题，而且很大概率进入页面后需要重新刷新才能显示出来，所以我就放弃了。</p><p><div style="width:170px;margin:0 auto;"><img src="/2019/04/11/blog-comments/xianqi.jpg" alt="嫌弃"></div></p><h4 id="Gitment"><a href="#Gitment" class="headerlink" title="Gitment"></a>Gitment</h4><p>接下来我又在茫茫Google中搜索，然后找到了它，看介绍说是通过github提issue的方式来创建一个评论系统，看到github我嘴角疯狂上扬，符合我的气质，这个我看行，开搞！</p><ul><li><p>首先在<a href="https://github.com/settings/developers" target="_blank" rel="noopener">https://github.com/settings/developers</a>申请一个免费的application，根据提示填写如下内容，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Application name：blog-comments  // 随便写啥，你能记住就好 </span><br><span class="line">Homepage URL：https://网站地址/  // 你的博客地址</span><br><span class="line">Application description：Blog comment system  // 随便写</span><br><span class="line">Authorization callback URL：https://网站地址/  // 你的博客地址</span><br></pre></td></tr></table></figure><p> 创建完成后先不要关闭，<code>client_id</code>与<code>client_secret</code>下面要用</p></li><li>接着在你的github新建一个空的仓库来存放评论，比如叫做<code>blog-comments</code></li><li>然后在主题配置文件<code>_config.yml</code>里填写gitment的相关配置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">gitment:</span><br><span class="line">  enable: true  // 这个改成true</span><br><span class="line">  mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway</span><br><span class="line">  count: true # Show comments count in post meta area</span><br><span class="line">  lazy: false # Comments lazy loading with a button</span><br><span class="line">  cleanly: false # Hide &apos;Powered by ...&apos; on footer, and more</span><br><span class="line">  language: zh-Hans # Force language, or auto switch by theme</span><br><span class="line">  github_user: BiYangJun # MUST HAVE, Your Github ID</span><br><span class="line">  github_repo: blog-comments # MUST HAVE, The repo you use to store Gitment comments 这是你新建的存放评论的库</span><br><span class="line">  client_id: # MUST HAVE, Github client id for the Gitment 刚刚创建application里有的</span><br><span class="line">  client_secret: # EITHER this or proxy_gateway, Github access secret token for the Gitment 刚刚创建application里有的</span><br><span class="line">  proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect</span><br><span class="line">  redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled</span><br></pre></td></tr></table></figure></li></ul><p>全部配置完后，一切看起来很顺利，页面底部也出来了评论框，就差最后一步登陆自己的github来初始化了，一开始本地登陆不了，我以为是要部署后才能登陆，然后我部署了上去，心里想着这下成了!</p><p><div style="width:170px;margin:0 auto;"><img src="/2019/04/11/blog-comments/shangyang.jpg" alt="嘴角上扬"></div><br>部署后，我点击登陆后，一直给我报错<code>[object ProgressEvent]</code>，试了很多次，我还一度怀疑是不是我github密码输错了，纳闷的我去看了一下gitment的issue，最后发现原因大概是gitment的网站证书到期了，gitment需要这个为接口，所以一直报错。<br>辛辛苦苦1小时，我…</p><p><div style="width:170px;margin:0 auto;" center><img src="/2019/04/11/blog-comments/wufuckshuo.jpg" alt="无话可说"></div><br>哎，接着在茫茫Google找吧…</p><h4 id="Gitalk"><a href="#Gitalk" class="headerlink" title="Gitalk"></a>Gitalk</h4><p>接着，在茫茫博客中，我发现了<a href="https://www.lizhechen.com/" target="_blank" rel="noopener">戳兔专家</a>这位大哥的博文，跟着他的教程开始了安装<code>Gitalk</code>,帖个<a href="https://github.com/gitalk/gitalk" target="_blank" rel="noopener">官网</a>。</p><h5 id="首先"><a href="#首先" class="headerlink" title="首先"></a>首先</h5><p>刚刚申请的application和新建存放评论的仓库不要丢，裹上鸡蛋液，放在油锅里炸一炸，隔壁小孩…<br>住嘴！<br>由于next还没有集成gitalk，所以配置起来相当繁琐</p><ul><li>首先还是要在github上申请一个application和新建一个存放评论的仓库(上面的就可以用)</li><li><p>在 /layout/_third-party/comments/ 目录下新建 gitalk.swig 文件，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if page.comments &amp;&amp; theme.gitalk.enable %&#125;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/gitalk/dist/gitalk.css&quot;&gt;</span><br><span class="line">    &lt;script src=&quot;https://unpkg.com/gitalk/dist/gitalk.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        var gitalk = new Gitalk(&#123;</span><br><span class="line">          clientID: &apos;&#123;&#123; theme.gitalk.ClientID &#125;&#125;&apos;,</span><br><span class="line">          clientSecret: &apos;&#123;&#123; theme.gitalk.ClientSecret &#125;&#125;&apos;,</span><br><span class="line">          repo: &apos;&#123;&#123; theme.gitalk.repo &#125;&#125;&apos;,</span><br><span class="line">          owner: &apos;&#123;&#123; theme.gitalk.owner &#125;&#125;&apos;,</span><br><span class="line">          admin: [&apos;&#123;&#123; theme.gitalk.adminUser &#125;&#125;&apos;],</span><br><span class="line">          id: location.pathname,</span><br><span class="line">          distractionFreeMode: &apos;&#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;&apos;</span><br><span class="line">        &#125;)</span><br><span class="line">        gitalk.render(&apos;gitalk-container&apos;)           </span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改 /layout/_partials/comments.swig，在最后一个 elseif 后添加字段，修改后如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> &#123;% elseif theme.gitment.enable %&#125;</span><br><span class="line">    &lt;div class=&quot;comments&quot; id=&quot;comments&quot;&gt;</span><br><span class="line">      &#123;% if theme.gitment.lazy %&#125;</span><br><span class="line">        &lt;div onclick=&quot;showGitment()&quot; id=&quot;gitment-display-button&quot;&gt;&#123;&#123; __(&apos;gitmentbutton&apos;) &#125;&#125;&lt;/div&gt;</span><br><span class="line">        &lt;div id=&quot;gitment-container&quot; style=&quot;display:none&quot;&gt;&lt;/div&gt;</span><br><span class="line">      &#123;% else %&#125;</span><br><span class="line">        &lt;div id=&quot;gitment-container&quot;&gt;&lt;/div&gt;</span><br><span class="line">      &#123;% endif %&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &#123;% elseif theme.valine.appid and theme.valine.appkey %&#125;</span><br><span class="line">    &lt;div class=&quot;comments&quot; id=&quot;comments&quot;&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  </span><br><span class="line">  &#123;% elseif theme.gitalk.enable %&#125;</span><br><span class="line">    &lt;div id=&quot;gitalk-container&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改 /layout/_third-party/comments/index.swig，在其末尾添加如下字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% include &apos;gitalk.swig&apos; %&#125;</span><br></pre></td></tr></table></figure></li><li><p>设置 gitalk 的样式，参考1： 在 /source/css/_common/components/third-party/ 目录下新建 gitalk.styl 文件，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.gt-header a, .gt-comments a, .gt-popup a</span><br><span class="line">  border-bottom: none;</span><br><span class="line">.gt-container .gt-popup .gt-action.is--active:before</span><br><span class="line">  top: 0.7em;</span><br></pre></td></tr></table></figure></li><li><p>修改 /source/css/_common/components/third-party/third-party.styl 文件，在末尾添加如下字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;gitalk&quot;;</span><br></pre></td></tr></table></figure></li><li><p>最后在主题配置文件 _config.yml 中添加如下项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gitalk:</span><br><span class="line">  enable: true</span><br><span class="line">  owner: 你的github帐号  # lzcwr  </span><br><span class="line">  repo: 存放评论的仓库名称   # Gitalk-comments</span><br><span class="line">  ClientID: 在申请好application的页面中有</span><br><span class="line">  ClientSecret: 在申请好application的页面中有</span><br><span class="line">  adminUser: 你的github帐号 # 可初始化评论的账户</span><br><span class="line">  distractionFreeMode: true</span><br></pre></td></tr></table></figure></li></ul><p>完整无误地完成上述步骤后，在本地可以看到gitalk的按钮，然后通过<code>hexo d</code>部署到线上后，登陆你的github进行初始化就大功告成了啦！</p><blockquote><p>如果你给一篇博文的文件命名有中文的话，你可能会碰到这个报错Error: Validation Failed。哎，真是一波三折啊</p></blockquote><h5 id="Error-Validation-Failed-解决方案"><a href="#Error-Validation-Failed-解决方案" class="headerlink" title="Error: Validation Failed 解决方案"></a>Error: Validation Failed 解决方案</h5><ol><li><p>修改前文提到的<code>gitalk.swig</code>，先下载一个<a href="https://github.com/blueimp/JavaScript-MD5/blob/master/js/md5.min.js" target="_blank" rel="noopener">md5.js</a>,更改完毕后的<code>gitalk.swig</code>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if page.comments &amp;&amp; theme.gitalk.enable %&#125;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/gitalk/dist/gitalk.css&quot;&gt;</span><br><span class="line">    &lt;script src=&quot;/js/md5.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;https://unpkg.com/gitalk/dist/gitalk.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        var gitalk = new Gitalk(&#123;</span><br><span class="line">          clientID: &apos;&#123;&#123; theme.gitalk.ClientID &#125;&#125;&apos;,</span><br><span class="line">          clientSecret: &apos;&#123;&#123; theme.gitalk.ClientSecret &#125;&#125;&apos;,</span><br><span class="line">          repo: &apos;&#123;&#123; theme.gitalk.repo &#125;&#125;&apos;,</span><br><span class="line">          owner: &apos;&#123;&#123; theme.gitalk.owner &#125;&#125;&apos;,</span><br><span class="line">          admin: [&apos;&#123;&#123; theme.gitalk.adminUser &#125;&#125;&apos;],</span><br><span class="line">          id: md5(location.pathname),</span><br><span class="line">          distractionFreeMode: &apos;&#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;&apos;</span><br><span class="line">        &#125;)</span><br><span class="line">        gitalk.render(&apos;gitalk-container&apos;)           </span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></li><li><p>批量修改博客文件名，例如以时间戳的方式命名md文件，具体可以参考这位<a href="https://blog.lanthora.org/20181229230044/" target="_blank" rel="noopener">大哥的博文</a></p></li><li>避免使用中文命名，英文不好咱们就用拼音吧！</li></ol><p>忙活了一晚上我的评论系统终于搞定了…</p><p><div style="width:170px;margin:0 auto;"><img src="/2019/04/11/blog-comments/geyou.gif" alt="葛优"></div><br>感谢万能的Google和<a href="https://www.lizhechen.com/" target="_blank" rel="noopener">戳兔专家</a>这位大哥。<br>看完的小伙伴记得评论、关注、收藏三连哦～<br>呸、<br>什么坏毛病<br>能给评论就感激不尽啦～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想要做一个骚气的博主，没有一个评论系统怎么行呢&lt;/p&gt;
&lt;p&gt;&lt;div style=&quot;width:170px;margin:0 auto;&quot;&gt;&lt;img src=&quot;/2019/04/11/blog-comments/sao.gif&quot; alt=&quot;你好骚啊&quot;&gt;&lt;/div&gt;&lt;br&gt;打开我的Google复制一下别人的，&lt;br&gt;呸，&lt;br&gt;打开我的Google搜索一下前辈们的经验。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="博客" scheme="http://blog.zijunfe.cn/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
  </entry>
  
  <entry>
    <title>记录一下搭建第一个博客的经历</title>
    <link href="http://blog.zijunfe.cn/2019/04/10/first-blog/"/>
    <id>http://blog.zijunfe.cn/2019/04/10/first-blog/</id>
    <published>2019-04-10T03:42:33.791Z</published>
    <updated>2019-04-20T10:32:16.657Z</updated>
    
    <content type="html"><![CDATA[<p>  起因，在论坛闲逛的时候发现一个老哥把很多知识点，问题都记录在自己的个人博客里，知识罗列的很清楚。<br>虽然我平时也会把一些问题和有趣的东西记录在MacDown里，可时如果要看的话还需要打开mac，很不方便。so～在网上找了一篇搭建博客的教程，干了一晚上终于成了，中间碰到很多曲折的问题，所以在这里记录一下。</p><p><strong>一、搭建条件及环境</strong><br>    Github Pages + Hexo + Node.js Mac电脑的OSX系统/windows<br><strong>二、搭建步骤</strong><br><a id="more"></a></p><ol><li><p>首先你得有个github账号(作为新时代的码农，这是必备的)，创建一个新的repository，项目名称格式为<code>yourname.github.io</code>，如图<br> <img src="/2019/04/10/first-blog/img1.jpg" alt></p></li><li><p>全局安装Hexo，<code>npm install -g hexo-cli</code></p></li><li><p>创建一个空文件夹，进入该文件夹，依次执行以下命令</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p> 在所有依赖都安装完成后，就可以在本地环境看一下hexo的博客内容啦，执行以下命令</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate  </span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><p> 这两条命令可以缩写成<code>hexo g</code> <code>hexo s</code>作用分别是：将md文件生成html，css文件；启动本地hexo。打开<a href="http://localhost:4000就能看到本地效果啦。" target="_blank" rel="noopener">http://localhost:4000就能看到本地效果啦。</a></p></li><li><p>修改 _config.yml 文件，这是博客网站 的配置文件，在这里你可以更改你的网页title，description等，最主要的是修改你在github上的仓库地址。<br> 在最下面一行</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repository: git@github.com:BiYangJun/zijun.github.io.git</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure><p> 写上自己的仓库地址。至于是SSH公钥方式提交还是https方式提交，看个人喜好啦。</p></li><li><p>在写完自己的博客后，执行以下命令</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p> <code>hexo deploy</code> 可以缩写成 <code>hexo d</code>意思为部署<br> 接着你会上传文件到github上。接着就可以在线访问啦。</p></li><li><p>那么如何在线访问呢？<br> 打开你的github。点击<code>environment</code>，<br> <img src="/2019/04/10/first-blog/img5.jpg" alt><br> 然后在点击 <code>View deployment</code>,打开后的网址就是你的线上博客地址辣，easy～</p></li></ol><p><strong>三、遇到的坑</strong></p><ol><li><p>如果发现线上博客一直是404，看一下repository中的setting，在GitHub Pages 这一栏中Source有没有选中master分支</p><p> <img src="/2019/04/10/first-blog/img2.jpg" alt></p></li><li><p>能打开线上博客后，如果发现样式没有加载出来，在_config.yml修改root为自己的项目名称</p><p> <img src="/2019/04/10/first-blog/img3.jpg" alt></p></li><li><p>其他hexo命令。<code>hexo clean</code>#缓存，在网页不正常的时候可以使用。<code>hexo new ‘我的博客’</code>#新建我的博客，<code>hexo server -p 5000</code>#更改端口</p></li><li><p>如何插入图片。</p><ul><li>在主题的source下面新建一个文件夹images专门放置图片资源，使用markdown的语法 <code>![](/images/test.jpg)</code></li><li>Hexo方式，设置_config.yml文件中<code>post_asset_folder</code>为true，之后新建一个文章后，会同时创建一个同名的空文件夹用来放图片资源，执行命令<code>npm install hexo-asset-image --save</code>，下载安装一个可以上传本地图片的插件，之后使用的时候，只需要图片名<code>![](test.jpg)</code></li><li>网络图片插入‘#’</li><li><p>Hexo 支持使用特定的语法，插入指定大小的图片，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 语法</span><br><span class="line">&#123;% img [class names] /path/to/image [width] [height] [title text [alt text]] %&#125;</span><br><span class="line">// 实例</span><br><span class="line">&#123;% img full-image /hexo-experiences/PL01.jpg 180 180 hello %&#125;</span><br><span class="line">// 生成的代码</span><br><span class="line">&lt;img src=&quot;/blog/hexo-experiences/PL01.jpg&quot; class=&quot;full-image&quot; width=&quot;180&quot; height=&quot;180&quot; title=&quot;hello&quot;&gt;</span><br></pre></td></tr></table></figure></li><li><p>如果发现怎么都不行，看下你这个博客是不是在二级域名下的，如果是，要设置_config.yml文件中的url与root。<br><img src="/2019/04/10/first-blog/img4.jpg" alt></p></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  起因，在论坛闲逛的时候发现一个老哥把很多知识点，问题都记录在自己的个人博客里，知识罗列的很清楚。&lt;br&gt;虽然我平时也会把一些问题和有趣的东西记录在MacDown里，可时如果要看的话还需要打开mac，很不方便。so～在网上找了一篇搭建博客的教程，干了一晚上终于成了，中间碰到很多曲折的问题，所以在这里记录一下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、搭建条件及环境&lt;/strong&gt;&lt;br&gt;    Github Pages + Hexo + Node.js Mac电脑的OSX系统/windows&lt;br&gt;&lt;strong&gt;二、搭建步骤&lt;/strong&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="博客" scheme="http://blog.zijunfe.cn/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
  </entry>
  
</feed>
